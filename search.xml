<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>愿你归来再少年</title>
      <link href="/zhb233go.github.io/2022/02/16/35-yuan-ni-gui-lai-zai-shao-nian/"/>
      <url>/zhb233go.github.io/2022/02/16/35-yuan-ni-gui-lai-zai-shao-nian/</url>
      
        <content type="html"><![CDATA[<p>我叫天客，我的背包是我做的自然科学博物馆，这是在骑行的林区路上和徒步的时候大江大河里面经常能捡到的东西，都是一些化石、贝壳之类的，我把它们做成了手链纪念品，供经过的旅人们挑选。</p><p>五六岁我就敢穿越这种森林，去山区里去寻鸟，煮两个青蛙吃，每次回来都会被打脚，在学校里时，跟学生们出去玩，个个都说是我带他们出去的。</p><p>我要去翻蛐蛐，我要去逮蜻蜓，我还要去偷山鸟回来，我还要去沟里面，河里面，那些山青青里面，到了山上，去爬悬崖，我还要走得更远我才满意。</p><p>因为触犯了人间的规矩，没学过也没人教过我。我的父母，她们是艺术家，画家，他们每一步都是规矩，在他们的观念和画里不能有一丝败笔，校长也不允许留下几个成绩不及格的有坏习惯的学生。</p><p>我不喜欢规矩，跟人打交道要规矩，在学校要规矩，在城市要规矩，在庙里遇到了一个和尚说：这是一步一规矩的地方。</p><p>这个地方这么多规矩，不如顺着这条河，顺着这个山峡一直穿越出去，看看山那边是什么样的，在大江大河里，在大石头上睡一觉，就又都忘记掉了。</p><p>我非常喜欢跟人打交流，但要讲规矩。我又不懂规矩，所以我就轻轻的打一下就好，然后就保持距离就完了，望着好看的女生就笑一笑，远远的望着我就觉得非常满足了。</p><p>有一次我遇到了一位男孩，大约有三十岁，我跟他说：“你是我交的最大的朋友”，他说怎么可能，我说因为平时只有小孩子才跟我交流。所以在卖给孩子们东西时，我心里想着把我身上的所有东西都给孩子我都不眨一下眼，因为我觉得我们是同一类人。</p><p>在那些无人区上，那些戈壁滩上，根本想不起还有人类，我只想着明天的草去哪里拔一包装满。一天到晚，找到的小草就手心里一小把，但是刚好够吃，我也觉得是天堂了。</p><p>到了一个新的火山口，一根草都没有，一个蚂蚁没有，一个人没有，一个牛羊没有，一个村庄也没有。只有空气和沙和石头。有时候看到的是一眼看不到边际的荒地，那这片荒地便是我的天堂，取了一把干草吃了，哎呀，又可以往前走了！又可以看远方天边的极光去了，那景象无与伦比，延绵千里的雪山，一眼看不到边的新疆的雪山。</p><p>登山回来，我最高兴的事就是看见一个人，给我激动的，然后他们跟我买东西，我就非常高兴，因为我知道我卖到钱又可以买到吃的，背的。然后我再也不怕我走的有多远了。</p><p>——天客</p><p>——一平凡但不孤独的旅行老人</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《天才在左，疯子在右》读后感</title>
      <link href="/zhb233go.github.io/2022/02/12/34-tian-cai-zai-zuo-feng-zi-zai-you-du-hou-gan/"/>
      <url>/zhb233go.github.io/2022/02/12/34-tian-cai-zai-zuo-feng-zi-zai-you-du-hou-gan/</url>
      
        <content type="html"><![CDATA[<h1 id="《天才在左，疯子在右》读后感"><a href="#《天才在左，疯子在右》读后感" class="headerlink" title="《天才在左，疯子在右》读后感"></a><strong>《天才在左，疯子在右》读后感</strong></h1><p><strong>真理属于人类，谬误属于时代。 —————歌德</strong></p><ul><li><p>维基百科：<strong>天才</strong>（英语：Genius）是指某人展现了卓越的智力、创意。而此创意则通常指在某一或某些领域展现前所未有的洞察力。有天才在风格和独创性规则创造性的高效率，普遍性。在科学上，对天才两个字并没有准确的定义。而天才这个用语模棱两可，也依旧是争论性的议题。天才可以形容一个人的某种特殊才能，也可以用在通晓各方面学问的博学家（通才），例如：亚里士多德、莱布尼兹、艾萨克·牛顿、列奥那多·达芬奇、高斯、尤拉、庞加莱，或是一个领域的佼佼者，例如：阿尔伯特·爱因斯坦，张爱玲，史蒂芬·霍金和莫札特。</p></li><li><p>百度百科：<strong>疯子</strong>，汉语词语，常比喻人的性格、外貌，多用于贬义。有时作为褒义词，表示对人敢打敢拼的一股闯劲的肯定。褒扬大无畏的牺牲精神、奋斗精神、奉献精神。精神病（或称做精神疾病、心理疾病、心理病），主要是一组以表现在行为、心理活动上的紊乱为主的神经系统疾病。研究所得到的结果认为主要是由于家庭、社会环境等外在原因，和患者自身的生理遗传因素、神经生化因素等内在原因相互作用所导致的心理活动、行为、及其神经系统功能紊乱为主要特征的病症。 [1]</p></li></ul><p>从释义解释的天才与疯子有巨大的区别，我理解的天才是在某一领域做到金字塔尖或他的某方面常人难以企及并且比别人更早的达到那个水平；而疯子我理解为你会在某些事走向极端化，死钻牛角尖难以自拔，或是精神上出现疾病以致常人难以理解。</p><p>《天才在左，疯子在右》这本书的作者是一个普通的人，就像许多人一样对这个世界有着许多的疑问难以去解答，但他一次与精神病人的对话使他对精神病人这个群体感到兴趣，随后就与多个病人进行沟通了解，并将对话的内容写成了这本书，带我们可以去了解到精神病人那些奇怪（在我眼里是“奇妙”）的视角看到的世界。</p><p>其中几个让我影响深刻的对话：</p><p>1.<strong>棋子</strong></p><pre class="line-numbers language-none"><code class="language-none">你：“你玩过象棋吧，还有扑克牌？那些游戏的乐趣就在于规则，各种不同的组合，根据各种不同的情况能有千变万化的结果，而且很多事情微妙到没办法形容。国际象棋起源于印度，我不熟悉那个最初的应用，所以不说那个，说中国象棋。中国象棋最初的目的是推演，其实就是古代的实战沙盘。每种不同的棋子，代表的是一种兵种，而且还包括军队性质。象棋里的‘俥’，我费了好大劲才查到，代表是精锐军。那个部队是最好用的，但不是轻易用的，虽然直来直去，但想操控自如可不是一般棋手能做到的。不过，象棋只是打仗而已，不是最精妙的。”我：“那什么是最精妙的？”他：“最精妙是围棋。”我：“为什么？”他：“围棋代表的是真正的智慧！围棋可以说是社会的浓缩，我不能理解围棋是怎么发明的，所以民间对于围棋的起源，有很大的传说性质。你想象一下，各19条平行线交叉，361个点，黑白一共360个棋子，没有高低贵贱之分，完全依靠操纵者的智慧。或者落手绵绵，或者落手铿锵，或者匪夷所思，或者杀声四起。你以为天下在握的时候，突然四面楚歌，生死难卜啊。这是什么？不就是社会吗？依靠的是什么？一个规则，一个简单的规则。棋子呢？就是人。大家都是一样的状态。但是落点决定了你的与众不同，而且每一个都是与众不同！这就是社会啊。我一直坚信，所有的历史、所有的辉煌，都是普通人创造的，而不是那些天才，不是那些聪明人。”我：“有道理是有道理，但是好像你在说宿命论。落点不是取决于自己，而是取决于操纵的那只手。”他：“才不是呢。每一个棋子，都有自己特定的位置，有自己特定的功能，少了一个，会出很大的问题，少了一个甚至全盘皆输。你作为一个棋子，要真正看清自己的位置，你才会明白到底怎么回事儿，也就是所谓全局。我再说一遍：我坚信所有的历史、所有的辉煌，绝对不是聪明人创造出来的，都是普通人创造出来的。而聪明人需要做的只是看清问题所在，顺应一个潮流罢了。实际上，那个聪明人即使不存在，也会有其他聪明人取代。但是，那些普通人，是绝对无法取代的。”  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.<strong>四维虫子</strong></p><pre class="line-numbers language-none"><code class="language-none">我：“可是你怎么能证实你的感觉是正确的，或者说你怎么能证明有谁给你感觉了呢？”他冷冷地看着我：“不用很远，只倒退一百多年，你对一个当时顶尖的物理学家说你拿着一个没有巴掌大、没一本书厚的东西就可以跟远方的人通话，而这要靠围着地球转的卫星和你手机里那个跟指甲盖一样大小的卡片；你可以坐在一个小屏幕前跟千里之外的陌生人交谈，而且还不需要任何连接线；你看地球另一边的球赛只需要按下电视遥控器。他会怎么想？他会认为你一定是疯子！因为那超出当时任何学科的范畴了，列在不可理喻的行列，对吗？”我：“但你说的是感觉。”他：“那只是个词，发现量子之前没人知道量子该叫什么，大多叫作能量什么的。你的思维，还是惯有的物质世界，那是三维的！我要告诉你的是‘四维’，非得用三维框架来描述，我觉得我们没办法沟通。”他再次表示我该滚蛋了。量子物理学教授：“你能告诉我那个四维生物还告诉你什么了吗？”“是绝对四维生物。”他不耐烦地纠正。量子物理学教授：“对，它还给你什么感觉了？”他：“它对我的看法。”我：“是怎么样的呢？”他严肃地转向我：“应该是我们，是对我们的看法。我们对它来说不是现在的样子，因为它的眼界跨越了时间，所以在它看来，我们都是跟蠕动的虫子一样的东西。”我忍不住回头和量子物理学教授对看了一眼。他：“你可以想象得出来，跨越时间地看，我们是一个很长很长的虫子怪物，从床上延伸到大街上，延伸到学校，延伸到公司，延伸到商场，延伸到好多地方。因为我们的动作在每个时间段都是不同的，所以跨越时间来看，我们都是一条条虫子。从某一个时间段开始，到某一个时间段结束。”我和量子物理学教授都愣愣地听着他说。他：“绝对四维生物可以先看到我们死亡，再看到我们出生，没有前后因果。其实这个我很早就理解了：时间不是流逝的，流逝的是我们。”他一字一句地说完后，任凭我们怎么问也不再回答了。那次谈话基本上还是以失败告终。不久后，少年接受了一次特地为他安排的量子物理考试，结果很糟。不知道为什么，我听了有些失望。如果，他真的是个天才，那么他也只能是一百年后，甚至更遥远未来的天才，而不属于我们这个时代——我是说时间段落？也许吧。我至今依旧很想知道，那个所谓的“绝对四维生物”是什么样子。它恐怖吗？我可能永远没办法知道了，即便那是真的。写到这里的时候，莫名地想起歌德说过的一句话：真理属于人类，谬误属于时代。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.<strong>刹那</strong></p><pre class="line-numbers language-none"><code class="language-none">他：“人死前，都会把自己的一生重新经历一遍，对吧？”我：“听说过。”他：“如果现在就是呢？”我：“嗯？你是说……”他：“所以我刚才问你，你有没有过似曾相识的时候？”我愣住了。他：“是的，现在就是！”我被这个想法吓了一跳：“可是……不对吧……从时间上看也不对……吧。”他：“如果你置身其中是无法正确认知到时间流的，不过从感觉上依然能感觉到时间的不稳定性。”我：“我不是太明白，我指时间不稳定性这个说法。”他：“你有没有时间越过越快的感觉？”我仔细回想了一下，好像有。他：“你应该有那种感觉吧，小时候时间似乎很慢、非常慢，但越大时间过得越快，是这样吧？”我：“对，不过，我觉得还是不大对劲……你说的是死前回溯那种……嗯……毕竟只是一刹那，怎么可能会是现在这种当下的感受呢？”他绝望地摇摇头：“在回溯的幻觉中，时间不重要。重要的是对自己一生的体会，回溯结束的时候，就会回到现实——死亡。”我：“可是……”他：“没有可是，实际就是这样的。第一，你似曾相识的感觉是真实的，而不是错觉，因为你自己刚才都承认了，不仅仅是熟悉，甚至还能预知到下一秒即将发生什么，就是说你真的经历过而不是一时的混乱。第二，时间流的不稳定性，时间只是相对的一个概念，并不是一成不变的，过去只是一瞬间，但是你的确都经历过，只有当下是最漫长的。因此我说很有可能我们现在都身处在死亡回溯中——那个刹那。”我：“话是这么说……不过有个悖论存在。”他：“什么悖论？”我：“许多人都有过似曾相识的感受，而且很多人都有时间流不稳定的感受，那他们都是身处在死亡回溯中吗？死亡回溯是相互交集的吗？”他：“每个人只是回溯自己的经历，与别人的交集只是曾经发生过的记忆，当然也就是从自己的角度。我们都是真实的，但现在，没法确定是你的记忆还是我的记忆，这种事情没有办法能证实，除非我们中的一个回溯结束，离开回忆，面对死亡。也许还要很久，也许就是下一秒。”我突然觉得很压抑。过了一会儿，他盯着我的眼睛一字一句地说：“在真实来临之前，你无法证明自己不在虚幻中。”<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这几个故事中，那些被人称为精神病人的思想是令我感到惊讶的，因为他们所想的都是我们常人难以想象的事物，所以如果跟人说的话就会被当成精神病人，但他们所描述的事件的逻辑性、思维性确实很完整，令人无法反驳。</p><p>在作者所遇见的病人中，有的就是钻牛角尖，有的是精神分裂，有的是想的事情太深难以自拔而造成人们的难以理解。</p><p>读完本书，作者带我进入到一个完全不同的世界，去认识的那些常人难以理解的<strong>“怪人”</strong>的思想，使我认识的在事情的认知和那些不同寻常的人的区别，作者的核心理念就是：我们认知的疯子与天才其实只有一线之隔，他们的共同点都是在某方面与常人有明显差距或不相同的，而他们的这些突出能力是否能被常人接受则与现实所影响。</p><p>就像梵高一样，在他所处的时代，他的画作并不受当时人们所接受，时过境迁他的画被奉为天才所作。所以天才只是生不逢时，常人难以理解，或许多年以后的人在看作者所写的书会觉得在正常不过了。。。</p><p>总之，非常推荐大家去阅读原书。。。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
            <tag> 好书推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列、堆、栈、堆栈的区别与defer的关系</title>
      <link href="/zhb233go.github.io/2022/02/12/33-dui-lie-dui-zhan-dui-zhan-de-qu-bie-yu-defer-de-guan-xi/"/>
      <url>/zhb233go.github.io/2022/02/12/33-dui-lie-dui-zhan-dui-zhan-de-qu-bie-yu-defer-de-guan-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="队列、堆、栈、堆栈的区别"><a href="#队列、堆、栈、堆栈的区别" class="headerlink" title="队列、堆、栈、堆栈的区别"></a>队列、堆、栈、堆栈的区别</h1><h3 id="堆栈：先进后出（就像放在箱子的衣服，先放进去的后拿出来）"><a href="#堆栈：先进后出（就像放在箱子的衣服，先放进去的后拿出来）" class="headerlink" title="堆栈：先进后出（就像放在箱子的衣服，先放进去的后拿出来）"></a>堆栈：先进后出（就像放在箱子的衣服，先放进去的后拿出来）</h3><h3 id="队列：先进先出（就像一条路，有一个入口和一个出口，先进去的就可以先出去）"><a href="#队列：先进先出（就像一条路，有一个入口和一个出口，先进去的就可以先出去）" class="headerlink" title="队列：先进先出（就像一条路，有一个入口和一个出口，先进去的就可以先出去）"></a>队列：先进先出（就像一条路，有一个入口和一个出口，先进去的就可以先出去）</h3><p>进程中每个线程都有自己的<strong>堆栈</strong>，这是一段线程创建时保留下的地址区域。我们的“<strong>栈内存</strong>”即在此。<br>至于“<strong>堆</strong>”内存，我个人认为在未用new定义时，<strong>堆</strong>应该就是未“保留”未“提交”的自由空间，new的功能是在这些自由空间中保留（并提交）出一个地址范围。</p><p><strong>栈</strong>(Stack)是操作系统在建立某个进程时或者线程（在支持多线程的操作系统中是线程）为这个线程建立的存储区域，该区域具有FIFO的特性，在编译的时候可以指定需要的Stack的大小。在编程中，例如C/C++中，所有的局部变量都是从<strong>栈</strong>中分配内存空间，实际上也不是什么分配，只是从<strong>栈顶</strong>向上用就行，在退出函数的时候，只是修改<strong>栈指针</strong>就可以把<strong>栈</strong>中的内容销毁，所以速度最快。</p><p><strong>堆</strong>（Heap)是应用程序在运行的时候请求操作系统分配给自己内存，一般是申请/给予的过程，C/C++分别用malloc/New请求分配Heap，用free/delete销毁内存。由于从操作系统管理的内存分配所以在分配和销毁时都要占用时间，所以用<strong>堆</strong>的效率低的多！但是<strong>堆</strong>的好处是可以做的很大，C/C++对分配的Heap是不初始化的。</p><p>在Java中除了简单类型（int,char等）都是在<strong>堆</strong>中分配内存，这也是程序慢的一个主要原因。但是跟C/C++不同，Java中分配Heap内存是自动初始化的。在Java中所有的对象（包括int的wrapper  Integer）都是在<strong>堆</strong>中分配的，但是这个对象的引用却是在Stack中分配。也就是说在建立一个对象时从两个地方都分配内存，在Heap中分配的内存实际建立这个对象，而在Stack中分配的内存只是一个指向这个<strong>堆</strong>对象的指针（引用）而已。</p><p><strong>堆</strong>是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。{<strong>堆</strong>是指程序运行是申请的动态内存，而栈只是指一种使用<strong>堆</strong>的<strong>方法</strong>(即<strong>先进后出</strong>)。}</p><p><strong>栈</strong>是先进后出的，但是于<strong>堆</strong>而言却没有这个特性，两者都是存放临时数据的地方。 对于<strong>堆</strong>，我们可以随心所欲的进行增加变量和删除变量，不要遵循什么次序，只要你喜欢。</p><p>###在同一个goroutine中：多个defer的调用栈原理是什么？</p><p>defer函数是如何调用的?</p><p>为了探究其中的奥秘我准备了如下代码：</p><pre class="line-numbers language-none"><code class="language-none">package mainimport "fmt"func main() {xx()}func xx() {defer aaa(100, "hello aaa")defer bbb("hello bbb")return}func aaa(x int, arg string) {fmt.Println(x, arg)}func bbb(arg string) {fmt.Println(arg)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><p>bbb</p><p>100 hello aaa</p><p>从输出结果看很像栈的数据结构特性：后进先出(LIFO).</p><p>对于如下所示的 defer 语句</p><pre class="line-numbers language-none"><code class="language-none">func x() {.......defer y(......).......}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，编译器会把 defer 语句翻译成对 deferproc 函数的调用，deferproc 负责构造一个用来保存 y 函数的地址以及 y 函数需要用到的参数的 _defer 结构体对象，并把该对象加入当前 goroutine 对应的 g 结构体对象的 _defer 链表表头；</p><p>然后，编译器会在 x 函数的结尾处插入对 deferreturn 的调用，deferreturn 负责递归的调用 x 函数通过 defer 语句注册的函数。</p><p>总体说来，在不考虑 panic/recover 的情况下，go语言对 defer 的实现机制还是比较简单，但其具体实现细节还是有很多地方值得我们仔细思考和学习的。</p><p>最后，defer函数虽然方便，但是需要有额外的运行开销，在使用时需要进行取舍，尤其是具有多个参数的时候，会发生多次内存拷贝：</p><p>runtime.deferproc执行之前：移动到栈中<br>runtime.deferproc执行过程中，拷贝_defer之后<br>runtime.deferreturn执行时，移动到栈中</p><p>update：go1.13对defer进行了优化，如果_defer没有发生逃逸，则将其分配在栈上，可以提高30%的性能。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Golang </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go程序员开发效率神器汇总！</title>
      <link href="/zhb233go.github.io/2022/02/09/go-cheng-xu-yuan-kai-fa-xiao-lu-shen-qi-hui-zong/"/>
      <url>/zhb233go.github.io/2022/02/09/go-cheng-xu-yuan-kai-fa-xiao-lu-shen-qi-hui-zong/</url>
      
        <content type="html"><![CDATA[<p>neon 是鹅厂的一位资深后台开发工程师，多年工作下来他总结了很多效率神器，今天分享给大家。</p><h2 id="一-开发工具"><a href="#一-开发工具" class="headerlink" title="一. 开发工具"></a>一. 开发工具</h2><p>1)sql2go<br>用于将 sql 语句转换为 golang 的 struct. 使用 ddl 语句即可。<br>例如对于创建表的语句: show create table xxx. 将输出的语句，直接粘贴进去就行。<br><a href="http://stming.cn/tool/sql2go.html">http://stming.cn/tool/sql2go.html</a></p><p>2)toml2go<br>用于将编码后的 toml 文本转换问 golang 的 struct.<br><a href="https://xuri.me/toml-to-go/">https://xuri.me/toml-to-go/</a></p><p>3)curl2go<br>用来将 curl 命令转化为具体的 golang 代码.<br><a href="https://mholt.github.io/curl-to-go/">https://mholt.github.io/curl-to-go/</a></p><p>4)json2go<br>用于将 json 文本转换为 struct.<br><a href="https://mholt.github.io/json-to-go/">https://mholt.github.io/json-to-go/</a></p><p>5)mysql 转 ES 工具<br><a href="http://www.ischoolbar.com/EsParser/">http://www.ischoolbar.com/EsParser/</a></p><p>6)golang<br>模拟模板的工具，在支持泛型之前，可以考虑使用。<br><a href="https://github.com/cheekybits/genny">https://github.com/cheekybits/genny</a></p><p>7)查看某一个库的依赖情况，类似于 go list 功能<br><a href="https://github.com/KyleBanks/depth">https://github.com/KyleBanks/depth</a></p><p>8)一个好用的文件压缩和解压工具，集成了 zip，tar 等多种功能，主要还有跨平台。<br><a href="https://github.com/mholt/archiver">https://github.com/mholt/archiver</a></p><p>9)go 内置命令<br>go list 可以查看某一个包的依赖关系.<br>go vet 可以检查代码不符合 golang 规范的地方。</p><p>10)热编译工具<br><a href="https://github.com/silenceper/gowatch">https://github.com/silenceper/gowatch</a></p><p>11)revive<br>golang 代码质量检测工具<br><a href="https://github.com/mgechev/revive">https://github.com/mgechev/revive</a></p><p>12)Go Callvis<br>golang 的代码调用链图工具<br><a href="https://github.com/TrueFurby/go-callvis">https://github.com/TrueFurby/go-callvis</a></p><p>13)Realize<br>开发流程改进工具<br><a href="https://github.com/oxequa/realize">https://github.com/oxequa/realize</a></p><p>14)Gotests<br>自动生成测试用例工具<br><a href="https://github.com/cweill/gotests">https://github.com/cweill/gotests</a></p><h2 id="二-调试工具"><a href="#二-调试工具" class="headerlink" title="二.调试工具"></a>二.调试工具</h2><p>1)perf<br>代理工具，支持内存，cpu，堆栈查看，并支持火焰图.<br>perf 工具和 go-torch 工具，快捷定位程序问题.<br><a href="https://github.com/uber-archive/go-torch">https://github.com/uber-archive/go-torch</a><br><a href="https://github.com/google/gops">https://github.com/google/gops</a></p><p>2)dlv 远程调试<br>基于 goland+dlv 可以实现远程调式的能力.<br><a href="https://github.com/go-delve/delve">https://github.com/go-delve/delve</a><br>提供了对 golang 原生的支持，相比 gdb 调试，简单太多。</p><p>3)网络代理工具<br>goproxy 代理，支持多种协议，支持 ssh 穿透和 kcp 协议.<br><a href="https://github.com/snail007/goproxy">https://github.com/snail007/goproxy</a></p><p>4)抓包工具<br>go-sniffer 工具，可扩展的抓包工具，可以开发自定义协议的工具包. 现在只支持了 http，mysql，redis，mongodb.<br>基于这个工具，我们开发了 qapp 协议的抓包。<br><a href="https://github.com/40t/go-sniffer">https://github.com/40t/go-sniffer</a></p><p>5)反向代理工具，快捷开放内网端口供外部使用。<br>ngrok 可以让内网服务外部调用<br><a href="https://ngrok.com/">https://ngrok.com/</a><br><a href="https://github.com/inconshreveable/ngrok">https://github.com/inconshreveable/ngrok</a></p><p>6)配置化生成证书<br>从根证书，到业务侧证书一键生成.<br><a href="https://github.com/cloudflare/cfssl">https://github.com/cloudflare/cfssl</a></p><p>7)免费的证书获取工具<br>基于 acme 协议，从 letsencrypt 生成免费的证书，有效期 1 年，可自动续期。<br><a href="https://github.com/Neilpang/acme.sh">https://github.com/Neilpang/acme.sh</a></p><p>8)开发环境管理工具，单机搭建可移植工具的利器。支持多种虚拟机后端。<br>vagrant常被拿来同 docker 相比，值得拥有。<br><a href="https://github.com/hashicorp/vagrant">https://github.com/hashicorp/vagrant</a></p><p>9)轻量级容器调度工具<br>nomad 可以非常方便的管理容器和传统应用，相比 k8s 来说，简单不要太多.<br><a href="https://github.com/hashicorp/nomad">https://github.com/hashicorp/nomad</a></p><p>10)敏感信息和密钥管理工具<br><a href="https://github.com/hashicorp/vault">https://github.com/hashicorp/vault</a></p><p>11)高度可配置化的 http 转发工具，基于 etcd 配置。<br><a href="https://github.com/gojek/weaver">https://github.com/gojek/weaver</a></p><p>12)进程监控工具 supervisor<br><a href="https://www.jianshu.com/p/39b476e808d8">https://www.jianshu.com/p/39b476e808d8</a></p><p>13)基于procFile进程管理工具. 相比 supervisor 更加简单。<br><a href="https://github.com/ddollar/foreman">https://github.com/ddollar/foreman</a></p><p>14)基于 http，https，websocket 的调试代理工具，配置功能丰富。在线教育的 nohost web 调试工具，基于此开发.<br><a href="https://github.com/avwo/whistle">https://github.com/avwo/whistle</a></p><p>15)分布式调度工具<br><a href="https://github.com/shunfei/cronsun/blob/master/README_ZH.md">https://github.com/shunfei/cronsun/blob/master/README_ZH.md</a><br><a href="https://github.com/ouqiang/gocron">https://github.com/ouqiang/gocron</a></p><p>16)自动化运维平台 Gaia<br><a href="https://github.com/gaia-pipeline/gaia">https://github.com/gaia-pipeline/gaia</a></p><h2 id="三-网络工具"><a href="#三-网络工具" class="headerlink" title="三. 网络工具"></a>三. 网络工具</h2><p><img src="https://hypo-pictrue-1308430808.cos.ap-shanghai.myqcloud.com/hypo.ltd-%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8/640.webp"></p><h2 id="四-常用网站"><a href="#四-常用网站" class="headerlink" title="四. 常用网站"></a>四. 常用网站</h2><p>go 百科全书: <a href="https://awesome-go.com/">https://awesome-go.com/</a></p><p>json 解析: <a href="https://www.json.cn/">https://www.json.cn/</a></p><p>出口 IP: <a href="https://ipinfo.io/">https://ipinfo.io/</a></p><p>redis 命令: <a href="http://doc.redisfans.com/">http://doc.redisfans.com/</a></p><p>ES 命令首页:</p><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html">https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html</a></p><p>UrlEncode: <a href="http://tool.chinaz.com/Tools/urlencode.aspx">http://tool.chinaz.com/Tools/urlencode.aspx</a></p><p>Base64: <a href="https://tool.oschina.net/encrypt?type=3">https://tool.oschina.net/encrypt?type=3</a></p><p>Guid: <a href="https://www.guidgen.com/">https://www.guidgen.com/</a></p><p>常用工具: <a href="http://www.ofmonkey.com/">http://www.ofmonkey.com/</a></p><h2 id="五-golang-常用库"><a href="#五-golang-常用库" class="headerlink" title="五. golang 常用库"></a>五. golang 常用库</h2><p>日志<br><a href="https://github.com/Sirupsen/logrus">https://github.com/Sirupsen/logrus</a><br><a href="https://github.com/uber-go/zap">https://github.com/uber-go/zap</a></p><p>配置<br>兼容 json，toml，yaml，hcl 等格式的日志库.<br><a href="https://github.com/spf13/viper">https://github.com/spf13/viper</a></p><p>存储<br>mysql: <a href="https://github.com/go-xorm/xorm">https://github.com/go-xorm/xorm</a><br>es: <a href="https://github.com/elastic/elasticsearch">https://github.com/elastic/elasticsearch</a><br>redis: <a href="https://github.com/gomodule/redigo">https://github.com/gomodule/redigo</a><br>mongo: <a href="https://github.com/mongodb/mongo-go-driver">https://github.com/mongodb/mongo-go-driver</a><br>kafka: <a href="https://github.com/Shopify/sarama">https://github.com/Shopify/sarama</a></p><p>数据结构<br><a href="https://github.com/emirpasic/gods">https://github.com/emirpasic/gods</a></p><p>命令行<br><a href="https://github.com/spf13/cobra">https://github.com/spf13/cobra</a></p><p>框架<br><a href="https://github.com/grpc/grpc-go">https://github.com/grpc/grpc-go</a><br><a href="https://github.com/gin-gonic/gin">https://github.com/gin-gonic/gin</a></p><p>并发<br><a href="https://github.com/Jeffail/tunny">https://github.com/Jeffail/tunny</a><br><a href="https://github.com/benmanns/goworker">https://github.com/benmanns/goworker</a><br>现在我们框架在用的，虽然 star 不多，但是确实好用，当然还可以更好用.<br><a href="https://github.com/rafaeldias/async">https://github.com/rafaeldias/async</a></p><p>工具<br>定义了实用的判定类，以及针对结构体的校验逻辑，避免业务侧写复杂的代码.<br><a href="https://github.com/asaskevich/govalidator">https://github.com/asaskevich/govalidator</a><br><a href="https://github.com/bytedance/go-tagexpr">https://github.com/bytedance/go-tagexpr</a></p><p>protobuf 文件动态解析的接口，可以实现反射相关的能力。<br><a href="https://github.com/jhump/protoreflect">https://github.com/jhump/protoreflect</a></p><p>表达式引擎工具<br><a href="https://github.com/Knetic/govaluate">https://github.com/Knetic/govaluate</a><br><a href="https://github.com/google/cel-go">https://github.com/google/cel-go</a></p><p>字符串处理<br><a href="https://github.com/huandu/xstrings">https://github.com/huandu/xstrings</a></p><p>ratelimit 工具<br><a href="https://github.com/uber-go/ratelimit">https://github.com/uber-go/ratelimit</a><br><a href="https://blog.csdn.net/chenchongg/article/details/85342086">https://blog.csdn.net/chenchongg/article/details/85342086</a><br><a href="https://github.com/juju/ratelimit">https://github.com/juju/ratelimit</a></p><p>golang 熔断的库<br>熔断除了考虑频率限制，还要考虑 qps，出错率等其他东西.<br><a href="https://github.com/afex/hystrix-go">https://github.com/afex/hystrix-go</a><br><a href="https://github.com/sony/gobreaker">https://github.com/sony/gobreaker</a></p><p>表格<br><a href="https://github.com/chenjiandongx/go-echarts">https://github.com/chenjiandongx/go-echarts</a></p><p>tail 工具库<br><a href="https://github.com/hpcloud/taglshi">https://github.com/hpcloud/taglshi</a></p><p>转自<br><a href="https://mp.weixin.qq.com/s/WjaHJHE7ZPbgo7QwIDwZzQ">https://mp.weixin.qq.com/s/WjaHJHE7ZPbgo7QwIDwZzQ</a><br>感谢大佬分享！！</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Galang </tag>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人与人之间的悲喜并不相通</title>
      <link href="/zhb233go.github.io/2022/01/24/32-ren-yu-ren-zhi-jian-de-bei-xi-bing-bu-xiang-tong/"/>
      <url>/zhb233go.github.io/2022/01/24/32-ren-yu-ren-zhi-jian-de-bei-xi-bing-bu-xiang-tong/</url>
      
        <content type="html"><![CDATA[<p>今天照常打开新闻，偶然间看到一篇热点新闻，标题是“寻亲男孩…自杀”，我就好奇点进去看了一下，男孩自杀前写了一封遗书，述说了自己普通但惨淡的一生，他述说自己在记事起，父母就因为事故去世了，从小和姥姥生活，并且遭受了旁人的欺负中成长。后来偶然间发现自己在婴儿时期就被自己真正的亲生父母卖了，所以他想寻找自己丢失的亲情，他的事迹就被发到网上发酵，一些不明事理就随意诽谤他加恶言相向。他才15岁，在他的惨淡的一生中，他将自己的悲伤藏在心地，希望给被人一点阳光的形象，希望别人能够善待他。但是，在这个人人自己的时代，大多数的人并不会对你的事情你的心理你的生活有同情，因为他们不是你，不要尝试改变其他人的想法，最终你只会自食其果。人与人之间的内心并不相通，但是可以通过其他的事物，表达出来，在看过他的遗书并了解到他的一生后，我对他表示同情。不仅仅是对他的人生，也是对像他这样在网上遭受网络暴力的人们，人间是不美好的，希望他在另一个世界不再痛苦，能和自己的父母快乐的生活。</p><p>在后面引用一句话送给网络施暴者：</p><p>如果我永远忘不掉，你们也别想忘掉，你们骂过我最难听的词，你们动手的没动手的都一样，你们比石头还冷漠，你们又恶毒又愚蠢，你们胆小怕事，别人做什么你就跟着做什么，你们巴不得世界上多死一个人，因为你们日子真的无聊，因为你们觉得自己不会承担任何后果，杀死顾森湘的凶手我不知道是谁，但杀死我的凶手，就都在这里了！———影视剧照进现实！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPFS-可快速索引的版本化的点对点文件系统</title>
      <link href="/zhb233go.github.io/2022/01/21/31-ipfs-ke-kuai-su-suo-yin-de-ban-ben-hua-de-dian-dui-dian-wen-jian-xi-tong/"/>
      <url>/zhb233go.github.io/2022/01/21/31-ipfs-ke-kuai-su-suo-yin-de-ban-ben-hua-de-dian-dui-dian-wen-jian-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="IPFS-可快速索引的版本化的点对点文件系统（草稿3）"><a href="#IPFS-可快速索引的版本化的点对点文件系统（草稿3）" class="headerlink" title="IPFS - 可快速索引的版本化的点对点文件系统（草稿3）"></a>IPFS - 可快速索引的版本化的点对点文件系统（草稿3）</h1><p>作者： Juan Benet (<a href="mailto:juan@benet.ai">juan@benet.ai</a>)<br>译者： 郭光华(<a href="mailto:gavin@8btc.com">gavin@8btc.com</a>)</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>星际文件系统是一种点对点的分布式文件系统， 旨在连接所有有相同的文件系统的计算机设备。在某些方面， IPFS类似于web, 但web 是中心化的，而IPFS是一个单一的Bittorrent 群集， 用git 仓库分布式存储。换句话说， IPFS 提供了高吞吐量的内容寻址块存储模型， 具有内容寻址的超链接。这形成了一个广义的Merkle DAG 数据结构，可以用这个数据结构构建版本文件系统，区块链，甚至是永久性网站。。IPFS 结合了分布式哈希表， 带有激励机制的块交换和自我认证命名空间。IPFS 没有单故障点， 节点不需要相互信任。</p><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>   在全球分布式文件系统这领域， 已经有许多人的尝试。一些系统已经取得了重大的成功， 而很多却完全失败了。在学术尝试中， AFS【6】就是成功的例子，如今已经得到广泛的应用， 然而，其他的【7， ？】却没有得到相同的结果。在学术界之外，应用最广泛的是面向音视频媒体的点对点文件共享系统。 最值得注意的是， Napster, KaZaA 和BitTorrent[2]部署的文件分发系统支持1亿用户的同时在线。即使在今天， BitTorrent 也维持着每天千万节点的活跃数。 基于这些学术文件系统理论而实现的应用程序有很多的用户量， 然而，这些系统理论是在应用层，而没有放在基础层。以致没有出现通用的文件系统基础框架， 给全球提供低延迟的分发。<br>   也许是因为HTTP这样“足够好“的系统已经存在。到目前为止，HTTP已经作为“分布式文件系统“的协议，并且已经大量部署，再与浏览器相结合，具有巨大的技术和社会影响力。在现在， 它已经成为互联网传输文件的事实标准。然而，他没有采用最近15年的发明的数十种先进的文件分发技术。 从一方面讲， 由于向后兼容的限制 和 当前新模式的投入， 不断发展http web 的基础设施几乎是不可能的。但从一个角度看， 从http 出现以来， 已经有许多新协议出现并被广泛使用。升级http协议虽然能引入新功能和加强当前http协议，但会降低用户的体验。<br>   有些行业已经摆脱使用HTTP 这么久， 因为移动小文件相对便宜，即使对拥有大流量的小组织也是如此。但是，随着新的挑战，我们正在进入数据分发的新纪元。</p><p>（a）托管和分发PB级数据集，<br>（b）跨组织的大数据计算，<br>（c）大批量的高清晰度按需或实时媒体流，<br>（d）大规模数据集的版本化和链接，<br>（e）防止意外丢失重要文件等。其中许多可以归结为“大量数据，无处不在”。由于关键功能和带宽问题，我们已经为不同的数据放弃了HTTP 分销协议。下一步是使它们成为web自己的一部分。<br>正交于有效的数据分发，版本控制系统，已经设法开发重要的数据协作工作流程。Git是分布式源代码版本控制系统，开发了许多有用的方法来建模和实现分布式数据操作。Git工具链提供了灵活的版本控制功能，这正是大量的文件分发系统所严重缺乏的。由Git启发的新解决方案正在出现，如Camlistore [？]，个人文件存储系统，Dat [？]数据协作工具链和数据集包管理器。Git已经影响了分布式文件系统设计[9]，因为其内容涉及到Merkle DAG数据模型，能够实现强大的文件分发策略。还有待探讨的是，这种数据结构如何影响面向高吞吐量的文件系统的设计，以及如何升级Web本身。<br>本文介绍了IPFS，一种新颖的对等版本控制的文件系统，旨在调和这些问题。 IPFS综合了许多以前成功的系统的优点。 IPFS产生了突出的效果， 甚至比参考的这些系统的总和还要好。IPFS的核心原则是将所有数据建模为同一Merkle DAG的一部分。</p><h3 id="2-背景"><a href="#2-背景" class="headerlink" title="2. 背景"></a>2. 背景</h3><p>   本节回顾了IPFS所采用成功的点对点系统技术的重要属性。</p><h4 id="2-1-分布式哈希表-DHT"><a href="#2-1-分布式哈希表-DHT" class="headerlink" title="2.1 分布式哈希表(DHT)"></a>2.1 分布式哈希表(DHT)</h4><p>   分布式散列表（DHT）被广泛用于协调和维护关于对等系统的元数据。比如，MainlineDHT 是一个去中心化哈希表，他可追踪查找所有的对等节点。</p><h5 id="2-1-1-KADEMLIA-DHT"><a href="#2-1-1-KADEMLIA-DHT" class="headerlink" title="2.1.1 KADEMLIA DHT"></a>2.1.1 KADEMLIA DHT</h5><p>   Kademlia[10] 是受欢迎的DHT, 它提供：<br>   1.通过大量网络进行高效查询：查询平均联系人O(log2N)节点。 （例如，20跳10万个节点的网络）<br>   2.低协调开销：优化数量的控制消息发送到其他节点。<br>   3.抵抗各种攻击，喜欢长寿节点。<br>   4.在对等应用中广泛使用，包括Gnutella和BitTorrent，形成了超过2000万个节点的网络[16]。</p><h5 id="2-1-2-CORAL-DSHT"><a href="#2-1-2-CORAL-DSHT" class="headerlink" title="2.1.2 CORAL DSHT"></a>2.1.2 CORAL DSHT</h5><p>   虽然一些对等文件系统直接在DHT中存储数据块，这种“数据存储在不需要的节点会乱费存储和带宽”[5]。Coral DSHT扩展了Kademlia三个特别重要的方式：</p><p>1.Kademlia在ids为“最近”（使用XOR-distance）的关键节点中存储值。这不考 虑应用程序数据的局部性，忽略“远”可能已经拥有数据的节点，并强制“最近”节点存储它，无论它们是否需要。这浪费了大量的存储和带宽。相反，Coral 存储了地址， 该地址的对等节点可以提供相应的数据块。<br>2.Coral将DHT API从get_value(key)换成了get_any_values(key)（DSHT中的“sloppy”）中。这仍然是因为Coral用户只需要一个（工作）的对等体，而不是完整的列表。作为回报，Coral可以仅将子集分配到“最近”的节点，避免热点（当密钥变得流行时，重载所有最近的节点）。<br>3.另外，Coral根据区域和大小组织了一个称为群集的独立DSHT层次结构。这使得节点首先查询其区域中的对等体，“查找附近的数据而不查询远程节点”[5]并大大减少查找的延迟。</p><h5 id="2-1-3-S-KADEMLIA-DHT"><a href="#2-1-3-S-KADEMLIA-DHT" class="headerlink" title="2.1.3 S/KADEMLIA DHT"></a>2.1.3 S/KADEMLIA DHT</h5><p>S/Kademlia[1] 扩展了Kademlia, 用于防止恶意的攻击。有如下两方面的方法：<br>1.S/Kad 提供了方案来保证NodeId的生成已经防止Sybill攻击。它需要节点产生PKI公私钥对。从中导出他们的身份，并彼此间签名。一个方案使用POW工作量证明，使得生成Sybills成本高昂。<br>2.S/Kad 节点在不相交的路径上查找直， 即使网络中存在大量的不诚实节点，也能确保诚实节点可以互相链接。即使网络中存在一半的不诚实节点，S/Kad 也能达到85%的成功率。</p><h4 id="2-2-块交换-BitTorrent"><a href="#2-2-块交换-BitTorrent" class="headerlink" title="2.2 块交换 - BitTorrent"></a>2.2 块交换 - BitTorrent</h4><p>BitTorrent[3] 是一个广泛成功应用的点对点共享文件系统，它可以在存在不信任的对等节点（群集）的协作网络中分发各自的文件数据片。从BitTorrent和它的生态系统的关键特征， IPFS得到启示如下：<br>1.BitTorrent的数据交换协议使用了一种bit-for-tat的激励策略， 可以奖励对其他方面做贡献的节点，惩罚只榨取对方资源的节点。<br>2.BitTorrent对等体跟踪文件的可用性，优先发送稀有片段。这减轻了seeds节点的负担， 让non-seeds节点有能力互相交易。<br>3.对于一些剥削带宽共享策略， BitTorrent的标准tit-for-tat策略是非常脆弱的。 然而，PropShare[8]是一种不同的对等带宽分配策略， 可以更好的抵制剥削战略， 提高群集的表现。</p><h4 id="2-3-版本控制系统-Git"><a href="#2-3-版本控制系统-Git" class="headerlink" title="2.3. 版本控制系统- Git"></a>2.3. 版本控制系统- Git</h4><p>版本控制系统提供了对随时间变化的文件进行建模的设施，并有效地分发不同的版本。流行版本控制系统Git提供了强大的Merkle DAG对象模型，以分布式友好的方式捕获对文件系统树的更改。<br>1.不可更改的对象表示文件（blob），目录（树）和更改（提交）。<br>2.通过加密hash对象的内容，让对象可寻址。<br>3.链接到其他对象是嵌入的，形成一个Merkle DAG。这提供了很多有用的完整和work-flow属性。<br>4.很多版本元数据（分支，标示等等）都只是指针引用，因此创建和更新的代价都小。<br>5.版本改变只是更新引用或者添加对象。<br>6.分布式版本改变对其他用户而言只是转移对象和更新远程引用。</p><h4 id="2-4-自我认证认文件系统-SFS"><a href="#2-4-自我认证认文件系统-SFS" class="headerlink" title="2.4 自我认证认文件系统-SFS"></a>2.4 自我认证认文件系统-SFS</h4><p>SFS [ 12，11 ]提出了两个引人注目的实现（a）分布式信任链，和（b）平等共享的全局命名空间。SFS引入了一种自我建构技术—注册文件：寻址远程文件系统使用以下格式：</p><pre class="line-numbers language-none"><code class="language-none">/sfs/&lt;Location&gt;:&lt;HostID&gt;Location:代表的是服务网络地方HostID = hash(public_key || Location)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>因此SFS文件系统的名字认证了它的服务，用户可以通过服务提供的公钥来验证，协商一个共享的私钥，保证所有的通信。所有的SFS实例都共享了一个全局的命名空间，这个命名空间的名称分配是加密的，不被任何中心化的body控制。</p><h3 id="3-IPFS设计"><a href="#3-IPFS设计" class="headerlink" title="3. IPFS设计"></a>3. IPFS设计</h3><p>   IPFS是一个分布式文件系统，它综合了以前的对等系统的成功想法，包括DHT，BitTorrent，Git和SFS。 IPFS的贡献是简化，发展和将成熟的技术连接成一个单一的内聚系统，大于其部分的总和。 IPFS提供了编写和部署应用程序的新平台，以及一个新的分发系统版本化大数据。 IPFS甚至可以演进网络本身。<br>   IPFS是点对点的;没有节点是特权的。 IPFS节点将IPFS对象存储在本地存储中。节点彼此连接并传输对象。这些对象表示文件和其他数据结构。 IPFS协议分为一组负责不同功能的子协议：</p><ol><li>身份 - 管理节点身份生成和验证。描述在3.1节。<br>2.网络 - 管理与其他对等体的连接，使用各种底层网络协议。可配置的。详见3.2节。<br>3.路由 - 维护信息以定位特定的对等体和对象。响应本地和远程查询。默认为DH​​T，但可更换。在3.3节描述。<br>4.交换 - 一种支持有效块分配的新型块交换协议（BitSwap）。模拟市场，弱化数据复制。贸易策略可替换。描述在3.4节。<br>5.对象 - 具有链接的内容寻址不可更改对象的Merkle DAG。用于表示任意数据结构，例如文件层次和通信系统。详见第3.5节。<br>6.文件 - 由Git启发的版本化文件系统层次结构。详见3.6节。<br>7.命名 - 自我认证的可变名称系统。详见3.7节。<br>这些子系统不是独立的;它们是集成在一起，互相利用各自的属性。但是，分开描述它们是有用的，从下到上构建协议栈。符号：Go语言中指定了以下数据结构和功能</li></ol><h4 id="3-1-身份"><a href="#3-1-身份" class="headerlink" title="3.1 身份"></a>3.1 身份</h4><p>节点由NodeId标识，这是使用S / Kademlia的静态加密难题[1]创建的公钥的密码散列。节点存储其公私钥（用密码加密）。用户可以在每次启动时自由地设置一个“新”节点身份，尽管这会损失积累的网络利益。激励节点保持不变。</p><pre class="line-numbers language-none"><code class="language-none">type NodeId Multihashtype Multihash []byte  // 自描述加密哈希摘要type PublicKey []bytetype PrivateKey []byte // 自描述的私钥type Node struct {NodeId NodeIDPubKey PublicKeyPriKey PrivateKey}基于S / Kademlia的IPFS身份生成：difficulty = &lt;integer parameter&gt;n = Node{}do {n.PubKey, n.PrivKey = PKI.genKeyPair()n.NodeId = hash(n.PubKey)p = count_preceding_zero_bits(hash(n.NodeId))} while (p &lt; difficulty)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首次连接时，对等体交换公钥，并检查：hash（other.PublicKey）等于other.NodeId。如果没有，则连接被终止<br>关于加密函数的注意事项：<br>IPFS不是将系统锁定到一组特定的功能选择，而是支持自我描述的值。哈希摘要值以多重哈希格式存储，其包括指定使用的哈希函数的头和以字节为单位的摘要长度。例如：</p><p>1<br><function code=""><digest length=""><digest bytes=""><br>这允许系统</digest></digest></function></p><p>（a）选择最佳功能用例（例如，更强的安全性与更快的性能），<br>（b）随着功能选择的变化而演变。自描述值允许兼容使用不同的参数选择。</p><h4 id="3-2-网络"><a href="#3-2-网络" class="headerlink" title="3.2 网络"></a>3.2 网络</h4><p>IPFS节点与数百个其他节点进行定期通信网络中的节点，可能跨越广域网络。IPFS网络堆栈功能：<br>传输层： IPFS可以使用任何传输协议，并且最适合WebRTC DataChannels [？]（用于浏览器连接）或uTP（LEDBAT [14]）。<br>可靠性： 如果底层网络不提供可靠性，IPFS可使用uTP（LEDBAT [14]）或SCTP [15]来提供​​可靠性。<br>可连接性：IPFS还可以使用ICE NAT穿墙打洞技术[13]。<br>完整性：可以使用哈希校验和来检查邮件的完整性。<br>可验证性：可以使用发送者的公钥使用HMAC来检查消息的真实性。<br>3.2.1对等节点寻址注意事项：<br>IPFS可以使用任何网络; 但它不承担对IP的获取以及不直接依赖于ip层。这允许在覆盖网络中使用IPFS。<br>IPFS将地址存储为多层地址，这个多层地址是由字节字符串组成的， 以便于给底层网络使用。多层地址提供了一种方式来表示地址及其协议，可以封装成好解析的格式。例如：</p><pre class="line-numbers language-none"><code class="language-none"># an SCTP/IPv4 connection/ip4/10.20.30.40/sctp/1234/# an SCTP/IPv4 connection proxied over TCP/IPv4/ip4/5.6.7.8/tcp/5678/ip4/1.2.3.4/sctp/1234/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-路由"><a href="#3-3-路由" class="headerlink" title="3.3 路由"></a>3.3 路由</h4><p>IPFS节点需要一个路由系统， 这个路由系统可用于查找：</p><p>（a）其他同伴的网络地址，<br>（b）专门用于服务特定对象的对等节点。<br>IPFS使用基于S / Kademlia和Coral的DSHT，在2.1节中具体介绍过。在对象大小和使用模式方面， IPFS 类似于Coral[5] 和Mainline[16], 因此，IPFS DHT根据其大小对存储的值进行区分。小的值（等于或小于1KB）直接存储在DHT上。对于更大的值，DHT只存储值索引，这个索引就是一个对等节点的NodeId, 该对等节点可以提供對该类型的值的具体服务。<br>DSHT的接口如下：</p><pre class="line-numbers language-none"><code class="language-none">type IPFSRouting interface {FindPeer(node NodeId) // 获取特定NodeId的网络地址。SetValue(key []bytes, value []bytes) // 往DHT存储一个小的元数据。GetValue(key []bytes) // 从DHT获取元数据。ProvideValue(key Multihash) // 声明这个节点可一个提供一个大的数据。FindValuePeers(key Multihash, min int) // 获取服务于该大数据的节点。}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：不同的用例将要求基本不同的路由系统（例如广域网中使用DHT，局域网中使用静态HT）。因此，IPFS路由系统可以根据用户的需求替换的。只要使用上面的接口就可以了，系统都能继续正常运行。</p><h4 id="3-4块交换-BitSwap协议"><a href="#3-4块交换-BitSwap协议" class="headerlink" title="3.4块交换 - BitSwap协议"></a>3.4块交换 - BitSwap协议</h4><p>IPFS 中的BitSwap协议受到BitTorrent 的启发，通过对等节点间交换数据块来分发数据的。像BT一样， 每个对等节点在下载的同时不断向其他对等节点上传已下载的数据。和BT协议不同的是， BitSwap 不局限于一个torrent文件中的数据块。BitSwap 协议中存在一个永久的市场。 这个市场包括各个节点想要获取的所有块数据。而不管这些块是哪些如.torrent文件中的一部分。这些快数据可能来自文件系统中完全不相关的文件。 这个市场是由所有的节点组成的。<br>虽然易货系统的概念意味着可以创建虚拟货币，但这将需要一个全局分类账本来跟踪货币的所有权和转移。这可以实施为BitSwap策略，并将在未来的论文中探讨。<br>在基本情况下，BitSwap节点必须以块的形式彼此提供直接的值。只有当跨节点的块的分布是互补的时候，各取所需的时候，这才会工作的很好。 通常情况并非如此，在某些情况下，节点必须为自己的块而工作。 在节点没有其对等节点所需的（或根本没有的）情况下，它会更低的优先级去寻找对等节点想要的块。这会激励节点去缓存和传播稀有片段， 即使节点对这些片段不感兴趣。</p><h5 id="3-4-1-BITSWAP-信用"><a href="#3-4-1-BITSWAP-信用" class="headerlink" title="3.4.1 - BITSWAP 信用"></a>3.4.1 - BITSWAP 信用</h5><p>这个协议必须带有激励机制， 去激励节点去seed 其他节点所需要的块，而它们本身是不需要这些块的。 因此， BitSwap的节点很积极去给对端节点发送块，期待获得报酬。但必须防止水蛭攻击（空负载节点从不共享块），一个简单的类似信用的系统解决了这些问题：</p><p>1， 对等节点间会追踪他们的平衡（通过字节认证的方式）。<br>2， 随着债务增加而概率降低，对等者概率的向债务人发送块。<br>注意的是，如果节点决定不发送到对等体，节点随后忽略对等体的ignore_cooldown超时。 这样可以防止发送者尝试多次发送（洪水攻击） （BitSwap默认是10秒）。<br>3.4.2 BITSWAP的策略<br>BitSwap 对等节点采用很多不同的策略，这些策略对整个数据块的交换执行力产生了不同的巨大影响。在BT 中， 标准策略是明确规定的（tit-for-tat），其他不同的策略也已经被实施，从BitTyrant [8]（尽可能分享）到BitThief [8]（利用一个漏洞，从不共享），到PropShare [8]（按比例分享）。BitSwap 对等体可以类似地实现一系列的策略（良好和恶意）。对于功能的选择，应该瞄准：<br>1.为整个交易和节点最大化交易能力。<br>2.为了防止空负载节点利用和损害交易。<br>3.高效抵制未知策略。<br>4.对可信任的对等节点更宽容。<br>探索这些策略的空白是未来的事情。在实践中使用的一个选择性功能是sigmoid，根据负债比例进行缩放：<br>让负债比例在一个节点和它对等节点之间：</p><pre class="line-numbers language-none"><code class="language-none">r =  bytes_sent  / bytes_recv + 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据r，发送到负债节点的概率为：</p><pre class="line-numbers language-none"><code class="language-none">P(send | r ) = 1 − ( 1/  ( 1 + exp(6 − 3r) ) )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>正如你看到的图片1，当节点负债比例超过节点已建立信贷的两倍，发送到负债节点的概率就会急速下降。</p><p>图片1  当r增加时发送的概率<br>负债比是信任的衡量标准：对于之前成功的互换过很多数据的节点会宽容债务，而对不信任不了解的节点会严格很多。这个(a)给与那些创造很多节点的攻击者（sybill 攻击）一个障碍。(b)保护了之前成功交易节点之间的关系，即使这个节点暂时无法提供数据。(c)最终阻塞那些关系已经恶化的节点之间的通信，直到他们被再次证明。</p><h5 id="3-4-3-BITSWAP-账本"><a href="#3-4-3-BITSWAP-账本" class="headerlink" title="3.4.3 BITSWAP 账本"></a>3.4.3 BITSWAP 账本</h5><p>BitSwap节点保存了一个记录与所有其他节点之间交易的账本。这个可以让节点追踪历史记录以及避免被篡改。当激活了一个链接，BitSwap节点就会互换它们账本信息。如果这些账本信息并不完全相同，分类账本将会重新初始化， 那些应计信贷和债务会丢失。 恶意节点会有意去失去“这些“账本， 从而期望清除自己的债务。节点是不太可能在失去了应计信托的情况下还能累积足够的债务去授权认证。伙伴节点可以自由的将其视为不当行为， 拒绝交易。</p><pre class="line-numbers language-none"><code class="language-none">type Ledger struct {owner NodeIdpartner NodeIdbytes_sent intbytes_recv inttimestamp Timestamp}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>节点可以自由的保留分布式账本历史，这不需要正确的操作，因为只有当前的分类账本条目是有用的。节点也可以根据需要自由收集分布式帐本，从不太有用的分布式帐开始：老（其他对等节点可能不存在）和小。</p><h5 id="3-4-4-BITSWAP-详解"><a href="#3-4-4-BITSWAP-详解" class="headerlink" title="3.4.4 BITSWAP 详解"></a>3.4.4 BITSWAP 详解</h5><p>BitSwap 节点有以下简单的协议。</p><pre class="line-numbers language-none"><code class="language-none">// Additional state kepttype BitSwap struct {ledgers map[NodeId]Ledger // Ledgers known to this node, inc inactiveactive map[NodeId]Peer // currently open connections to other nodesneed_list []Multihash // checksums of blocks this node needshave_list []Multihash // checksums of blocks this node has}type Peer struct {nodeid NodeIdledger Ledger // Ledger between the node and this peerlast_seen Timestamp // timestamp of last received messagewant_list []Multihash // checksums of all blocks wanted by peer// includes blocks wanted by peer's peers}// Protocol interface:interface Peer {open (nodeid : NodeId, ledger : Ledger);send_want_list (want_list : WantList);send_block(block: Block) -&gt; (complete:Bool);close(final: Bool);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对等连接的生命周期草图：</p><p>1.Open: 对等节点间发送ledgers 直到他们同意。<br>2.Sending: 对等节点间交换want_lists 和blocks。<br>3.Close: 对等节点断开链接。<br>4.Ignored: （特殊）对等体被忽略（等待时间的超时）如果节点采用防止发送策略。<br>Peer.open(NodeId, Ledger).<br>当发生链接的时候，节点会初始化链接的账本，要么保存一个份链接过去的账本，要么创建一个新的被清零的账本。然后，发送一个携带账本的open信息给对等节点。<br>接收到一个open信息之后，对等节点可以选择是否接受此链接。如果，根据接收者的账本，发送者是一个不可信的代理（传输低于零或者有很大的未偿还的债务），接收者可能会选择忽略这个请求。忽略请求是ignore_cooldown超时来概率性实现的，为了让错误能够有时间改正和攻击者被挫败。<br>如果链接成功，接收者用本地账本来初始化一个Peer对象以及设置last_seen时间戳。然后，它会将接受到的账本与自己的账本进行比较。如果两个账本完全一样，那么这个链接就被Open，如果账本并不完全一致，那么此节点会创建一个新的被清零的账本并且会发送此账本。<br>Peer.send_want_list(WantList)<br>当链接已经Open的时候，节点会广发它们的want_list给所有已经链接的对等节点。这个是在(a)open链接后(b)随机间歇超时后(c)want_list改变后(d)接收到一个新的块之后完成的。<br>当接收到一个want_list之后，节点会存储它。然后，会检查自己是否拥有任何它想要的块。如果有，会根据上面提到的BitSwap策略来将want_list所需要的块发送出去。<br>Peer.send_block(Block)<br>发送一个块是直接了当的。节点只是传输数据块。当接收到了所有数据的时候，接收者会计算多重hash校验和来验证它是否是自己所需数据，然后发送确认信息。<br>在完成一个正确的块传输之后，接受者会将此块从need_list一到have_list,最后接收者和发送者都会更新它们的账本来反映出传输的额外数据字节数。<br>如果一个传输验证失败了，发送者要么会出故障要么会攻击接收者，接收者可以选择拒绝后面的交易。注意，BitSwap是期望能够在一个可靠的传输通道上进行操作的，所以传输错误（可能会引起一个对诚实发送者错误的惩罚）是期望在数据发送给BitSwap之前能够被捕捉到。<br>Peer.close(Bool)<br>传给close最后的一个参数，代表close链接是否是发送者的意愿。如果参数值为false,接收者可能会立即重新open链接，这避免链过早的close链接。<br>一个对等节点close链接发生在下面两种情况下：<br>silence_wait超时已经过期，并且没有接收到来自于对等节点的任何信息（BitSwap默认使用30秒），节点会发送Peer.close(false)。<br>在节点退出和BitSwap关闭的时候，节点会发送Peer.close(true).<br>接收到close消息之后，接收者和发送者会断开链接，清除所有被存储的状态。账本可能会被保存下来为了以后的便利，当然，只有在被认为账本以后会有用时才会被保存下来。<br>注意点：<br>非open信息在一个不活跃的连接上应该是被忽略的。在发送send_block信息时，接收者应该检查这个块，看它是否是自己所需的，并且是否是正确的，如果是，就使用此块。总之，所有不规则的信息都会让接收者触发一个close(false)信息并且强制性的重初始化此链接。</p><h4 id="3-5-Merkle-DAG对象"><a href="#3-5-Merkle-DAG对象" class="headerlink" title="3.5 Merkle DAG对象"></a>3.5 Merkle DAG对象</h4><p>DHT和BitSwap允许IPFS构造一个庞大的点对点系统用来快速稳定的分发和存储。最主要的是，IPFS建造了一个Merkle DAG,一个无回路有向图，对象之间的links都是hash加密嵌入在源目标中。这是Git数据结构的一种推广。Merkle DAGS给IPFS提供了很多有用的属性，包括：<br>1.内容可寻址：所有内容都是被多重hash校验和来唯一识别的，包括links。<br>2.防止篡改：所有的内容都用它的校验和来验证。如果数据被篡改或损坏，IPFS会检测到。<br>3.重复数据删除：所有的对象都拥有相同的内容并只存储一次。这对于索引对象非常有用，比如git的tree和commits，或者数据的公共部分。<br>IPFS对象的格式是：</p><pre class="line-numbers language-none"><code class="language-none">type IPFSLink struct {Name string      // 此link的别名Hash Multihash // 目标的加密hashSize int             // 目标总大小}type IPFSObject struct {links []IPFSLink   //links数组data []byte         //不透明内容数据}IPFS Merkle DAG是存储数据非常灵活的一种方式。只要求对象引用是(a）内容可寻址的，(b)用上面的格式编码。IPFS允许应用完全的掌控数据域；应用可以使用任何自定义格式的数据，即使数据IPFS都无法理解。单独的内部对象link表允许IPFS做：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用对象的形式列出所有对象引用，例如：</p><pre class="line-numbers language-none"><code class="language-none">&gt; ipfs ls /XLZ1625Jjn7SubMDgEyeaynFuR84ginqvzbXLYkgq61DYaQ8NhkcqyU7rLcnSa7dSHQ16x 189458 lessXLHBNmRQ5sJJrdMPuu48pzeyTtRo39tNDR5 19441 scriptXLF4hwVHsVuZ78FZK6fozf8Jj9WEURMbCX4 5286 template&lt;object multihash&gt; &lt;object size&gt; &lt;link name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决字符串路经查找，例如foo/bar/baz。给出一个对象，IPFS会解析第一个路经成分进行hash放入到对象的link表中，再获取路径的第二个组成部分，一直如此重复下去。因此，任何数据格式的字符串路经都可以在Merkle DAG中使用。<br>*递归性的解决所有对象引用：</p><pre class="line-numbers language-none"><code class="language-none">&gt; ipfs refs --recursive \/XLZ1625Jjn7SubMDgEyeaynFuR84ginqvzbXLLxhdgJcXzLbtsLRL1twCHA2NrURp4H38sXLYkgq61DYaQ8NhkcqyU7rLcnSa7dSHQ16xXLHBNmRQ5sJJrdMPuu48pzeyTtRo39tNDR5XLWVQDqxo9Km9zLyquoC9gAP8CL1gWnHZ7z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原始数据结构公共link结构是IPFS构建任意数据结构的必要组成部分。可以很容易看出Git的对象模型是如何套用DAG的。一些其他潜在的数据结构：</p><p>(a)键值存储<br>(b)传统关系型数据<br>(c)数据三倍存储<br>(d) 文档发布系统<br>(e)通信平台<br>(f)加密货币区块。<br>这些系统都可以套用IPFS Merkle DAG，这使这些系统更复杂的应用可以使用IPFS作为传输协议。</p><h5 id="3-5-1-路经"><a href="#3-5-1-路经" class="headerlink" title="3.5.1 路经"></a>3.5.1 路经</h5><p>IPFS对象可以遍历一个字符串路经。路经格式与传统UNIX文件系统以及Web一致。Merkle DAG的links使遍历变得很容易。全称路经在IPFS中的格式是：</p><pre class="line-numbers language-none"><code class="language-none">*# 格式/ipfs/&lt;hash-of-object&gt;/&lt;name-path-to-object&gt;*# 例子/ipfs/XLYkgq61DYaQ8NhkcqyU7rLcnSa7dSHQ16x/foo.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>/ipfs前缀允许只要在挂载点不冲突(挂载点名称当然是可配置的)的情况下挂载到一个已存在的系统上。第二个路经组成部分(第一个是IPFS)是一个对象的hash。通常都是这种情况，因为没有全局的根。一个根对象可能会有一个不可能完成的任务，就是在分布式环境(可能还断开链接)中处理百万对象的一致性。因此，我们用地址可寻址来模拟根。通过的hash所有的对象都是可访问的。这意思是说，给一个路经对象/bar/baz，最后一个对象可以可以被所有的访问的：</p><pre class="line-numbers language-none"><code class="language-none">/ipfs/&lt;hash-of-foo&gt;/bar/baz/ipfs/&lt;hash-of-bar&gt;/baz/ipfs/&lt;hash-of-baz&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="3-5-2-本地对象"><a href="#3-5-2-本地对象" class="headerlink" title="3.5.2 本地对象"></a>3.5.2 本地对象</h5><p>IPFS客户端需要一个本地存储器，一个外部系统可以为IPFS管理的对象存储以及检索本地原始数据。存储器的类型根据节点使用案例不同而不同。在大多数情况下，这个存储器只是硬盘空间的一部分（不是被本地的文件系统使用键值存储如leveldb来管理，就是直接被IPFS客户端管理），在其他的情况下，例如非持久性缓存，存储器就是RAM的一部分。<br>最终，所有的块在IPFS中都是能够获取的到的，块都存储在了一些节点的本地存储器中。当用户请求一个对象时，这个对象会被查找到并下载下来存储到本地，至少也是暂时的存储在本地。这为一些可配置时间量提供了快速的查找。</p><h5 id="3-5-3对象锁定"><a href="#3-5-3对象锁定" class="headerlink" title="3.5.3对象锁定"></a>3.5.3对象锁定</h5><p>希望确保特定对象生存的节点可以锁定此对象。这保证此特定对象被保存在了节点的本地存储器上。也可以递归的进行锁定所有相关的派生对象。这使所有被指定的对象都保存在本地存储器上。这对长久保存文件特别有用，包括引用。这也同样让IPFS成为一个links是永久的Web，且对象可以确保其他被指定对象的生存。</p><h5 id="3-5-4-发布对象"><a href="#3-5-4-发布对象" class="headerlink" title="3.5.4 发布对象"></a>3.5.4 发布对象</h5><p>IPFS是全球分布的。它设计为允许成千上万的用户文件可以共同的存在的。DHT使用内容哈希寻址技术，使发布对象是公平的，安全的，完全分布式的。任何人都可以发布对象，只需要将对象的key加入到DHT中，并且以对象是对等节点的方式加入进去，然后把路径给其他的用户。要注意的是，对象本质上是不可改变的，就像在Git中一样。新版本的哈希值不同，因此是新对象。跟踪版本则是额外版本对象的工作。</p><h5 id="3-5-5-对象级别的加密"><a href="#3-5-5-对象级别的加密" class="headerlink" title="3.5.5 对象级别的加密"></a>3.5.5 对象级别的加密</h5><p>IPFS是具备可以处理对象级别加密操作的。一个已加密的或者已签名的对象包装在一个特殊的框架里，此框架允许加密和验证原始字节。</p><pre class="line-numbers language-none"><code class="language-none">type EncryptedObject struct {Object []bytes // 已加密的原始对象数据Tag []bytes    // 可选择的加密标识type SignedObject struct {Object []bytes  // 已签名的原始对象数据Signature []bytes // HMAC签名PublicKey []multihash // 多重哈希身份键值}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>加密操作改变了对象的哈希值，定义一个不同的新的对象。IPFS自动的验证签名以及使用用户指定的钥匙链解密数据。加密数据的links也同样的被保护着，没有解密秘钥就无法遍历对象。也存在着一种现象，可能父对象使用了一个秘钥进行了加密，而子对象使用了另一个秘钥进行加密或者根本没有加密。这可以保证links共享对象安全。</p><h4 id="3-6-文件"><a href="#3-6-文件" class="headerlink" title="3.6 文件"></a>3.6 文件</h4><p>IPFS在Merkle DAG上还为模型化版本文件系统定义了一组对象。这个对象模型与Git比较相似：<br>Block：一个可变大小的数据块<br>List：块或者其他链表的集合<br>Tree：块，链表，或者其他树的集合<br>Commit：树在版本历史记录中的一个快照<br>我原本希望使用与Git对象格式一致的模型，但那就必须要分开来引进在分布式文件系统中有用的某些特征，如</p><p>(a)快速大小查找(总字节大小已经加入到对象中)<br>(b)大文件的重复删除(添加到list对象)<br>(c)commits嵌入到trees中。不过，IPFS文件对象与Git还是非常相近的，两者之间进行交流都是有可能的。而且，Git的一个系列的对象可以被引进过来转换都不会丢失任何的信息。（UNIX文件权限等等）。<br>标记：下面的文件对象格式使用JSON。注意，虽然IPFS包含了JSON的互相转换，但是文件对象的结构体还是使用protobufs的二进制编码。</p><h5 id="3-6-1-文件对象：BLOB"><a href="#3-6-1-文件对象：BLOB" class="headerlink" title="3.6.1 文件对象：BLOB"></a>3.6.1 文件对象：BLOB</h5><p>blob对象代表一个文件且包含一个可寻址的数据单元，IPFS的blobs就像Git的blobs或者文件系统数据块。它们存储用户的数据。需要留意的是IPFS文件可以使用lists或者blobs来表示。Blobs没有links。</p><pre class="line-numbers language-none"><code class="language-none">{"data": "some data here",  // blobs无links}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="3-6-2-文件对象-LIST"><a href="#3-6-2-文件对象-LIST" class="headerlink" title="3.6.2 文件对象: LIST"></a>3.6.2 文件对象: LIST</h5><p>List对象代表着由几个IPFS的blobs连接成的大文件或者重复数据删除文件。Lists包含着有序的blob序列或list对象。从某种程度上而言，IPFS的list函数就像一个间接块的文件系统。由于lists可以包含其他的lists，那么包含linked的链表和平衡树的拓扑结构是有可能的。有向图中相同的节点出现在多个不同地方允许在文件中重复数据删除。当然，循环是不可以能的，因为是被哈希寻址强制实行的。</p><pre class="line-numbers language-none"><code class="language-none">{"data": ["blob", "list", "blob"], //lists有一个对象类型的数组作为数据"links": [{ "hash": "XLYkgq61DYaQ8NhkcqyU7rLcnSa7dSHQ16x","size": 189458 },{ "hash": "XLHBNmRQ5sJJrdMPuu48pzeyTtRo39tNDR5","size": 19441 },{ "hash": "XLWVQDqxo9Km9zLyquoC9gAP8CL1gWnHZ7z","size": 5286 } //在links中lists是没有名字的]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-6-3-文件对象：TREE"><a href="#3-6-3-文件对象：TREE" class="headerlink" title="3.6.3 文件对象：TREE"></a>3.6.3 文件对象：TREE</h5><p>IPFS中的tree对象与Git中相似，它代表着一个目录，一个名字到哈希值的映射。哈希值则表示着blobs，lists，其他的trees，或者commits。注意，传统路径的命名早已经被Merkle DAG实现了。</p><pre class="line-numbers language-none"><code class="language-none">{"data": ["blob", "list", "blob"],//trees有一个对象类型的数组作为数据"links": [{ "hash": "XLYkgq61DYaQ8NhkcqyU7rLcnSa7dSHQ16x","name": "less", "size": 189458 },{ "hash": "XLHBNmRQ5sJJrdMPuu48pzeyTtRo39tNDR5","name": "script", "size": 19441 },{ "hash": "XLWVQDqxo9Km9zLyquoC9gAP8CL1gWnHZ7z","name": "template", "size": 5286 }//trees是有名字的]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-6-4-文件对象：COMMIT"><a href="#3-6-4-文件对象：COMMIT" class="headerlink" title="3.6.4 文件对象：COMMIT"></a>3.6.4 文件对象：COMMIT</h5><p>IPFS中的commit对象代表任何对象在版本历史记录中的一个快照。与Git中类似，但是它能够表示任何类型的对象。它同样link着发起对象。</p><h5 id="3-6-5-版本控制"><a href="#3-6-5-版本控制" class="headerlink" title="3.6.5 版本控制"></a>3.6.5 版本控制</h5><p>Commit对象代表着一个对象在历史版本中的一个特定快照。在两个不同的commit中比较对象（和子对象）可以揭露出两个不同版本文件系统的区别。只要commit和它所有子对象的引用是能够被访问的，所有前版本是可获取的，所有文件系统改变的全部历史是可访问的，这就与Merkle DAG对象模型脱离开来了。</p><p>Git版本控制工具的所有功能对于IPFS的用户是可用的。对象模型不完全一致，但也是可兼容的。这可能</p><p>(a)构建一个Git工具版本改造成使用IPFS对象图，<br>(b)构建一个挂载FUSE文件系统，挂载一个IPFS的tree作为Git的仓库，把Git文件系统的读/写转换为IPFS的格式。</p><h5 id="3-6-6-文件系统路径"><a href="#3-6-6-文件系统路径" class="headerlink" title="3.6.6 文件系统路径"></a>3.6.6 文件系统路径</h5><p>如我们在Merkle DAG中看到的一样，IPFS对象可以使用字符串路径API来遍历。IPFS文件对象是特意设计的，为了让挂载IPFS到UNIX文件系统更加简单。文件对象限制trees没有数据，为了使它们可以表示目录。Commits可以以代表目录的形式出现，也可以完全的隐藏在文件系统中。</p><h5 id="3-6-7-将文件分隔成LISTS和BLOBS"><a href="#3-6-7-将文件分隔成LISTS和BLOBS" class="headerlink" title="3.6.7 将文件分隔成LISTS和BLOBS"></a>3.6.7 将文件分隔成LISTS和BLOBS</h5><p>版本控制和分发大文件其中一个最主要的挑战是：找到一个正确的方法来将它们分隔成独立的块。与其认为IPFS可以为每个不同类型的文件提供正确的分隔方法，不如说IPFS提供了以下的几个可选选择：<br>就像在LIBFS[?]中一样使用Rabin Fingerprints [?]来选择一个比较合适的块边界。<br>使用rsync[?] rolling-checksum算法，来检测块在版本之间的改变。<br>允许用户指定专为特定文件而调整的’快分隔’函数。</p><h5 id="3-6-8路径查找性能"><a href="#3-6-8路径查找性能" class="headerlink" title="3.6.8路径查找性能"></a>3.6.8路径查找性能</h5><p>基于路径的访问需要遍历对象图。获取每个对象要求在DHT中查找它们的key，连接到对等节点，然后获取它的块。这造成相当大的开销，特别是查找的路径由很多子路径组成时。下面的方法可以减缓开销：</p><p>tree缓存：由于所有的对象都是哈希寻址的，它们可以被无限的缓存。另外，trees一般比较小，所以比起blobs，IPFS会优先缓存trees。<br>flattened trees：对于任何tree，一个特殊的 flattened tree可以构建一个链表，所有对象都可以从这个tree中访问得到。在flattened tree中名字就是一个从原始tree分离的路径，用斜线分隔。<br>例如，对于上面的ttt111的flattened tree如下：</p><pre class="line-numbers language-none"><code class="language-none">{"data":["tree", "blob", "tree", "list", "blob" "blob"],"links": [{ "hash": "&lt;ttt222-hash&gt;", "size": 1234"name": "ttt222-name" },{ "hash": "&lt;bbb111-hash&gt;", "size": 123,"name": "ttt222-name/bbb111-name" },{ "hash": "&lt;ttt333-hash&gt;", "size": 3456,"name": "ttt333-name" },{ "hash": "&lt;lll111-hash&gt;", "size": 587,"name": "ttt333-name/lll111-name"},{ "hash": "&lt;bbb222-hash&gt;", "size": 22,"name": "ttt333-name/lll111-name/bbb222-name" },{ "hash": "&lt;bbb222-hash&gt;", "size": 22"name": "bbb222-name" }] }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-7-IPNS：命名以及易变状态"><a href="#3-7-IPNS：命名以及易变状态" class="headerlink" title="3.7 IPNS：命名以及易变状态"></a>3.7 IPNS：命名以及易变状态</h4><p>目前为止，IPFS桟形成了一个对等块交换组成一个内容可寻址的DAG对象。这提供了发布和获取不可改变的对象。这甚至可以跟踪这些对象的版本历史记录。但是，这里有一个关键成分遗漏了：易变的命名。没有这个，发送IPFS的links，所有新内容的通信肯定都会有所偏差。现在所需就是能有某些方法可以获取相同路径的的易变状态。<br>这值得详述原因—如果最终易变数据是必须的—我们费了很大的力气构建了一个不可改变的Merkle DAG。就当做IPFS脱离了Merkle DAG的特征：对象可以</p><p>(a)通过哈希值可以获取<br>(b)完整性的检查<br>(c)link其他的对象<br>(d)无限缓存。从某种意义上说：<br>对象就是永恒的<br>这些就是一个高性能分布式系统的关键特征，在此系统上跨网络links之间移动文件是非常昂贵的。对象内容可寻址构建了一个具有以下特点的Web，(a)优秀的宽带优化(b)不受信任的内容服务(c)永恒的links(d)能够永久备任何对象以及它的引用。<br>不可变的内容可寻址对象和命名的Merkle DAG， 可变指针指向Merkle DAG，实例化了一个出现在很多成功分布式系统中的二分法。这些系统包括Git的版本控制系统，使用不可变的对象和可变的引用；还有UNIX分布式的继承者Plan9[?]文件系统，使用可变的Fossil和不可变的Venti[?]。LBFS[?]同样使用可变的索引以及不可变的块。</p><h5 id="3-7-1-自我认证名称"><a href="#3-7-1-自我认证名称" class="headerlink" title="3.7.1 自我认证名称"></a>3.7.1 自我认证名称</h5><p>使用SFS[12,11]中的命名方案，给我们提供了一个种可以构建自我认证名称的方法，<br>在一个加密指定的全局命名空间中，这是可变的。IPFS的方案如下：</p><p>1.回想一下在IPFS中：NodeId = hash(node.PubKey)<br>2.我们给每个用户分配一个可变的命名空间，在此路径下：/ipns/<br>3.一个用户可以在此路径下发布一个用自己私钥签名的对象，比如说：/ipns/XLF2ipQ4jD3UdeX5xp1KBgeHRhemUtaA8Vm/<br>4.当其他用户获取对象时，他们可以检测签名是否与公钥和NodeId匹配。这个验证了用户发布对象的真实性，达到了可变状态的获取。<br>注意下面的细节：</p><p>IPNS(InterPlanetary的命名空间)分开前缀是在可变和不可变的路径之间建立一个很容易辨认的区别，为了程序也为了人类阅读的便利。<br>因为这不是一个内容可寻址的对象，所以发布它就要依靠IPFS中的唯一的可变状态分配制度，路由系统。过程是(a)首先把此对象做一个常规的不可变IPFS的对象来发布(b)将此对象的哈希值作为元数据的值发布到路由系统上：</p><pre class="line-numbers language-none"><code class="language-none">routing.setValue(NodeId, &lt;ns-object-hash&gt;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发布的对象中任何links在命令空间中充当子名称：</p><pre class="line-numbers language-none"><code class="language-none">/ipns/XLF2ipQ4jD3UdeX5xp1KBgeHRhemUtaA8Vm//ipns/XLF2ipQ4jD3UdeX5xp1KBgeHRhemUtaA8Vm/docs/ipns/XLF2ipQ4jD3UdeX5xp1KBgeHRhemUtaA8Vm/docs/ipfs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一般建议发布一个commit对象或者其他对象的时候，要使用历史版本记录，因为这样就用户就可以找到之前使用过的名字。不过由于这并不总是需要的，所以留个用户自己选择。<br>注意当用户发布一个对象的时候，他不能使用相同的方式来发布对象。</p><h5 id="3-7-2人类友好名称"><a href="#3-7-2人类友好名称" class="headerlink" title="3.7.2人类友好名称"></a>3.7.2人类友好名称</h5><p>IPNS的确是一个分配和在分配名称的好方法，但是对用户却不是十分友好的，因为它使用很长的哈希值作为名称，众所周知这样的名称很难被记住。IPNS足够应付URLs，但对于很多线下的传输工作就没有这么好用了。因此，IPFS使用下面的技术来增加IPNS的用户友好度。<br>对等节点Links<br>被SFS所鼓舞，用户可以直接将其他用户的对象link到自己的对象上（命令空间，家目录等等）。这有一个好处就是创建了一个可信任的Web（也支持老的真实性认证模型）：</p><pre class="line-numbers language-none"><code class="language-none"># Alice links 到Bob上ipfs link /&lt;alice-pk-hash&gt;/friends/bob /&lt;bob-pk-hash&gt;# Eve links 到Alice上ipfs link /&lt;eve-pk-hash/friends/alice /&lt;alice-pk-hash&gt;# Eve 也可以访问Bob/&lt;eve-pk-hash/friends/alice/friends/bob# 访问Verisign 认证域/&lt;verisign-pk-hash&gt;/foo.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DNS TXT IPNS 记录<br>如果/ipns/是一个有效的域名称，IPFS会在DNS TXT记录中查找关键的ipns。IPFS会将查找到的值翻译为一个对象的哈希值或者另一个ipns的路径：</p><pre class="line-numbers language-none"><code class="language-none"># DNS TXT 记录ipfs.benet.ai. TXT "ipfs=XLF2ipQ4jD3U ..."# 表现为符号链接ln -s /ipns/XLF2ipQ4jD3U /ipns/fs.benet.ai<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Proquint 可读的标识符<br>总是会有将二进制编码翻译成可读文件的方法。IPNS则支持Proquint[?].。如下：</p><pre class="line-numbers language-none"><code class="language-none"># proquint语句/ipns/dahih-dolij-sozuk-vosah-luvar-fuluh# 分解为相应的下面形式/ipns/KhAwNprxYVxKqpDZ<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>缩短名称服务<br>会涌现出很多服务器提供缩短名称的服务，向用户提供他们的命名空间。就像我们现在看到的DNS和Web的URLs：</p><pre class="line-numbers language-none"><code class="language-none"># 用户可以从下面获取一个link/ipns/shorten.er/foobar# 然后放到自己的命名空间/ipns/XLF2ipQ4jD3UdeX5xp1KBgeHRhemUtaA8Vm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-8-使用IPFS"><a href="#3-8-使用IPFS" class="headerlink" title="3.8 使用IPFS"></a>3.8 使用IPFS</h4><p>IPFS设计为可以使用多种不同的方法来使用的，下面就是一些我将会继续追求的使用方式：</p><p>1.作为一个挂载的全局文件系统，挂载在/ipfs和/ipns下<br>2.作为一个挂载的个人同步文件夹，自动的进行版本管理，发布，以及备份任何的写入<br>3.作为一个加密的文件或者数据共享系统<br>4.作为所有软件的版本包管理者<br>5.作为虚拟机器的根文件系统<br>6.作为VM的启动文件系统 (在管理程序下)<br>7.作为一个数据库：应用可以直接将数据写入Merkle DAG数据模型中，获取所有的版本，缓冲，以及IPFS提供的分配<br>8.作为一个linked（和加密的）通信平台<br>9.作为一个为大文件的完整性检查CDN（不使用SSL的情况下）<br>10.作为一个加密的CDN<br>11.在网页上，作为一个web CDN<br>12.作为一个links永远存在新的永恒的Web<br>IPFS实现的目标：<br>(a)一个IPFS库可以导出到你自己应用中使用<br>(b)命令行工具可以直接操作对象<br>(c)使用FUSE[?]或者内核的模型挂载文件系统</p><h3 id="4-未来"><a href="#4-未来" class="headerlink" title="4. 未来"></a>4. 未来</h3><p>   IPFS的思想是几十年成功的分布式系统的探索和开源的产物。IPFS综合了很多迄今为止很成功的系统中优秀的思想。除了BitSwap新协议之外，IPFS最大的特色就是系统的耦合以及设计的综合性。<br>   IPFS是去中心化网络基础设施的一个野心设想，很多不同类型的应用都可以建立在IPFS上。最低限度，它可以用来作为一个全局的，挂载性，版本控制文件系统和命名空间，或者作为下一代的文件共享系统。而最好的情况是，IPFS可以让Web升级一个层次，当发布一个有价值的信息时，任何感兴趣的人都可以进行发布而不会强迫性的必须只允许发布机构进行发布，用户可以信任信息的内容，信不信任信息的发送者都是无关紧要的，还有一个特点就是，一些重要但很老的文件也不会丢失。IPFS期待着带我们进入到一个永恒Wdb的世界。</p><h3 id="5-感谢"><a href="#5-感谢" class="headerlink" title="5. 感谢"></a>5. 感谢</h3><p>   IPFS是一个很多很棒的主意以及系统的综合体。没有站在巨人的肩膀上，IPFS也不可能敢于有一个这么有野心的目标。个人感谢参与这些主意长期讨论的人：David Dalrymple, Joe Zimmerman, and Ali Yahya，特别是：揭开Merkle DAG的总体架构(David, Joe),滚动哈希阻塞(David), s/kademlia sybill 保护(David, Ali)，特别感谢David Mazieres,为他之前非常聪明的主意。<br>   6.引用备忘录<br>   7.引用<br>   [1].I. Baumgart and S. Mies. S/kademlia:一个安全的基于秘钥路由的可行方法。2007年国际会议，第2卷，1-8页，在《并发和分布式系统》中。IEEE，2007年。<br>   [2].I. BitTorrent.Bittorrent和Attorrent软件超过1亿5000万用户里程碑，Jan。2012<br>   [3].B. Cohen.激励机制在bittorrent中建立了健壮性。在《对等系统经济研讨会》中，第6卷，68-72页，2003年。<br>   [4].J. Dean and S. Ghemawat. Leveldb - 一个快速和轻量级键值存储数据库，谷歌提供，2011年。<br>   [5].M. J. Freedman, E. Freudenthal, and D. Mazieres. Coral民主内容发布。在NSDI中，第4卷，18-18页，2004年。<br>   [6].J. H. Howard, M. L. Kazar, S. G. Menees, D. A,Nichols, M. Satyanarayanan, R. N. Sidebotham, 以及M. J. West.分布式文件系统的规模和性能。“ACM 电脑系统上的交易 （TOCS）” 6(1):51-81, 1988年</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器间通信</title>
      <link href="/zhb233go.github.io/2022/01/08/30-docker-rong-qi-jian-tong-xin/"/>
      <url>/zhb233go.github.io/2022/01/08/30-docker-rong-qi-jian-tong-xin/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker容器间通信"><a href="#Docker容器间通信" class="headerlink" title="Docker容器间通信"></a>Docker容器间通信</h1><p>Bridge网桥双向通信</p><p><strong>浏览器&lt;==&gt;物理网卡&lt;=网桥=&gt;Docker环境下的容器</strong></p><p>将指定的容器都绑定到同一个网桥上，这些容器就会天然的互联互通</p><pre class="line-numbers language-none"><code class="language-none">docker run -d --name server appdocker run -d --name database mysqldocker network create -d bridge my-bridge #创建一个新的网桥[root@VM-0-2-centos ~]# docker network ls #列出docker服务网络底层明细NETWORK ID          NAME                DRIVER              SCOPE0dfca8776e29        bridge              bridge              localdec8ce58f992        host                host                local522173622fe8        my-bridge           bridge              local36e1a4828e03        none                null                local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建新的网桥"><a href="#创建新的网桥" class="headerlink" title="创建新的网桥"></a>创建新的网桥</h2><pre class="line-numbers language-none"><code class="language-none">docker network create my-bridge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="容器和网桥绑定"><a href="#容器和网桥绑定" class="headerlink" title="容器和网桥绑定"></a>容器和网桥绑定</h2><pre class="line-numbers language-none"><code class="language-none">docker network connect my-bridge webdocker network connect my-bridge database<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="网桥实现原理"><a href="#网桥实现原理" class="headerlink" title="网桥实现原理"></a>网桥实现原理</h2><pre class="line-numbers language-none"><code class="language-none">外网----&gt;物理网卡（192.168.0.117）-----&gt;docker里的虚拟网卡（172.17.0.1）|-----&gt;redis(172.17.0.2:6375)  |----&gt;server(172.17.0.3:8080)  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://hypo-pictrue-1308430808.cos.ap-shanghai.myqcloud.com/hypo.ltd-%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8/%E7%BD%91%E6%A1%A5.png"></p><h2 id="容器和网桥解除绑定"><a href="#容器和网桥解除绑定" class="headerlink" title="容器和网桥解除绑定"></a>容器和网桥解除绑定</h2><pre class="line-numbers language-none"><code class="language-none">docker network disconnect my-bridge serverdocker network disconnect my-bridge database<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>团队协作中的Githubflow工作流程</title>
      <link href="/zhb233go.github.io/2022/01/07/29-tuan-dui-xie-zuo-zhong-de-githubflow-gong-zuo-liu-cheng/"/>
      <url>/zhb233go.github.io/2022/01/07/29-tuan-dui-xie-zuo-zhong-de-githubflow-gong-zuo-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="团队协作中的Github-flow-工作流程"><a href="#团队协作中的Github-flow-工作流程" class="headerlink" title="团队协作中的Github flow 工作流程"></a>团队协作中的Github flow 工作流程</h1><p>作者：知乎@<a href="https://www.zhihu.com/people/hui-xiao-48">回晓</a></p><p>文章引自：<a href="https://zhuanlan.zhihu.com/p/39148914">https://zhuanlan.zhihu.com/p/39148914</a></p><p>有删减</p><p>作为一名开发人员 Git 常用命令每天都在使用，大家肯定信手拈来，但是在团队协作中 Git 的使用姿势和个人开发还是有很多不一样的地方，对于技术团队，期望大家使用规范的 Git 操作流程，规范的 Commit Message，规范的代码风格。这样才能提高团队开发相率和项目的可维护性。</p><p>在本地仓库中有两个固定的分支，分别是master和develop</p><pre class="line-numbers language-none"><code class="language-none">git clone to local<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">git remote -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时可以在控制台输入 <code>git remote -v</code> 命令查看当前远端仓库的地址：</p><pre class="line-numbers language-none"><code class="language-none">origin git@local.git(fetch)origin  git@local.git(push)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接下来我们可以设置一个名字为 upstream 的上游地址，也就是我们项目主仓库的地址<br>在命令行执行：</p><pre class="line-numbers language-none"><code class="language-none">git remote add upstream upstream git@upstream.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加一个别名为upstream(上游)的地址，指向之前 fork 的原项目仓库地址。<br>再次执行 <code>git remote -v</code> 控制台输出如下：</p><pre class="line-numbers language-none"><code class="language-none">origin git@local.git(fetch)origin  git@local.git(push)upstream upstream git@upstream.git(fetch)upstream upstream git@upstream.git(push)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>设置上游地址的目的是当我们通过 pull request 的形式提到主仓库之后，本地仓库需要同步主仓库的代码，并及时更新到 origin（远端）仓库，保证自己托管空间下本地和远端仓库的代码都是最新的。</p><p>之后运行下面几条命令，就可以保持本地仓库与上游（upstream）仓库同步了</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git fetch upstreamgit checkout mastergit merge upstream/master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来就是本地仓库推送到远端（origin）仓库：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个时候我们可以在本地进行开发了，通常我们规定：</p><ul><li>开发新功能要从 develop 分支上新建一个 feat/[name-desc] 临时分支</li><li>bug 修复 从 master 分支新建一个 hotfix/[name-desc] 临时分支</li></ul><p>如果没有输出任何提交信息的话，即表示 feat/feedback 分支 相对于 develop 分支 是 最新（up-to-date）的。如果有输出的话去执行 <code>git merge --ff-only</code> ，提交路线图就会分叉，为了得到一个干净清爽的提交路线图，合并前最好先执行：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git checkout feat/feedbackgit rebase develop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这会将整个工作分支移到 develop 分支的前面（HEAD），可以使 feat/feedback 分支与上游（upstream） develop 分支同步，最后我们将代码推送到远端（origin）分支。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git push origin feat/feedback<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样 pull request 通过之后，feat/feedback 分支的代码执行合并操作之后，commit 历史拼接到更新到最新的develop 分支之后，最终得到一个干净舒服的提交线图。</p><h2 id="提交-pull-request"><a href="#提交-pull-request" class="headerlink" title="提交 pull request"></a><strong>提交 pull request</strong></h2><p>从自己远端（origin）仓库的 feat/feedback 分支想要提交到上游（upstream）主仓库的 develop 分支，需要去在主仓库上Open a pull request ：</p><p>在点击Merge pull request 的时候，我们看到有三个选项，简单介绍一下使用场景：</p><h2 id="Create-a-merge-commit"><a href="#Create-a-merge-commit" class="headerlink" title="Create a merge commit"></a><strong>Create a merge commit</strong></h2><p>当点击的是 Create a merge commit 时，feature 分支上所有的 commit 都会被加到develop 分支后面，并且会生成一个 merge commit 新节点。这个 pull request 的合并使用的就是 <code>git merge --ff-only</code>操作，<code>--ff-only</code>解释为仅使用–fast forward(快进)，尽可能将合并解析为快进；不可能时，拒绝合并并以非零状态退出。使用该操作合并之后的commit 路线图看到，使用 <code>git merge --ff-only</code> 没有提交线路分叉的效果。</p><h2 id="Squash-and-merge"><a href="#Squash-and-merge" class="headerlink" title="Squash and merge"></a><strong>Squash and merge</strong></h2><p>当选择 Squash and merge 选项时，实际的git 操作为 <code>git merge --squash</code> 。这个命令会使 该pull request 上的所有 commit 都会合并成一个 commit 放在 develop 分支上，原来的 commit 历史并不会带过来。</p><p>判断是否要用 squash and merge 的标准是待合并的分支的历史是否有意义，如果在开发分支上提交的非常随意，并没有做一个很好的规范性提交，那么可以使用 squash and merge 选项。但是对于大型项目的多人开发过程中，保证每个 commit 必须有意义是开发人员的基本素养及要求，因此不建议在团队开发中使用 squash and merge 选项。</p><h2 id="Rebase-and-merge"><a href="#Rebase-and-merge" class="headerlink" title="Rebase and merge"></a><strong>Rebase and merge</strong></h2><p>当选择 rebase and merge 时，实际上做的操作是<code>git rebase</code>。使用 git rebase 会将 pull request 上的所有提交历史按照原有顺序依次拼接到 develop 分支的头部（HEAD），看起来像是在 develop 分支做了这些提交，但是每个 commit 的SHA1值会发生改变，因此合并到develop 分支的提交的SHA1 值会更新。</p><p>使用 rebase and merge 之后，develop 分支的 commit 路线图如下：</p><p><img src="https://pic2.zhimg.com/80/v2-d27e4e2e19930721d0178255ddf1257d_720w.jpg" alt="img"></p><p>上面两图可以明显看出 commit 的SHA1 发生了变化，因此在使用 git rebase 的时候千万要注意：不要对除了你以外的公共仓库分支执行git rebase，git rebase 的实质放弃现有的提交而去新建内容一样的提交，实际上是不同的提交。</p><p>当然使用 git rebase 会有一定风险，在不完全熟悉 Git 工作流时，不建议去做该操作。比如在结对编程的过程中你将你的提交推送到了你远端仓库的 feature 分支，并且你的伙伴从该分支拉去代码进行后续开发，如果此时你用 git rebase 命令重新提交并再次 pull，那么你的小伙伴要在他提交代码之前将你的提交进行整合，并且你还要拉取他提交的整合过的代码，整个过程就很混乱。</p><p>git rebase 都说是危险的，但是只在从未推送至共用仓库的提交上执行变基命令，就不会有事。因此我们采用 fork 到自己仓库的方式去做 pull request 操作，并没有在主仓库进行操作，在这里，git rebase 是安全的。</p><p>最后总结一下 git rebase 要遵守的法则是：只对尚未推送或分享给别人的本地修改执行 git rebase 操作清理历史，而不对已推送至别处的提交执行 git rebase 操作。比如在 push 所有代码并发起合并请求之前去使用，保证本地进行的提交引用于所有历史提交的最顶端，这种需求非常适合用 git rebase。但是不要对自己仓库以外的副本分支执行 git rebase。</p><p>上面介绍了 pull request merge 的三种方式。对于团队合作的项目中，个人比较推荐使用Create a merge commit 方式，能够清楚的保留每个人提交的上下文，能够记录实际发生过什么，并保留下来，供以后有需求的查阅。</p><h2 id="删除-feature-分支"><a href="#删除-feature-分支" class="headerlink" title="删除 feature 分支"></a><strong>删除 feature 分支</strong></h2><p>使用 pull request merge 之后，对于已经合到 upstream/develop 的远端 feature 分支，可以将其进行删除了：</p><p>本地分支删除：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git branch -D feat/feedback<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>远端分支删除：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git push origin :feat/feedback<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里使用 <code>git push [远程名] :[分支名]</code> 的语法去做删除，这是从 <code>git push [远程名] [本地分支]:[远程分支]</code> 而来的，这里省略掉本地分支，相当于将空白推送到要 feature 分支，从而实现删除该分支。</p><h2 id="分支同步"><a href="#分支同步" class="headerlink" title="分支同步"></a><strong>分支同步</strong></h2><p>一段时间内，有多个小伙伴通过 pull request merge 的方式将代码合并到 upstream 上游 develop 分支了，此时我们要将 upstream 上游 develop 分支的代码同步到本地和远端，以保证自己仓库下的代码是最新的。</p><p>此时先要将 upstream 上游的改动同步到本地，再 push 到远端 origin 分支：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git checkout developgit pull upstream developgit push origin develop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="新建bugfix-分支"><a href="#新建bugfix-分支" class="headerlink" title="新建bugfix 分支"></a><strong>新建bugfix 分支</strong></h2><p>对于修复紧急 bug 的时候，此时要基于 master 分支新建 bugfix 分支，来实现快速修复：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git checkout mastergit pull upstream mastergit checkout -b hotfix/fixbug master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>修改完 bug， push之后，先提交 pull request 至 upstream/master， 自动化测试和 code review 通过后合并到 upstream/master 分支，将代码部署到生产修复该 bug。此时再从 hotfix/fixbug 分支向 upstream/develop 分支发送 pull request 再合到 develop 分支，最后删除本地和远程的 hotfix/fixbug 分支。下次进行开发功能时再次将上游代码同步到本地和 origin 远程。</p><h2 id="出现冲突的情况"><a href="#出现冲突的情况" class="headerlink" title="出现冲突的情况"></a><strong>出现冲突的情况</strong></h2><p>如果两个 pull request 的操作修改同一个文件，并且都是从同一个分支拉出的新的 feature 分支。其中一个pull request先被合到了develop 分支，另一个 pull request 合并的时候会出现冲突。</p><p><img src="https://pic3.zhimg.com/80/v2-8602d2b3e98efa175de164a0f63addb2_720w.jpg" alt="img"></p><p>假设本地有冲突的分支为 feat/delete，已经合到 upstream/develop 分支为 feat/update，<br>在 feat/delete 分支上进行解决冲突操作：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git pull upstream develop --rebase<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://pic3.zhimg.com/80/v2-16f5d0a604f5d6a925e426265ce1e2e2_720w.jpg" alt="img"></p><p>可以根据控制台输出的提示继续操作</p><p>先手动修改完代码，解决冲突保存之后执行：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git add .git rebase --continuegit push origin feat/delete -f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最后 feat/delete 的改动出现在了 feat/update 的时间线后面，可以正常 pull request merge 了，下图是 merge 之后的 commit 路线图：</p><p><img src="https://pic3.zhimg.com/80/v2-30f4aed547b61418d4c80a752c9a089a_720w.jpg" alt="img"></p><h2 id="针对编程的情况"><a href="#针对编程的情况" class="headerlink" title="针对编程的情况"></a><strong>针对编程的情况</strong></h2><p><strong>主动情况</strong></p><p>甲从 develop 新起一个分支为 feat/jia， 甲、乙做的功能有通用的地方，此时甲、乙的代码都不能同时提交 pull request，因为功能缺乏，发到线上可能会挂掉。因此此时需要结对编程，甲开发完公共的部分，推到他的远端仓库，此时先不要提交 pull request。乙来拉取甲的代码继续进行开发，待乙开发完，提交 pull request 到 upstream 上游仓库，举例如下：</p><p>例如甲fork 到自己托管空间的远端仓库为：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git@github.com:jia/github-flow.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时甲将他的代码推送到 他的origin 远端 feat/jia 分支，然后甲告诉乙，你可以继续进行开发了，</p><p>此时乙本地准备开发的分支为 feat/yi，在该分支上进行如下操作：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git remote add pair git@github.com:jia/github-flow.gitgit pull pair feat/jia --rebase<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面命令的意思是新建一个名字叫 pair 的远程仓库，地址为甲的仓库地址。 然后拉去该仓库下的 feat/jia 分支同步到当前分支。</p><p>乙在该分支上修改完代码提交后，提 pull request 到甲仓库的 feat/jia 分支，若没有问题，使用 rebase and merge 合进去。code review 通过后，由甲再次提交 pull request 到上游仓库 develop 分支，合并到上游 develop 分支。此时甲乙的 feat/jia、feat/yi 功能分支都可以删掉了。</p><p><strong>被动情况</strong></p><p>如果甲提交 pull request 之后，在 code review 时发现问题，但是自己又不能马上修掉，可能需要他人帮忙，那么这个时候，乙出现来救火，首先乙先从 develop 拉出个 feature 分支，pull 甲的 feature 分支，例如：</p><pre class="line-numbers language-abap" data-language="abap"><code class="language-abap">git <span class="token keyword">remote</span> <span class="token keyword">add</span> pair  git@github<span class="token punctuation">.</span>com<span class="token punctuation">:</span>jia/github<span class="token token-operator punctuation">-</span>flow<span class="token punctuation">.</span>gitgit pull pair feat/jia --rebase<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>乙修改完代码后，将改动的之后的内容提 pull request 到甲有问题的当前 feature 分支。甲需要 rebase and merge 合掉乙向甲分支提交的 pull request。再按照标准流程将最后的没有问题的 pull request 合到develop。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h2><p>开发中需要的注意事项以及建议：</p><ol><li>规范化Commit Message：</li></ol><p>为了保证每个commit 是必须有意义的的同时，开发人员的commit 格式要统一，便于阅读。<br>对于commit 的规范推荐使用 <a href="https://link.zhihu.com/?target=https://github.com/commitizen/cz-cli">cz-cli</a>， 其安装步骤如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">npm install commitizen <span class="token operator">-</span>g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在项目中 命令行运行：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">commitizen init cz-conventional-changelog --save-dev --save-exact<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>每次 commit 执行 命令 <code>git cz</code></p><p><img src="https://pic1.zhimg.com/80/v2-c5c85c1727f8e0696eace2374f1808d4_720w.jpg" alt="img"></p><p>\2. 对于上游仓库，要保护develop 和 master 分支，不允许团队成员随意（直接）推送代码到 develop 或 master 分支。<br>\3. 设置 develop 分支为 default 分支，便于提交 pull request 时 base 分支自动默认为 develop分支。<br>\4. Github flow 开发流程中，可以配置 webhook 去自动触发测试环境的发布和自动化测试，只有自动化测试和code review 都通过，才可以被允许合并到 develop 分支。<br>\5. 将某些关键字加入到 pull request 的描述文本中，例如输入close issue #4 ，当 pull request merge 通过并合并到 develop 后，该 issue 会被自动关闭。</p><p>\6. <a href="https://link.zhihu.com/?target=https://help.github.com/articles/creating-a-pull-request-template-for-your-repository/">设置 pull_request 模板</a> 能规范化团队 pull request 的内容，示例模板如下：</p><p><img src="https://pic3.zhimg.com/80/v2-805268f989b03d7e3a831e6f3eef131a_720w.jpg" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>上面简单介绍了在工作中使用的 github flow 工作流。但是最早由于不熟悉整个 Git 流程，一度非常依赖 sourcetree，只敢在 sourcetree 上进行可视化操作，导致对于 git 的工作流程一直不是很理解。因此对于初学者如果一开始就使用Sourcetree 的各种操作但是不知道是什么原理，会很麻烦。因此建议脱离 sourcetree 自己动手命令行多去练习 Git 的一整套工作流程。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Githubflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我作为软件工程师的财务独立之路</title>
      <link href="/zhb233go.github.io/2022/01/07/28-wo-zuo-wei-ruan-jian-gong-cheng-shi-de-cai-wu-du-li-zhi-lu/"/>
      <url>/zhb233go.github.io/2022/01/07/28-wo-zuo-wei-ruan-jian-gong-cheng-shi-de-cai-wu-du-li-zhi-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="我作为软件工程师的财务独立之路"><a href="#我作为软件工程师的财务独立之路" class="headerlink" title="我作为软件工程师的财务独立之路"></a>我作为软件工程师的财务独立之路</h1><p>文章来源：<a href="https://software.rajivprab.com/2021/12/26/my-path-to-financial-independence-as-a-software-engineer/">https://software.rajivprab.com/2021/12/26/my-path-to-financial-independence-as-a-software-engineer/</a></p><p><a href="https://www.forbes.com/sites/financialfinesse/2019/08/06/3-ways-to-invest-for-financial-independence"><img src="https://softwarerajivprab.files.wordpress.com/2021/11/finances.png" alt="img"></a></p><p>我生命中的一个分水岭时刻是作为一名 20 岁的实习生参加关于个人理财的工作场所演示。在一小时内，我了解了买入并持有投资和复合增长的力量。我了解到，通过财务纪律和投资规划，即使是年薪五位数的普通工程师也可以在 30 多岁时成为百万富翁。这既鼓舞人心又充满活力。我一直认为我需要工作到 60 岁，才能支付账单和维持生计。成为“千万富翁”是梦想，而不是计划。这次演讲改变了我对财务命运的看法。</p><p>从那时起，财务独立是我优先考虑和追求的事情。今年，在企业界工作了 12 年后，我欣喜若狂，我终于实现了自己的目标。这篇文章是关于我旅程的具体细节，以防其他人发现它有助于制定自己的路线。</p><p><em>免责声明：我承认我很荣幸，尤其是在我所拥有的教育机会方面。在我的旅程中，有许多其他人难以或不可能复制的步骤。但也许还有其他一些你会发现在你自己的生活中更有用和适用的方法。</em></p><p><em>第二个免责声明。不幸的是，谈论金钱在社会上有很多污名。那些赚得不多的人会感到尴尬。而那些赚得更多的人往往被告知要隐瞒这一事实，以免被视为傲慢和自负。我认为这是一种耻辱。金钱应该像对待健康一样对待。这是生活的必需品，也是我们应该优先考虑的事情。但不是定义你或你作为一个人的价值的东西。我们越公开谈论金钱，我们就越能互相学习，我们也能更好地管理自己的财务。</em></p><hr><p>不用多说，这里总结了我在职业生涯中每年赚了多少钱，我存了多少，以及我的储蓄如何随着时间的推移而增长。</p><table><thead><tr><th><strong>年</strong></th><th><strong>雇主</strong></th><th><strong>年收入</strong></th><th><strong>花费金额（不含税）</strong></th><th><strong>净值</strong></th><th><strong>笔记</strong></th></tr></thead><tbody><tr><td>2009年</td><td>英特尔</td><td>100,000</td><td>38,000</td><td>35,000</td><td>获得工程硕士学位的新大学毕业生</td></tr><tr><td>2010年</td><td>英特尔</td><td>100,000</td><td>38,000</td><td>75,000</td><td></td></tr><tr><td>2011年</td><td>英特尔</td><td>105,000</td><td>38,000</td><td>122,000</td><td></td></tr><tr><td>2012年</td><td>英特尔/太阳</td><td>115,000</td><td>38,000</td><td>175,000</td><td></td></tr><tr><td>2013年</td><td>太阳</td><td>125,000</td><td>39,000</td><td>236,000</td><td></td></tr><tr><td>2014年</td><td>太阳</td><td>125,000</td><td>39,000</td><td>320,000</td><td></td></tr><tr><td>2015年</td><td>对冲基金</td><td>230,000</td><td>56,000</td><td>450,000</td><td>从硬件 -&gt; 软件的职业转向</td></tr><tr><td>2016年</td><td>对冲基金/谷歌</td><td>230,000</td><td>56,000</td><td>505,000</td><td></td></tr><tr><td>2017年</td><td>谷歌</td><td>300,000</td><td>64,000</td><td>850,000</td><td></td></tr><tr><td>2018年</td><td>谷歌</td><td>330,000</td><td>68,000</td><td>990,000</td><td>谷歌股价上涨导致收入增加</td></tr><tr><td>2019年</td><td>亚马逊</td><td>475,000</td><td>94,000</td><td>1,130,000</td><td></td></tr><tr><td>2020年</td><td>亚马逊</td><td>475,000</td><td>78,000</td><td>1,470,000</td><td></td></tr><tr><td>2021年</td><td>亚马逊</td><td>625,000</td><td>78,000</td><td>2,400,000</td><td>亚马逊股价上涨导致收入增加</td></tr></tbody></table><p>我在此过程中学到的一些教训：</p><ul><li><p>当你得到大幅加薪时，很容易把钱花在奢侈品上，比如更漂亮的公寓或豪华的汽车。在某种程度上，这当然也是我所做的。但尽可能避免加速你的享乐跑步机，而是省下这笔钱</p><p>在可能的情况下，把钱花在体验上，而不是事情上——我已经进行了无数次洲际旅行，每周出去吃很多次，同时仍然节俭租金和汽车付款。和我花钱买的所有东西相比，经济独立是最大的奢侈</p></li><li><p>我看到一个常见的模因，旧金山和纽约等城市的房价贵得离谱。在上述几乎整个时间段内，我都住在旧金山、纽约或距离很短的通勤地点。我无法谈论抚养孩子所涉及的费用，但作为一个没有孩子的人，我能够找到与我的收入相关的价格合理的选择（这在大多数地方是不可能的）。和室友住在一起时，我支付了约 1000 美元的租金，独居时支付了约 2000 美元的租金</p><p>人们喜欢讨厌与室友住在一起的想法（我听说它被讽刺地描述为贫困）。但它造就了极其有趣的社交生活，以及有趣的生活体验的源泉。更不用说显着的租金节省</p></li><li><p>投资你的钱。不要让它在银行闲置。作为一个职业生涯很长的年轻人，你有能力承担风险。大部分投资于<a href="https://investor.vanguard.com/etf/profile/VT">全球股市</a>。您将定期遭受损失，尤其是在经济衰退期间。但平均而言，你会领先。复合增长非常强大，让我的净资产增加了近 100 万美元。</p><p>我自己的投资组合完全由美国股票 ( <a href="https://investor.vanguard.com/etf/profile/VTI">VTI</a> )、发达国家 ( <a href="https://investor.vanguard.com/etf/profile/VEA">VEA</a> ) 和新兴市场 ( <a href="https://investor.vanguard.com/etf/profile/VWO">VWO</a> ) 组成。近年来，我还加入了房地产（<a href="https://money.usnews.com/funds/etfs/real-estate/ishares-global-reit-etf/reet">REET</a>）。我的确切分配有所不同，但我通常在上述每一项中投入了相同的金额。如果您更厌恶风险，请添加债券基金（<a href="https://investor.vanguard.com/etf/profile/BND">BND</a> ) 到您的投资组合</p><p>不要试图为市场计时或挑选赢家和输家。平均而言，这些都是失败的策略。如果您确信自己拥有非凡的才能并想把握市场时机或投资特定股票，请每周至少花 20 小时进行投资研究</p></li><li><p>拥有房屋是您将要做出的最大的财务决定 - 清楚地了解利弊。使用<a href="https://www.nytimes.com/interactive/2014/upshot/buy-rent-calculator.html">专家计算器</a>来评估购买特定房屋后您能赚或亏的金额。在很多情况下，租房在经济上比买房更好。</p><p>毫无疑问 - 住房是基本需求，而拥有房屋则是可有可无的。说你<em>“需要”</em>买房，就像说你<em>“需要”</em>拥有价值一百万美元的谷歌股票</p></li><li><p>如果您仍然是学生或准备进入研究生院，请尽一切努力获得进入前 5 名的硕士课程。毕业只需一年左右，为你的职业生涯打开大门</p><p>如果你的学生时代结束了，你没有引人注目的简历，你可以在FANG工作得到同样的结果（或类似）公司几年。好消息是，与律师事务所或投资银行不同，FANG 公司会为大多数本地软件开发人员提供面试机会（虽然招聘门槛确实很高）</p></li><li><p>当我从计算机硬件工程师转变为软件工程师时，我职业收入的最大提升是。领先公司的软件工程师可以赚到与医生和投资银行家不相上下的巨额收入。还有许多其他职业，即使是工程师，尽管我同样才华横溢，但我的收入会少得多。您选择的职业道路将对您的薪酬产生巨大影响</p><p>转换职业是我必须做的最困难的事情，需要大量投入我几个月的空闲时间，而且我不得不将多年来的自我融入我的新职业。但它得到了很好的回报。当谈到利润丰厚的职业机会时，始终保持开放的心态，不要害怕改变你的职业生涯。如果我今天 20 岁，我会认真考虑专攻机器学习</p></li><li><p>与上述类似，我听说有才华的软件开发人员几乎不可能在美国以外的任何国家获得类似的收入。如果您优先考虑早期财务独立，请强烈考虑搬到这里。要做到这一点，最简单的方法可能是暂停工作 1 年，然后在美国攻读硕士学位。虽然我也遇到了其他持工作签证搬到这里的人</p></li><li><p>不要让短期的恐惧妨碍您的长期成功。我在硬件行业的前 5 年阻碍了我的职业发展，从那时起，我一直在追赶直接进入软件行业的同学。讽刺的是，当我在大学一年级时，有人问我为什么不想主修计算机科学，我回答说：<em>“从高中开始编程的人很多，相比之下，我会处于劣势。他们。”</em> 有趣的是，我最终还是转行了……7 年后……处于更大的劣势</p></li><li><p>如果您擅长面试，那么您需要做出的最大决定是初创公司与 FANG。在任何时候，你都会在 FANG 公司赚更多的钱，同时工作的时间更少。刚毕业时差异较小，但作为高级开发人员时差异尤其明显，当你可以在 FANGs 赚 250-500k 时，同时每周工作 40 小时。</p><p>另一方面，你可以在初创公司更快地发展你的职业生涯，并更快地获得领导经验。您还将获得更多机会从事绿地项目，在短时间内建造更多东西，并减少官僚主义的阻碍。</p><p>如果你的目标是在朝九晚五的时候赚 30 万/年，你应该坚持 FANG 公司。<br>如果你的目标是创造很多很酷的东西或者有一天成为一名 VP/SVP/C 级执行官，你应该做早期创业公司。<br>如果可以重来一次，我会用我职业生涯的前 6 年做初创公司。如果我的创业公司都没有成功，后来加入 FANG 公司担任高级工程师</p></li><li><p>你应该强烈考虑每 3 年到别处面试。这需要在面试准备和处理拒绝方面付出努力，但您可以获得显着的加薪和晋升。练习你的面试技巧是你能做出的最好的财务投资。</p></li><li><p>这并不是说你目前的工作不重要——它确实重要。始终追求卓越，并将自己置于可以学习和成长的环境中。在我接受谷歌面试之前的一年里，我利用晚上和周末的时间来引导一家初创公司。又是在我加入亚马逊的前一年。我这样做并不是为了给任何人留下深刻印象，但我怀疑它帮助我获得了异常丰厚的工作机会。无论您走到哪里，您的声誉、人脉、您掌握的技能以及您学到的课程都会与您同在。</p></li><li><p>我听说很多人说你应该忽略公平，只看工作机会中的基本工资。这是一个糟糕的建议——总是看总薪酬，而不是其中的任何一部分。如果有的话，股权给了你选择权。如果股价大幅下跌，可以通过换公司来重置。如果它显着上升，您将获得显着的补偿增加。这对我在谷歌和亚马逊都有很大帮助。</p><p>许多州规定，准雇主询问您目前的工资是非法的。即使你不是生活在这样的状态，这也是一个很好的指导方针。告诉招聘人员你期望的薪酬，而不是你目前的薪酬。根据经验，每当我换工作时，我预计薪酬会增加 30%。任何低于 20% 的情况，我建议您等待更好的结果出现。</p><p>你的薪酬期望越高，你就越需要在面试和工作中给他们留下深刻印象。所以这是一把双刃剑。准备好实现您的要求</p></li></ul><hr><p>您可能想知道这一切的意义何在。金钱买不到幸福。此外，如果你只是打算在 30 多岁时退休，那么优化你的职业生涯有什么意义呢？</p><p>确实，金钱或事业上的成功并不能买到幸福。但真正能买到幸福的是独立和自主。因此，我的目标是优化我的职业和财务状况，以便我能够在 30 多岁时“退休”。</p><p>现在我已经“退休”了，理论上我可以在海滩上度过余生。但这不是我想要的，也不是我追求经济独立的原因。我的真正目标一直是按照我自己的方式追求我的人生目标，而不必担心金钱。</p><p>作为在我工作过的每家公司中都发现令人沮丧的问题的人，我目前的目标是从头开始建立一家初创公司。我可以独立工作并快速做出决定，而无需参加无休止的会议或等待数天/数周的批准。一个我可以尝试解决我在其他公司中反复出现的问题的地方。一个我可以尝试领导力的地方，而不仅仅是中层管理人员。</p><p>除了我的创业目标之外，我还有其他目标，我很高兴在未来几年追求这些目标。您可能已经从这篇博客中猜到了，写作是我的爱好之一，我希望有朝一日成为一名出版作家。辅导和指导他人也是我过去喜欢的事情——我正在考虑担任兼职导师/导师的想法。最后，我打算将我的大部分积蓄用于慈善事业。如果我的任何一家初创公司取得成功，我还计划成立一个慈善基金会并积极参与慈善事业。</p><hr><p>这些都是我过去在某种程度上做过的事情，但我从来没有能够在兼顾全职工作的同时给他们应得的时间和精力。此外，我知道一个事实，如果我在 20 多岁的时候尝试成为一名全职作家，我一生中的大部分时间都会为财务稳定性而感到压力。赚钱的诱惑会威胁到我创造性努力的完整性。但现在我在经济上独立了，我有能力全心全意地追求我的人生目标。没有任何货币预期，或担心支付账单。</p><p>最终对我来说，这就是财务独立的全部意义所在，以及为什么这一切都是值得的。这不是关于坐在海滩上喝掉你的生命。这是关于拥有追求人生目标的自由，无论它是什么，无论它可能多么不切实际。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在新年伊始写给自己的一封信</title>
      <link href="/zhb233go.github.io/2022/01/01/27-zai-xin-nian-yi-shi-xie-gei-zi-ji-de-yi-feng-xin/"/>
      <url>/zhb233go.github.io/2022/01/01/27-zai-xin-nian-yi-shi-xie-gei-zi-ji-de-yi-feng-xin/</url>
      
        <content type="html"><![CDATA[<h1 id="致2022年的新我"><a href="#致2022年的新我" class="headerlink" title="致2022年的新我"></a>致2022年的新我</h1><p>2021年刚刚过去，我想写下这篇文章作为我在2022年迷茫的时候能看到，给我一些<br>力量；<br>在年初时，我就给我自己许下了两个愿望，1.换一个工作，并且工资期望不错；2.减肥<br>到60公斤。<br>这两个愿望在2021年快结束时，我都实现了，我深深的知道我在这其中付出了多少<br>努力，也是因为这两个愿望使得我的2021变得充实且没有遗憾，在这一年，我为了换<br>工作自学了go语言，并且靠着我的努力寻找到了一份超出我自己期望的工作，我很满意<br>我的薪资，但是我知道不能因满意而使自己堕怠的原因，我还需要在这条路上不停的<br>前进。二是减肥，我第一次是靠着我的努力真实的感受到付出汗水的快乐，因为变瘦<br>能使我变得自信，使我能认识到自己的潜力，并不是我做不到，而是我愿不愿意去做<br>，并且坚持下去。对于我的2021我很满意，一、我认识到做自己认为正确的事情并且<br>坚持下去。二、学会和自己独处，第一次在一个异地一个人生活，难免会不习惯，虽然<br>都来了四个月了，我还是不是很释然，一个人的独处能力还需加强。三、认识的身体是<br>奋斗的本钱，假如我不爱惜自己的身体，那么身体的病痛和难受就会接踵而至，健身<br>很重要。四、读书和学习不能停下，你不进步，时代就会抛弃你；<br>2022的新目标：1、最重要的是健身，能在21年的基础上锻炼出6块腹肌；2、找到一个<br>伴侣，在这一方面我不强求，这是希望能遇上一段缘分；3、在工作基础上不断加强<br>，做到自如应对项目的相关事宜，并不断学习；4、再学习一下一个游戏引擎编程，不<br>要求达到工作需求，只是当作自己的一项投资，一个自己探索的方向，也是自己的下一个<br>新目标。<br>新的一年已经开始了，我希望在自己迷茫时能想起自己写的这边文章，想想自己的目标，<br>和自己想走的自己的路。</p><p>加油！hypo！加油！2022！</p><p><img src="https://hypo-pictrue-1308430808.cos.ap-shanghai.myqcloud.com/hypo.ltd-%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8/IMG_2827.jpg" alt="2021"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
            <tag> 2022目标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你的B计划是什么？</title>
      <link href="/zhb233go.github.io/2021/12/23/26-ni-de-b-ji-hua-shi-shi-me/"/>
      <url>/zhb233go.github.io/2021/12/23/26-ni-de-b-ji-hua-shi-shi-me/</url>
      
        <content type="html"><![CDATA[<h1 id="你的B计划是什么？"><a href="#你的B计划是什么？" class="headerlink" title="你的B计划是什么？"></a>你的B计划是什么？</h1><p>最近看新闻总是看到各大互联网公司裁员的消息，自己作为刚入互联网的新人，不禁就感叹到IT行业的残酷，意识到自己正处在一个正在风云变化的时代。<br>一是国家倡导共同富裕，希望能减小国家间的贫富差距，打击互联网巨头的无序扩张；<br>二是互联网巨头们也感受到了压力，需要减轻财务负担，大量裁掉底层技术人员，导致许多技术人员失去工作岗位。<br>三是大量的高龄技术人员越来越受到企业的弃用，从而希望招入年轻并薪资待遇较低的大学生入行；</p><p>这样就导致技术人员的焦虑感越来越强，毕竟互联网就是吃年轻饭的，淘汰年纪大的给年轻人让位，也可以使年轻人得到更多的机会，之前看到一遍新闻：说是互联网HR有一个潜规则就是28岁以后的简历一律不看，经人验证，情况属实！我看到这就很惊讶！28岁正是一个青壮年的时候，人的黄金年纪，之后互联网都看不上了，就说明整个行业的平均年纪就在28岁左右，很年轻。我计算了一下给我在互联网的红利时期也就6年左右，时间很短！</p><p>恐惧的感觉油然而生，又刚阅读的阮一峰的著作《未来的幸存者》一书，就感觉对远期互联网的未来感到悲观，虽然远不及他书中对人类的未来着想，我只能顾及我自己。就像他书中所说：<br>对于人生来说，你现在的职业就是A计划，应该努力追求职业成功。但是，也要做好两手准备，万一A计划失败，还需要一个B计划，对自己的退路有所安排。一旦有了B计划，我建议，最好立刻动手做一些准备。不一定为了真的实施，但至少让它从一个很模糊的设想，变得稍微具体一点。千万不要只是想想而已，人生缺少的就是行动，只有迈出第一步，才有后面的旅程。</p><p>我是应该想想我的B计划是什么了，虽然不是立即就要做出改变，但是是应该做一些准备了，并在这几年的时间里面做到能够在生活发生重大变化的时候能够从容一些，其实想想普通人并没有什么能够做终身的职业，那些能做终身的职业的人都是伟人，我不是，所以需要为自己找到一条后路，以备不时之需。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一个Dockerfile书写笔记</title>
      <link href="/zhb233go.github.io/2021/12/23/25-ji-lu-yi-ge-dockerfile-shu-xie-bi-ji/"/>
      <url>/zhb233go.github.io/2021/12/23/25-ji-lu-yi-ge-dockerfile-shu-xie-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="docker-制作镜像"><a href="#docker-制作镜像" class="headerlink" title="docker 制作镜像"></a>docker 制作镜像</h2><p>在<code>Dockerfile</code>所在的目录下执行<code>docker build</code>构建镜像</p><pre class="line-numbers language-none"><code class="language-none">➜  docker build -t 镜像名 .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>docker</code>会依据<code>Dockerfile</code>里的指令构建镜像，整个构建的过程类似下面：</p><h3 id="验证镜像"><a href="#验证镜像" class="headerlink" title="验证镜像"></a>验证镜像</h3><p>这一步其实可以省略，不过为了确保制作的镜像是没有问题，我们通过<code>docker run</code>命令用这个镜像运行容器验证一下。</p><pre class="line-numbers language-none"><code class="language-none">➜ docker run -d -p 本机端口:容器端口 --rm --name container名 镜像名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这里，我们指示<code>docker</code>从源镜像<code>运行容器，将主机端口</code>绑定到容器的内部端口``，以后台模式（-d）运行容器，给此容器命名为<code>容器名</code>，并在容器结束运行后自动删除容器（–rm）。</p><h3 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h3><p>下面就来介绍一下怎么使用<code>Docker</code>的多阶段构建制作<code>Go</code>应用的镜像。</p><p>之前文章里镜像的<code>Dockerfile</code>长这样：</p><pre class="line-numbers language-none"><code class="language-none">FROM golang:1.14-alpineRUN mkdir /appCOPY . /appWORKDIR /appRUN go build -o main . CMD ["/app/main"]复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用用多阶段构建的方式构建镜像后，<code>Dockerfile</code>会变成类似下面这样：</p><pre class="line-numbers language-none"><code class="language-none">FROM golang:alpine AS buildRUN mkdir /appCOPY . /appWORKDIR /appRUN CGO_ENABLED=0 GOOS=linux go build -o myapp### FROM scratch as finalCOPY --from=build /app/myapp .CMD ["/myapp"]复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="记录一个有sqlite3数据库和golang的Dockerfile书写笔记"><a href="#记录一个有sqlite3数据库和golang的Dockerfile书写笔记" class="headerlink" title="记录一个有sqlite3数据库和golang的Dockerfile书写笔记"></a>记录一个有sqlite3数据库和golang的Dockerfile书写笔记</h2><h3 id="以ubuntu为基础镜像"><a href="#以ubuntu为基础镜像" class="headerlink" title="以ubuntu为基础镜像"></a>以ubuntu为基础镜像</h3><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM ubuntu:latest As build# 配置环境变量ENV GOROOT=/usr/lib/goENV PATH=$PATH:/usr/lib/go/binENV GOPATH=/root/goENV PATH=$GOPATH/bin/:$PATHENV DEBIAN_FRONTEND=noninteractive# 执行命令RUN set -x; buildDeps='gcc libc6-dev make wget' \    &amp;&amp; apt-get update\    &amp;&amp; apt-get install -y $buildDeps \    &amp;&amp; wget https://go.dev/dl/go1.17.5.linux-amd64.tar.gz\    &amp;&amp; tar -xzvf go1.17.5.linux-amd64.tar.gz -C /usr/lib\    &amp;&amp; export GOROOT=/usr/lib/go \    &amp;&amp; ln -s /usr/local/go/bin/* /usr/bin/ \    &amp;&amp; export PATH=$PATH:/usr/lib/go/bin \    &amp;&amp; export GOPATH=/root/go\    &amp;&amp; export PATH=$GOPATH/bin/:$PATH\    &amp;&amp; rm go1.17.5.linux-amd64.tar.gz\    &amp;&amp; wget https://www.sqlite.org/2021/sqlite-autoconf-3370000.tar.gz\    &amp;&amp; tar -xzvf sqlite-autoconf-3370000.tar.gz -C /usr/lib\    &amp;&amp; rm sqlite-autoconf-3370000.tar.gz\    &amp;&amp; cd /usr/lib/sqlite-autoconf-3370000\    &amp;&amp; ./configure --prefix=/usr/local \    &amp;&amp; make \    &amp;&amp; make install \    &amp;&amp; cd .. \    &amp;&amp; mkdir /authCOPY . /auth/WORKDIR /authEXPOSE 8000#安装库依赖项RUN go mod tidy\    &amp;&amp; go build -o server\    &amp;&amp; apt-get purge -y --auto-remove $buildDeps####FROM ubuntu:latest as final#镜像构建参数COPY --from=build /auth/server .CMD ["/server"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Go</code>项目应用的<code>Dockerfile</code>通常大概类似这样，但是每个项目的细节可能有所不同。<code>FROM ubuntu:latest</code>指定了开始阶段的基础映像（其中包含ubuntu的操作系统，无工具和库，用于构建程序），<code>AS build</code>是给这个阶段取名为<code>build</code>。</p><p>ubuntu是专门为容器设计的小型<code>Linux</code>发行版。这个<code>Dockerfile</code>中使用了两次<code>FROM</code>指令，第二条<code>FROM ubuntu</code>行，它告诉<code>Docker</code>从一个全新的，完全空的容器镜像重新开始，然后将上个阶段编译好的程序复制到其中。这个才是我们随后将用于运行的<code>Go</code>应用程序的容器镜像。</p><p><code>Docker</code>用于<code>Go</code>程序的多阶段构建很常见，使用<code>新的</code>镜像可以节省大量空间，因为我们实际上不需要<code>Go</code>工具或其他任何东西来运行我们的编译好的程序，这可能也是<code>Go</code>在容器时代的一个优势吧。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Docker </tag>
            
            <tag> Dockerfile </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是消息队列</title>
      <link href="/zhb233go.github.io/2021/12/20/24-shi-me-shi-xiao-xi-dui-lie/"/>
      <url>/zhb233go.github.io/2021/12/20/24-shi-me-shi-xiao-xi-dui-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h1><h2 id="一、消息模型"><a href="#一、消息模型" class="headerlink" title="一、消息模型"></a>一、消息模型</h2><h3 id="点对点"><a href="#点对点" class="headerlink" title="点对点"></a>点对点</h3><p>消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191212011250613.png" alt="img"></p><h3 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h3><p>消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191212011410374.png" alt="img"></p><p>发布与订阅模式和观察者模式有以下不同：</p><ul><li>观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，生产者与消费者不知道对方的存在，它们之间通过频道进行通信。</li><li>观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，生产者向频道发送一个消息之后，就不需要关心消费者何时去订阅这个消息，可以立即返回。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191212011747967.png" alt="img"></p><h2 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h2><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。</p><p>例如在注册流程中通常需要发送验证邮件来确保注册用户身份的合法性，可以使用消息队列使发送验证邮件的操作异步处理，用户在填写完注册信息之后就可以完成注册，而将发送验证邮件这一消息发送到消息队列中。</p><p>只有在业务流程允许异步处理的情况下才能这么做，例如上面的注册流程中，如果要求用户对验证邮件进行点击之后才能完成注册的话，就不能再使用消息队列。</p><h3 id="流量削锋"><a href="#流量削锋" class="headerlink" title="流量削锋"></a>流量削锋</h3><p>在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。</p><p>可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。</p><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p>如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。</p><p>通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。</p><h2 id="三、可靠性"><a href="#三、可靠性" class="headerlink" title="三、可靠性"></a>三、可靠性</h2><h3 id="发送端的可靠性"><a href="#发送端的可靠性" class="headerlink" title="发送端的可靠性"></a>发送端的可靠性</h3><p>发送端完成操作后一定能将消息成功发送到消息队列中。</p><p>实现方法：在本地数据库建一张消息表，将消息数据与业务数据保存在同一数据库实例里，这样就可以利用本地数据库的事务机制。事务提交成功后，将消息表中的消息转移到消息队列中，若转移消息成功则删除消息表中的数据，否则继续重传。</p><h3 id="接收端的可靠性"><a href="#接收端的可靠性" class="headerlink" title="接收端的可靠性"></a>接收端的可靠性</h3><p>接收端能够从消息队列成功消费一次消息。</p><p>两种实现方法：</p><ul><li>保证接收端处理消息的业务逻辑具有幂等性：只要具有幂等性，那么消费多少次消息，最后处理的结果都是一样的。</li><li>保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://developers-club.com/posts/270339/">Observer vs Pub-Sub(opens new window)</a></li><li><a href="https://blog.csdn.net/lizhitao/article/details/47723105">消息队列中点对点与发布订阅区别</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是分布式？</title>
      <link href="/zhb233go.github.io/2021/12/17/23-shi-me-shi-fen-bu-shi/"/>
      <url>/zhb233go.github.io/2021/12/17/23-shi-me-shi-fen-bu-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是分布式？"><a href="#什么是分布式？" class="headerlink" title="什么是分布式？"></a>什么是分布式？</h1><h2 id="一、分布式锁"><a href="#一、分布式锁" class="headerlink" title="一、分布式锁"></a>一、分布式锁</h2><p>在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。</p><p>阻塞锁通常使用互斥量来实现：</p><ul><li>互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态；</li><li>互斥量为 1 表示未锁定状态。</li></ul><p>1 和 0 可以用一个整型值表示，也可以用某个数据是否存在表示。</p><h3 id="数据库的唯一索引"><a href="#数据库的唯一索引" class="headerlink" title="数据库的唯一索引"></a>数据库的唯一索引</h3><p>获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否处于锁定状态。</p><p>存在以下几个问题：</p><ul><li>锁没有失效时间，解锁失败的话其它进程无法再获得该锁；</li><li>只能是非阻塞锁，插入失败直接就报错了，无法重试；</li><li>不可重入，已经获得锁的进程也必须重新获取锁。</li></ul><h3 id="Redis-的-SETNX-指令"><a href="#Redis-的-SETNX-指令" class="headerlink" title="Redis 的 SETNX 指令"></a>Redis 的 SETNX 指令</h3><p>使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。</p><p>SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。</p><p>EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。</p><h3 id="Redis-的-RedLock-算法"><a href="#Redis-的-RedLock-算法" class="headerlink" title="Redis 的 RedLock 算法"></a>Redis 的 RedLock 算法</h3><p>使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。</p><ul><li>尝试从 N 个互相独立 Redis 实例获取锁；</li><li>计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功；</li><li>如果获取锁失败，就到每个实例上释放锁。</li></ul><h3 id="Zookeeper-的有序节点"><a href="#Zookeeper-的有序节点" class="headerlink" title="Zookeeper 的有序节点"></a>Zookeeper 的有序节点</h3><h4 id="抽象模型"><a href="#抽象模型" class="headerlink" title="抽象模型"></a>抽象模型</h4><p>Zookeeper 提供了一种树形结构的命名空间，/app1/p_1 节点的父节点为 /app1。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/aefa8042-15fa-4e8b-9f50-20b282a2c624.png"></p><h4 id="2-节点类型"><a href="#2-节点类型" class="headerlink" title="2. 节点类型"></a>2. 节点类型</h4><ul><li>永久节点：不会因为会话结束或者超时而消失；</li><li>临时节点：如果会话结束或者超时就会消失；</li><li>有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推。</li></ul><h4 id="3-监听器"><a href="#3-监听器" class="headerlink" title="3. 监听器"></a>3. 监听器</h4><p>为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。</p><h4 id="4-分布式锁实现"><a href="#4-分布式锁实现" class="headerlink" title="4. 分布式锁实现"></a>4. 分布式锁实现</h4><ul><li>创建一个锁目录 /lock；</li><li>当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点；</li><li>客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；</li><li>执行业务代码，完成后，删除对应的子节点。</li></ul><h4 id="5-会话超时"><a href="#5-会话超时" class="headerlink" title="5. 会话超时"></a>5. 会话超时</h4><p>如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，这种实现方式不会出现数据库的唯一索引实现方式释放锁失败的问题。</p><h4 id="6-羊群效应"><a href="#6-羊群效应" class="headerlink" title="6. 羊群效应"></a>6. 羊群效应</h4><p>一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应，一只羊动起来，其它羊也会一哄而上），而我们只希望它的后一个子节点收到通知。</p><h2 id="二、分布式事务"><a href="#二、分布式事务" class="headerlink" title="二、分布式事务"></a>二、分布式事务</h2><p>指事务的操作位于不同的节点上，需要保证事务的 ACID 特性。</p><p>例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。</p><p>分布式锁和分布式事务区别：</p><ul><li>锁问题的关键在于进程操作的互斥关系，例如多个进程同时修改账户的余额，如果没有互斥关系则会导致该账户的余额不正确。</li><li>而事务问题的关键则在于事务涉及的一系列操作需要满足 ACID 特性，例如要满足原子性操作则需要这些操作要么都执行，要么都不执行。</li></ul><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</p><h4 id="1-运行过程"><a href="#1-运行过程" class="headerlink" title="1. 运行过程"></a>1. 运行过程</h4><h5 id="1-1-准备阶段"><a href="#1-1-准备阶段" class="headerlink" title="1.1 准备阶段"></a>1.1 准备阶段</h5><p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。询问可以看成一种投票，需要参与者都同意才能执行。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/44d33643-1004-43a3-b99a-4d688a08d0a1.png"></p><h5 id="1-2-提交阶段"><a href="#1-2-提交阶段" class="headerlink" title="1.2 提交阶段"></a>1.2 提交阶段</h5><p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p><p>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d2ae9932-e2b1-4191-8ee9-e573f36d3895.png"></p><h4 id="2-存在的问题"><a href="#2-存在的问题" class="headerlink" title="2. 存在的问题"></a>2. 存在的问题</h4><h5 id="2-1-同步阻塞"><a href="#2-1-同步阻塞" class="headerlink" title="2.1 同步阻塞"></a>2.1 同步阻塞</h5><p>所有事务参与者在等待其它参与者响应的时候都处于同步阻塞等待状态，无法进行其它操作。</p><h5 id="2-2-单点问题"><a href="#2-2-单点问题" class="headerlink" title="2.2 单点问题"></a>2.2 单点问题</h5><p>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在提交阶段发生故障，所有参与者会一直同步阻塞等待，无法完成其它操作。</p><h5 id="2-3-数据不一致"><a href="#2-3-数据不一致" class="headerlink" title="2.3 数据不一致"></a>2.3 数据不一致</h5><p>在提交阶段，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p><h5 id="2-4-太过保守"><a href="#2-4-太过保守" class="headerlink" title="2.4 太过保守"></a>2.4 太过保守</h5><p>任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p><h3 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h3><p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。</p><ol><li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li><li>之后将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li><li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li></ol><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/476329d4-e2ef-4f7b-8ac9-a52a6f784600.png"></p><h2 id="三、CAP"><a href="#三、CAP" class="headerlink" title="三、CAP"></a>三、CAP</h2><p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a14268b3-b937-4ffa-a34a-4cc53071686b.jpg"></p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p><p>对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。</p><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p><p>在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p><h3 id="分区容忍性"><a href="#分区容忍性" class="headerlink" title="分区容忍性"></a>分区容忍性</h3><p>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p><p>在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p><h3 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h3><p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。</p><p>可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时，</p><ul><li>为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；</li><li>为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。</li></ul><h2 id="四、BASE"><a href="#四、BASE" class="headerlink" title="四、BASE"></a>四、BASE</h2><p>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p><p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p><h3 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h3><p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p><p>例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</p><h3 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h3><p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。</p><h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p><p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。</p><p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p><h2 id="五、Paxos"><a href="#五、Paxos" class="headerlink" title="五、Paxos"></a>五、Paxos</h2><p>用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。</p><p>主要有三类节点：</p><ul><li>提议者（Proposer）：提议一个值；</li><li>接受者（Acceptor）：对每个提议进行投票；</li><li>告知者（Learner）：被告知投票的结果，不参与投票过程。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b988877c-0f0a-4593-916d-de2081320628.jpg"></p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>规定一个提议包含两个字段：[n, v]，其中 n 为序号（具有唯一性），v 为提议值。</p><h4 id="1-Prepare-阶段"><a href="#1-Prepare-阶段" class="headerlink" title="1. Prepare 阶段"></a>1. Prepare 阶段</h4><p>下图演示了两个 Proposer 和三个 Acceptor 的系统中运行该算法的初始过程，每个 Proposer 都会向所有 Acceptor 发送 Prepare 请求。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1a9977e4-2f5c-49a6-aec9-f3027c9f46a7.png"></p><p>当 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n1, v1]，并且之前还未接收过 Prepare 请求，那么发送一个 Prepare 响应，设置当前接收到的提议为 [n1, v1]，并且保证以后不会再接受序号小于 n1 的提议。</p><p>如下图，Acceptor X 在收到 [n=2, v=8] 的 Prepare 请求时，由于之前没有接收过提议，因此就发送一个 [no previous] 的 Prepare 响应，设置当前接收到的提议为 [n=2, v=8]，并且保证以后不会再接受序号小于 2 的提议。其它的 Acceptor 类似。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fb44307f-8e98-4ff7-a918-31dacfa564b4.jpg"></p><p>如果 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n2, v2]，并且之前已经接收过提议 [n1, v1]。如果 n1 &gt; n2，那么就丢弃该提议请求；否则，发送 Prepare 响应，该 Prepare 响应包含之前已经接收过的提议 [n1, v1]，设置当前接收到的提议为 [n2, v2]，并且保证以后不会再接受序号小于 n2 的提议。</p><p>如下图，Acceptor Z 收到 Proposer A 发来的 [n=2, v=8] 的 Prepare 请求，由于之前已经接收过 [n=4, v=5] 的提议，并且 n &gt; 2，因此就抛弃该提议请求；Acceptor X 收到 Proposer B 发来的 [n=4, v=5] 的 Prepare 请求，因为之前接收到的提议为 [n=2, v=8]，并且 2 &lt;= 4，因此就发送 [n=2, v=8] 的 Prepare 响应，设置当前接收到的提议为 [n=4, v=5]，并且保证以后不会再接受序号小于 4 的提议。Acceptor Y 类似。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2bcc58ad-bf7f-485c-89b5-e7cafc211ce2.jpg"></p><h4 id="2-Accept-阶段"><a href="#2-Accept-阶段" class="headerlink" title="2. Accept 阶段"></a>2. Accept 阶段</h4><p>当一个 Proposer 接收到超过一半 Acceptor 的 Prepare 响应时，就可以发送 Accept 请求。</p><p>Proposer A 接收到两个 Prepare 响应之后，就发送 [n=2, v=8] Accept 请求。该 Accept 请求会被所有 Acceptor 丢弃，因为此时所有 Acceptor 都保证不接受序号小于 4 的提议。</p><p>Proposer B 过后也收到了两个 Prepare 响应，因此也开始发送 Accept 请求。需要注意的是，Accept 请求的 v 需要取它收到的最大提议编号对应的 v 值，也就是 8。因此它发送 [n=4, v=8] 的 Accept 请求。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9b838aee-0996-44a5-9b0f-3d1e3e2f5100.png"></p><h4 id="3-Learn-阶段"><a href="#3-Learn-阶段" class="headerlink" title="3. Learn 阶段"></a>3. Learn 阶段</h4><p>Acceptor 接收到 Accept 请求时，如果序号大于等于该 Acceptor 承诺的最小序号，那么就发送 Learn 提议给所有的 Learner。当 Learner 发现有大多数的 Acceptor 接收了某个提议，那么该提议的提议值就被 Paxos 选择出来。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bf667594-bb4b-4634-bf9b-0596a45415ba.jpg"></p><h3 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h3><h4 id="1-正确性"><a href="#1-正确性" class="headerlink" title="1. 正确性"></a>1. 正确性</h4><p>指只有一个提议值会生效。</p><p>因为 Paxos 协议要求每个生效的提议被多数 Acceptor 接收，并且 Acceptor 不会接受两个不同的提议，因此可以保证正确性。</p><h4 id="2-可终止性"><a href="#2-可终止性" class="headerlink" title="2. 可终止性"></a>2. 可终止性</h4><p>指最后总会有一个提议生效。</p><p>Paxos 协议能够让 Proposer 发送的提议朝着能被大多数 Acceptor 接受的那个提议靠拢，因此能够保证可终止性。</p><h2 id="六、Raft"><a href="#六、Raft" class="headerlink" title="六、Raft"></a>六、Raft</h2><p>Raft 也是分布式一致性协议，主要是用来竞选主节点。</p><ul><li><a href="http://thesecretlivesofdata.com/raft">Raft: Understandable Distributed Consensus(opens new window)</a></li></ul><h3 id="单个-Candidate-的竞选"><a href="#单个-Candidate-的竞选" class="headerlink" title="单个 Candidate 的竞选"></a>单个 Candidate 的竞选</h3><p>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p><ul><li>下图展示一个分布式系统的最初阶段，此时只有 Follower 没有 Leader。Node A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118015898.gif"></p><ul><li>此时 Node A 发送投票请求给其它所有节点。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118445538.gif"></p><ul><li>其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118483039.gif"></p><ul><li>之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118640738.gif"></p><h3 id="多个-Candidate-竞选"><a href="#多个-Candidate-竞选" class="headerlink" title="多个 Candidate 竞选"></a>多个 Candidate 竞选</h3><ul><li>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票。例如下图中 Node B 和 Node D 都获得两票，需要重新开始投票。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521119203347.gif"></p><ul><li>由于每个节点设置的随机竞选超时时间不同，因此下一次再次出现多个 Candidate 并获得同样票数的概率很低。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521119368714.gif"></p><h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><ul><li>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/71550414107576.gif"></p><ul><li>Leader 会把修改复制到所有 Follower。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/91550414131331.gif"></p><ul><li>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/101550414151983.gif"></p><ul><li>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111550414182638.gif"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>倪超. 从 Paxos 到 ZooKeeper : 分布式一致性原理与实践 [M]. 电子工业出版社, 2015.</li><li><a href="https://redis.io/topics/distlock">Distributed locks with Redis(opens new window)</a></li><li><a href="http://www.linkedkeeper.com/detail/blog.action?bid=1023">浅谈分布式锁(opens new window)</a></li><li><a href="http://www.dengshenyu.com/java/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2017/10/23/zookeeper-distributed-lock.html">基于 Zookeeper 的分布式锁(opens new window)</a></li><li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html">聊聊分布式事务，再说说解决方案(opens new window)</a></li><li><a href="https://coolshell.cn/articles/10910.html">分布式系统的事务处理(opens new window)</a></li><li><a href="https://juejin.im/entry/577c6f220a2b5800573492be">深入理解分布式事务(opens new window)</a></li><li><a href="http://www.colooshiki.com/index.php/2017/04/20/what-is-cap-theorem-in-distributed-database-system/">What is CAP theorem in distributed database system?(opens new window)</a></li><li><a href="http://harry.me/blog/2014/12/27/neat-algorithms-paxos/">NEAT ALGORITHMS - PAXOS(opens new window)</a></li><li>[Paxos By Example](</li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是缓存？</title>
      <link href="/zhb233go.github.io/2021/12/16/22-shi-me-shi-huan-cun/"/>
      <url>/zhb233go.github.io/2021/12/16/22-shi-me-shi-huan-cun/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是缓存？"><a href="#什么是缓存？" class="headerlink" title="什么是缓存？"></a>什么是缓存？</h1><h2 id="一、缓存特征"><a href="#一、缓存特征" class="headerlink" title="一、缓存特征"></a>一、缓存特征</h2><h3 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h3><p>当某个请求能够通过访问缓存而得到响应时，称为缓存命中。</p><p>缓存命中率越高，缓存的利用率也就越高。</p><h3 id="最大空间"><a href="#最大空间" class="headerlink" title="最大空间"></a>最大空间</h3><p>缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。</p><p>当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。</p><h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><ul><li>FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。</li><li>LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。</li><li>LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。</li></ul><h2 id="二、缓存位置"><a href="#二、缓存位置" class="headerlink" title="二、缓存位置"></a>二、缓存位置</h2><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。</p><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><p>网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。</p><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。</p><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p>使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。</p><p>相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。</p><h3 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h3><p>MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。</p><p>###Java 内部的缓存</p><p>Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。</p><h3 id="CPU-多级缓存"><a href="#CPU-多级缓存" class="headerlink" title="CPU 多级缓存"></a>CPU 多级缓存</h3><p>CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。</p><h2 id="三、CDN"><a href="#三、CDN" class="headerlink" title="三、CDN"></a>三、CDN</h2><p>内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。</p><p>CDN 主要有以下优点：</p><ul><li>更快地将数据分发给用户；</li><li>通过部署多台服务器，从而提高系统整体的带宽性能；</li><li>多台服务器可以看成是一种冗余机制，从而具有高可用性。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15313ed8-a520-4799-a300-2b6b36be314f.jpg" alt="img"></p><h2 id="四、缓存问题"><a href="#四、缓存问题" class="headerlink" title="四、缓存问题"></a>四、缓存问题</h2><p>###缓存穿透</p><p>指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。</p><p>解决方案：</p><ul><li>对这些不存在的数据缓存一个空数据；</li><li>对这类请求进行过滤。</li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。</p><p>在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。</p><p>解决方案：</p><ul><li>为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；</li><li>为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。</li><li>也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li></ul><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>缓存一致性要求数据更新的同时缓存数据也能够实时更新。</p><p>解决方案：</p><ul><li>在数据更新的同时立即去更新缓存；</li><li>在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。</li></ul><p>要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。</p><h3 id="缓存-“无底洞”-现象"><a href="#缓存-“无底洞”-现象" class="headerlink" title="缓存 “无底洞” 现象"></a>缓存 “无底洞” 现象</h3><p>指的是为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降了的现象。</p><p>产生原因：缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外，网络连接数变多，对节点的性能也有一定影响。</p><p>解决方案：</p><ul><li>优化批量数据操作命令；</li><li>减少网络通信次数；</li><li>降低接入成本，使用长连接 / 连接池，NIO 等。</li></ul><h2 id="五、数据分布"><a href="#五、数据分布" class="headerlink" title="五、数据分布"></a>五、数据分布</h2><h3 id="哈希分布"><a href="#哈希分布" class="headerlink" title="哈希分布"></a>哈希分布</h3><p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。</p><p>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。</p><h3 id="顺序分布"><a href="#顺序分布" class="headerlink" title="顺序分布"></a>顺序分布</h3><p>将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，…，6001 ~ 7000。</p><p>顺序分布相比于哈希分布的主要优点如下：</p><ul><li>能保持数据原有的顺序；</li><li>并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。</li></ul><h2 id="六、一致性哈希"><a href="#六、一致性哈希" class="headerlink" title="六、一致性哈希"></a>六、一致性哈希</h2><p>Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>将哈希空间 [0, 2n-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/68b110b9-76c6-4ee2-b541-4145e65adb3e.jpg" alt="img"></p><p>一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将它前一个节点 C 上的数据重新进行分布即可，对于节点 A、B、D 都没有影响。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66402828-fb2b-418f-83f6-82153491bcfe.jpg" alt="img"></p><h3 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h3><p>上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。</p><p>数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。</p><p>解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。</p><h2 id="七、LRU"><a href="#七、LRU" class="headerlink" title="七、LRU"></a>七、LRU</h2><p>以下是基于 双向链表 + HashMap 的 LRU 算法实现，对算法的解释如下：</p><ul><li>访问某个节点时，将其从原来的位置删除，并重新插入到链表头部。这样就能保证链表尾部存储的就是最近最久未使用的节点，当节点数量大于缓存最大空间时就淘汰链表尾部的节点。</li><li>为了使删除操作时间复杂度为 O(1)，就不能采用遍历的方式找到某个节点。HashMap 存储着 Key 到节点的映射，通过 Key 就能以 O(1) 的时间得到节点，然后再以 O(1) 的时间将其从双向队列中删除。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>大规模分布式存储系统</li><li><a href="https://tech.meituan.com/cache_about.html">缓存那些事(opens new window)</a></li><li><a href="https://my.oschina.net/jayhu/blog/732849">一致性哈希算法(opens new window)</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF">内容分发网络(opens new window)</a></li><li><a href="https://www.aspirationhosting.com/aspiration-cdn/">How Aspiration CDN helps to improve your website loading speed?</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言使用阿里云实现短信发送/验证服务（gin框架）</title>
      <link href="/zhb233go.github.io/2021/12/16/go-yu-yan-shi-yong-a-li-yun-shi-xian-duan-xin-fa-song-yan-zheng-fu-wu-gin-kuang-jia/"/>
      <url>/zhb233go.github.io/2021/12/16/go-yu-yan-shi-yong-a-li-yun-shi-xian-duan-xin-fa-song-yan-zheng-fu-wu-gin-kuang-jia/</url>
      
        <content type="html"><![CDATA[<h1 id="go语言使用阿里云实现短信发送-验证服务（gin框架）"><a href="#go语言使用阿里云实现短信发送-验证服务（gin框架）" class="headerlink" title="go语言使用阿里云实现短信发送/验证服务（gin框架）"></a>go语言使用阿里云实现短信发送/验证服务（gin框架）</h1><h3 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h3><h2 id="短信批量发送结果查询-CodeSample"><a href="#短信批量发送结果查询-CodeSample" class="headerlink" title="短信批量发送结果查询 CodeSample"></a>短信批量发送结果查询 CodeSample</h2><p>该项目为通过 SendSms 发送短信并查询发送的结 CodeSample，生成的代码可以通过安装<a href="https://darabonba.api.aliyun.com/module/alibabacloud/CS20151215">各语言的包</a>来进行测试。</p><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><ul><li>在您开始之前，您需要注册阿里云帐户并获取您的 <a href="https://usercenter.console.aliyun.com/#/manage/ak">凭证</a></li></ul><h3 id="使用的-API"><a href="#使用的-API" class="headerlink" title="使用的 API"></a>使用的 API</h3><ul><li>SendBatchSms 批量发送短信，可以参考：<a href="https://help.aliyun.com/document_detail/101414.html">文档</a></li><li>QuerySendDetails 查询短信的发送情况，可以参考：<a href="https://help.aliyun.com/document_detail/102352.html">文档</a></li></ul><h3 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">&lt;phoneNumbers&gt;: 接收短信的手机号码，多个用英文逗号隔开&lt;signNameJson&gt;: 短信签名名称，eg: "阿里云"&lt;templateCode&gt;: 短信模板CODE&lt;templateParamJson&gt;: 短信模板变量对应的实际值，eg：{"code":"1234"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="返回示例"><a href="#返回示例" class="headerlink" title="返回示例"></a>返回示例</h3><p>QuerySendDetails：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">{"TotalCount":1,"Message":"OK","RequestId":"819BE656-D2E0-4858-8B21-B2E477085AAF","SmsSendDetailDTOs":{"SmsSendDetailDTO":{"SendDate":"2019-01-08 16:44:10","OutId":123,"SendStatus":3,"ReceiveDate":"2019-01-08 16:44:13","ErrCode":"DELIVERED","TemplateCode":"SMS_122310183","Content":"【阿里云】验证码为：123，您正在登录，若非本人操作，请勿泄露","PhoneNum":15298356881}},"Code":"OK"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="本人测试代码如下："><a href="#本人测试代码如下：" class="headerlink" title="本人测试代码如下："></a>本人测试代码如下：</h3><h5 id="用户信息结构体："><a href="#用户信息结构体：" class="headerlink" title="用户信息结构体："></a>用户信息结构体：</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> UserInfo <span class="token keyword">struct</span> <span class="token punctuation">{</span>Uid              <span class="token builtin">int64</span>Account          <span class="token builtin">string</span>Password         <span class="token builtin">string</span>Phone            <span class="token builtin">string</span>Email            <span class="token builtin">string</span>VerificationCode <span class="token builtin">string</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="短信发送部分代码："><a href="#短信发送部分代码：" class="headerlink" title="短信发送部分代码："></a>短信发送部分代码：</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// GetSMSverification 通过短信发送验证码</span><span class="token keyword">func</span> <span class="token function">GetSMSVerification</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>data <span class="token operator">:=</span> Models<span class="token punctuation">.</span>UserInfo<span class="token punctuation">{</span><span class="token punctuation">}</span>err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">BindJSON</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>Utils<span class="token punctuation">.</span><span class="token function">HandleErr</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> err<span class="token punctuation">,</span> <span class="token string">"获取数据失败"</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>user <span class="token operator">:=</span> <span class="token operator">&amp;</span>Models<span class="token punctuation">.</span>UserInfo<span class="token punctuation">{</span>Phone<span class="token punctuation">:</span> data<span class="token punctuation">.</span>Phone<span class="token punctuation">}</span>isExist <span class="token operator">:=</span> <span class="token operator">&amp;</span>dataisExist<span class="token punctuation">.</span><span class="token function">QueryPhone</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>Phone<span class="token punctuation">)</span><span class="token comment">//发送验证码</span>request <span class="token operator">:=</span> Models<span class="token punctuation">.</span>ALiYunCommunicationRequest<span class="token punctuation">{</span><span class="token punctuation">}</span>randcode <span class="token operator">:=</span> Utils<span class="token punctuation">.</span><span class="token function">GenerateRandNum</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>    <span class="token comment">//需获取AliYun的短信服务签名和短信模板</span>req <span class="token operator">:=</span> request<span class="token punctuation">.</span><span class="token function">SetParamsValue</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>Phone<span class="token punctuation">,</span> signName<span class="token punctuation">,</span> randcode<span class="token punctuation">,</span> TemplateParam<span class="token punctuation">)</span>err <span class="token operator">=</span> req<span class="token punctuation">.</span><span class="token function">SendReq</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Utils<span class="token punctuation">.</span><span class="token function">HandleErr</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> err<span class="token punctuation">,</span> <span class="token string">"发送失败"</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">{</span><span class="token string">"verification"</span><span class="token punctuation">:</span> randcode<span class="token punctuation">,</span><span class="token string">"result"</span><span class="token punctuation">:</span>       <span class="token string">"发送成功"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">//记录本地验证码</span>user<span class="token punctuation">.</span>VerificationCode <span class="token operator">=</span> randcode<span class="token comment">//给定过期时间</span>timer <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTimer</span><span class="token punctuation">(</span><span class="token number">60</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token keyword">select</span> <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token operator">&lt;-</span>timer<span class="token punctuation">.</span>C<span class="token punctuation">:</span>user<span class="token punctuation">.</span>VerificationCode <span class="token operator">=</span> <span class="token string">"expired"</span><span class="token punctuation">}</span>timer<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="短信验证部分代码："><a href="#短信验证部分代码：" class="headerlink" title="短信验证部分代码："></a>短信验证部分代码：</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// LoginbySMS  通过SMS用户登录</span><span class="token keyword">func</span> <span class="token function">LoginbySMS</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>data <span class="token operator">:=</span> Models<span class="token punctuation">.</span>UserInfo<span class="token punctuation">{</span><span class="token punctuation">}</span>err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">BindJSON</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>Utils<span class="token punctuation">.</span><span class="token function">HandleErr</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> err<span class="token punctuation">,</span> <span class="token string">"获取数据失败"</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>VerificationCode<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">{</span><span class="token string">"verification"</span><span class="token punctuation">:</span> <span class="token boolean">nil</span><span class="token punctuation">,</span><span class="token string">"result"</span><span class="token punctuation">:</span>       <span class="token string">"获取数据失败"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>user <span class="token operator">:=</span> <span class="token operator">&amp;</span>Models<span class="token punctuation">.</span>UserInfo<span class="token punctuation">{</span>VerificationCode<span class="token punctuation">:</span> data<span class="token punctuation">.</span>VerificationCode<span class="token punctuation">}</span> <span class="token comment">//填入的验证码</span>isExist <span class="token operator">:=</span> <span class="token operator">&amp;</span>dataisExist<span class="token punctuation">.</span><span class="token function">QueryPhone</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>Phone<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>VerificationCode<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">{</span><span class="token string">"verification"</span><span class="token punctuation">:</span> user<span class="token punctuation">.</span>VerificationCode<span class="token punctuation">,</span><span class="token string">"result"</span><span class="token punctuation">:</span>       <span class="token string">"验证码输入错误"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">if</span> user<span class="token punctuation">.</span>VerificationCode <span class="token operator">==</span> <span class="token string">"expired"</span> <span class="token punctuation">{</span>c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">{</span><span class="token string">"verification"</span><span class="token punctuation">:</span> user<span class="token punctuation">.</span>VerificationCode<span class="token punctuation">,</span><span class="token string">"result"</span><span class="token punctuation">:</span>       <span class="token string">"验证码过期"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">//填入的验证码与数据库的验证码进行比较</span><span class="token keyword">if</span> user<span class="token punctuation">.</span>VerificationCode <span class="token operator">==</span> data<span class="token punctuation">.</span>VerificationCode <span class="token punctuation">{</span><span class="token function">SetCookie</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> data<span class="token punctuation">.</span>Uid<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">{</span><span class="token string">"verificationCode"</span><span class="token punctuation">:</span> user<span class="token punctuation">.</span>VerificationCode<span class="token punctuation">,</span><span class="token string">"result"</span><span class="token punctuation">:</span>           <span class="token string">"验证码错误"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><p>因为短信签名需要完整的网站和App才能申请成功，不能看到实际短信情况，但在postman测试是成功返回，待网站建设完好后，再展示短信结果。。。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Gin框架 </tag>
            
            <tag> AliYun </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言实现邮箱验证/邮件发送</title>
      <link href="/zhb233go.github.io/2021/12/15/go-yu-yan-shi-xian-you-xiang-yan-zheng-you-jian-fa-song/"/>
      <url>/zhb233go.github.io/2021/12/15/go-yu-yan-shi-xian-you-xiang-yan-zheng-you-jian-fa-song/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言实现邮箱验证-邮件发送"><a href="#Go语言实现邮箱验证-邮件发送" class="headerlink" title="Go语言实现邮箱验证/邮件发送"></a>Go语言实现邮箱验证/邮件发送</h1><h3 id="1-首先设置邮箱的smtp"><a href="#1-首先设置邮箱的smtp" class="headerlink" title="1.首先设置邮箱的smtp"></a>1.首先设置邮箱的smtp</h3><p>SMTP服务器就是邮件代收发服务器，由邮件服务商提供，常见的SMTP服务器端口号：<br>QQ邮箱：SMTP服务器地址：smtp.qq.com（端口：587）<br>雅虎邮箱: SMTP服务器地址：smtp.yahoo.com（端口：587）<br>163邮箱：SMTP服务器地址：smtp.163.com（端口：25）<br>126邮箱: SMTP服务器地址：smtp.126.com（端口：25）<br>新浪邮箱: SMTP服务器地址：smtp.sina.com（端口：25）</p><p>登录邮箱账户 设置开启SMTP 并获取授权码</p><p>我使用的是QQ邮箱进行测试</p><p><img src="https://hypo-pictrue-1308430808.cos.ap-shanghai.myqcloud.com/hypo.ltd-%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8/qqmail_test.jpg" alt="qqmail"></p><p>QQ邮箱默认关闭SMTP服务，将IMAP/SMTP服务打开，跟着流程做后你会得到令牌密码。</p><h3 id="代码实现如下："><a href="#代码实现如下：" class="headerlink" title="代码实现如下："></a>代码实现如下：</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">SendToMail</span><span class="token punctuation">(</span>rand<span class="token punctuation">,</span> to <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>subject <span class="token operator">:=</span> <span class="token string">"动态验证码"</span>user <span class="token operator">:=</span> <span class="token string">"user@qq.com"</span>password <span class="token operator">:=</span> <span class="token string">"**********"</span> <span class="token comment">//输入刚得到的令牌</span>host <span class="token operator">:=</span> <span class="token string">"smtp.qq.com:587"</span>body <span class="token operator">:=</span> <span class="token string">"您的动态验证码为："</span> <span class="token operator">+</span> rand <span class="token operator">+</span> <span class="token string">"，您正在进行密码重置操作，如非本人操作，请忽略本邮件！"</span>sendUserName <span class="token operator">:=</span> <span class="token string">"senderName"</span> <span class="token comment">//发送邮件的人名称</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"send email"</span><span class="token punctuation">)</span>hp <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> <span class="token string">":"</span><span class="token punctuation">)</span>auth <span class="token operator">:=</span> smtp<span class="token punctuation">.</span><span class="token function">PlainAuth</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> user<span class="token punctuation">,</span> password<span class="token punctuation">,</span> hp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">var</span> content_type <span class="token builtin">string</span>mailtype <span class="token operator">:=</span> <span class="token string">""</span><span class="token keyword">if</span> mailtype <span class="token operator">==</span> <span class="token string">"html"</span> <span class="token punctuation">{</span>content_type <span class="token operator">=</span> <span class="token string">"Content-Type: text/"</span> <span class="token operator">+</span> mailtype <span class="token operator">+</span> <span class="token string">"; charset=UTF-8"</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>content_type <span class="token operator">=</span> <span class="token string">"Content-Type: text/plain"</span> <span class="token operator">+</span> <span class="token string">"; charset=UTF-8"</span><span class="token punctuation">}</span>msg <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"To: "</span> <span class="token operator">+</span> to <span class="token operator">+</span> <span class="token string">"\r\nFrom: "</span> <span class="token operator">+</span> sendUserName <span class="token operator">+</span> <span class="token string">"&lt;"</span> <span class="token operator">+</span> user <span class="token operator">+</span> <span class="token string">"&gt;"</span> <span class="token operator">+</span> <span class="token string">"\r\nSubject: "</span> <span class="token operator">+</span> subject <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token operator">+</span> content_type <span class="token operator">+</span> <span class="token string">"\r\n\r\n"</span> <span class="token operator">+</span> body<span class="token punctuation">)</span>send_to <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token string">";"</span><span class="token punctuation">)</span>err <span class="token operator">:=</span> smtp<span class="token punctuation">.</span><span class="token function">SendMail</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> auth<span class="token punctuation">,</span> user<span class="token punctuation">,</span> send_to<span class="token punctuation">,</span> msg<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"send email"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Send mail error!"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Send mail success!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span> err<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//发送验证码</span>randcode <span class="token operator">:=</span> Utils<span class="token punctuation">.</span><span class="token function">GenerateRandNum</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token comment">//随机6位数</span>err <span class="token operator">=</span> Models<span class="token punctuation">.</span><span class="token function">SendToMail</span><span class="token punctuation">(</span>randcode<span class="token punctuation">,</span>user<span class="token punctuation">.</span>Email<span class="token punctuation">)</span>    log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"验证码发送失败,err:%s"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span>c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">{</span><span class="token string">"verification"</span><span class="token punctuation">:</span> randcode<span class="token punctuation">,</span><span class="token string">"result"</span><span class="token punctuation">:</span>       <span class="token string">"发送成功"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成功发送：</p><p><img src="https://hypo-pictrue-1308430808.cos.ap-shanghai.myqcloud.com/hypo.ltd-%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8/qqmail_test_success.jpg" alt="success"></p><h3 id="遇到的几个坑"><a href="#遇到的几个坑" class="headerlink" title="遇到的几个坑"></a>遇到的几个坑</h3><ul><li>smtp.SendMail 后出现 EOF 失败</li></ul><p><strong>解决方法：</strong> QQmail 的 465 端口用于通过 TLS 连接，但 SendMail 需要普通的旧 TCP。尝试连接到端口 587。SendMail 将在可用时自动升级到 TLS（在本例中就是这种情况）。</p><p>还需要解决的问题：</p><ul><li>这个只能单人进行验证，如果多个人同时验证会造成验证码记录覆盖，导致用户输入验证码错误。</li></ul><p>代解决。。。</p><p><strong>解决方法：</strong> 将验证码记录在本地数据库个人用户的字段中，并设置过期时间，时间一到就会被覆盖掉；<br>验证时，在过期时间之前，通过邮箱号查找验证码比较是否相同，即可解决多个用户验证问题。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Gin框架 </tag>
            
            <tag> SMTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin框架中使用JWT进行接口认证</title>
      <link href="/zhb233go.github.io/2021/12/07/gin-kuang-jia-zhong-shi-yong-jwt-jin-xing-jie-kou-ren-zheng/"/>
      <url>/zhb233go.github.io/2021/12/07/gin-kuang-jia-zhong-shi-yong-jwt-jin-xing-jie-kou-ren-zheng/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.cn/user/1556564193589431"><img src="https://p26-passport.byteacctimg.com/img/user-avatar/3e505a96513d6dcbb77fbea3b4d936db~300x300.image" alt="img"></a></p><p><a href="https://juejin.cn/user/1556564193589431">CloudNativeOps <img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/f597b88d22ce5370bd94495780459040.svg" alt="lv-2"></a></p><p>2020年03月15日 阅读 5401</p><p>关注</p><h1 id="Gin框架中使用JWT进行接口认证"><a href="#Gin框架中使用JWT进行接口认证" class="headerlink" title="Gin框架中使用JWT进行接口认证"></a>Gin框架中使用JWT进行接口认证</h1><blockquote><p>背景: 在如今前后端分离开发的大环境中，我们需要解决一些登陆，后期身份认证以及鉴权相关的事情，通常的方案就是采用请求头携带token的方式进行实现。本篇文章主要分享下在Golang语言下使用<a href="https://link.juejin.cn/?target=https://github.com/dgrijalva/jwt-go">jwt-go</a>来实现后端的token认证逻辑。</p></blockquote><p><code>JSON Web Token(JWT)</code>是一个常用语HTTP的客户端和服务端间进行身份认证和鉴权的标准规范，使用JWT可以允许我们在用户和服务器之间传递安全可靠的信息。</p><p>在开始学习<a href="https://link.juejin.cn/?target=https://jwt.io/">JWT</a>之前，我们可以先了解下早期的几种方案。</p><h3 id="token、cookie、session的区别"><a href="#token、cookie、session的区别" class="headerlink" title="token、cookie、session的区别"></a>token、cookie、session的区别</h3><p><strong>Cookie</strong></p><p>Cookie总是保存在客户端中，按在客户端中的存储位置，可分为<code>内存Cookie</code>和<code>硬盘Cookie</code>。</p><p>内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。所以，按存在时间，可分为<code>非持久Cookie和持久Cookie</code>。</p><p>cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。</p><p><code>cookie由服务器生成，发送给浏览器</code>，浏览器把cookie以key-value形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。</p><p><strong>Session</strong></p><p>Session字面意思是会话，主要用来标识自己的身份。比如在无状态的api服务在多次请求数据库时，如何知道是同一个用户，这个就可以通过session的机制，服务器要知道当前发请求给自己的是谁</p><p>为了区分客户端请求，<code>服务端会给具体的客户端生成身份标识session</code>，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。</p><p>至于客户端如何保存该标识，可以有很多方式，对于浏览器而言，一般都是使用<code>cookie</code>的方式</p><p>服务器使用session把用户信息临时保存了服务器上，用户离开网站就会销毁，这种凭证存储方式相对于cookie来说更加安全，但是session会有一个缺陷: 如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。</p><p>因此，通常企业里会使用<code>redis,memcached</code>缓存中间件来实现session的共享，此时web服务器就是一个完全无状态的存在，所有的用户凭证可以通过共享session的方式存取，当前session的过期和销毁机制需要用户做控制。</p><p><strong>Token</strong></p><p>token的意思是“令牌”，是用户身份的验证方式，最简单的token组成: <code>uid(用户唯一标识)</code>+<code>time(当前时间戳)</code>+<code>sign(签名,由token的前几位+盐以哈希算法压缩成一定长度的十六进制字符串)</code>，同时还可以将不变的参数也放进token</p><p>这里我们主要想讲的就是<code>Json Web Token</code>，也就是本篇的主题:JWT</p><h3 id="Json-Web-Token-JWT-介绍"><a href="#Json-Web-Token-JWT-介绍" class="headerlink" title="Json-Web-Token(JWT)介绍"></a>Json-Web-Token(JWT)介绍</h3><p>一般而言，用户注册登陆后会生成一个jwt token返回给浏览器，浏览器向服务端请求数据时携带<code>token</code>，服务器端使用<code>signature</code>中定义的方式进行解码，进而对token进行解析和验证。</p><h4 id="JWT-Token组成部分"><a href="#JWT-Token组成部分" class="headerlink" title="JWT Token组成部分"></a>JWT Token组成部分</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170ddb5b098f391d~tplv-t2oaga2asx-watermark.awebp" alt="JWT-Token组成部分">JWT-Token组成部分</p><ul><li>header: 用来指定使用的算法(HMAC SHA256 RSA)和token类型(如JWT)</li><li>payload: 包含声明(要求)，声明通常是用户信息或其他数据的声明，比如用户id，名称，邮箱等. 声明可分为三种: registered,public,private</li><li>signature: 用来保证JWT的真实性，可以使用不同的算法</li></ul><p><strong>header</strong></p><pre class="line-numbers language-none"><code class="language-none">{    "alg": "HS256",    "typ": "JWT"}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对上面的json进行base64编码即可得到JWT的第一个部分</p><p><strong>payload</strong></p><ul><li>registered claims: 预定义的声明，通常会放置一些预定义字段，比如过期时间，主题等(iss:issuer,exp:expiration time,sub:subject,aud:audience)</li><li>public claims: 可以设置公开定义的字段</li><li>private claims: 用于统一使用他们的各方之间的共享信息</li></ul><pre class="line-numbers language-none"><code class="language-none">{    "sub": "xxx-api",    "name": "bgbiao.top",    "admin": true}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对payload部分的json进行base64编码后即可得到JWT的第二个部分</p><p><code>注意:</code> 不要在header和payload中放置敏感信息，除非信息本身已经做过脱敏处理</p><p><strong>signature</strong></p><p>为了得到签名部分，必须有编码过的header和payload，以及一个秘钥，签名算法使用header中指定的那个，然后对其进行签名即可</p><pre class="line-numbers language-none"><code class="language-none">HMACSHA256(base64UrlEncode(header)+"."+base64UrlEncode(payload),secret)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>签名是<code>用于验证消息在传递过程中有没有被更改</code>，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。</p><p>在<a href="https://link.juejin.cn/?target=https://jwt.io">jwt.io</a>网站中，提供了一些JWT token的编码，验证以及生成jwt的工具。</p><p>下图就是一个典型的jwt-token的组成部分。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170ddb5b072d445e~tplv-t2oaga2asx-watermark.awebp" alt="jwt官方签名结构">jwt官方签名结构</p><h4 id="什么时候用JWT"><a href="#什么时候用JWT" class="headerlink" title="什么时候用JWT"></a>什么时候用JWT</h4><ul><li>Authorization(授权): 典型场景，用户请求的token中包含了该令牌允许的路由，服务和资源。单点登录其实就是现在广泛使用JWT的一个特性</li><li>Information Exchange(信息交换): 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式.因为JWTs可以被签名，例如，用公钥/私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改</li></ul><h4 id="JWT-Json-Web-Tokens-是如何工作的"><a href="#JWT-Json-Web-Tokens-是如何工作的" class="headerlink" title="JWT(Json Web Tokens)是如何工作的"></a>JWT(Json Web Tokens)是如何工作的</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170ddb5b09686448~tplv-t2oaga2asx-watermark.awebp" alt="JWT认证过程">JWT认证过程</p><p>所以，基本上整个过程分为两个阶段，第一个阶段，客户端向服务端获取token，第二阶段，客户端带着该token去请求相关的资源.</p><p>通常比较重要的是，服务端如何根据指定的规则进行token的生成。</p><p>在认证的时候，当用户用他们的凭证成功登录以后，一个JSON Web Token将会被返回。</p><p>此后，token就是用户凭证了，你必须非常小心以防止出现安全问题。</p><p>一般而言，你保存令牌的时候不应该超过你所需要它的时间。</p><p>无论何时用户想要访问受保护的路由或者资源的时候，用户代理（通常是浏览器）都应该带上JWT，典型的，通常放在Authorization header中，用Bearer schema: <code>Authorization: Bearer &lt;token&gt;</code></p><p>服务器上的受保护的路由将会检查Authorization header中的JWT是否有效，如果有效，则用户可以访问受保护的资源。如果JWT包含足够多的必需的数据，那么就可以减少对某些操作的数据库查询的需要，尽管可能并不总是如此。</p><p>如果token是在授权头（Authorization header）中发送的，那么跨源资源共享(CORS)将不会成为问题，因为它不使用cookie.</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170ddb5b0a3068a5~tplv-t2oaga2asx-watermark.awebp" alt="获取JWT以及访问APIs以及资源">获取JWT以及访问APIs以及资源</p><ul><li>客户端向授权接口请求授权</li><li>服务端授权后返回一个access token给客户端</li><li>客户端使用access token访问受保护的资源</li></ul><h4 id="基于Token的身份认证和基于服务器的身份认证"><a href="#基于Token的身份认证和基于服务器的身份认证" class="headerlink" title="基于Token的身份认证和基于服务器的身份认证"></a>基于Token的身份认证和基于服务器的身份认证</h4><p><strong>1.基于服务器的认证</strong></p><p>前面说到过session，cookie以及token的区别，在之前传统的做法就是基于存储在服务器上的session来做用户的身份认证，但是通常会有如下问题:</p><ul><li>Sessions: 认证通过后需要将用户的session数据保存在内存中，随着认证用户的增加，内存开销会大</li><li>扩展性: 由于session存储在内存中，扩展性会受限，虽然后期可以使用redis,memcached来缓存数据</li><li>CORS: 当多个终端访问同一份数据时，可能会遇到禁止请求的问题</li><li>CSRF: 用户容易受到CSRF攻击</li></ul><p><strong>2.Session和JWT Token的异同</strong></p><p>都可以存储用户相关信息，但是session存储在服务端，JWT存储在客户端</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170ddb5b0a56f132~tplv-t2oaga2asx-watermark.awebp" alt="session和jwt数据存储位置">session和jwt数据存储位置</p><p><strong>3.基于Token的身份认证如何工作</strong></p><p>基于Token的身份认证是无状态的，服务器或者session中不会存储任何用户信息.(很好的解决了共享session的问题)</p><ul><li>用户携带用户名和密码请求获取token(接口数据中可使用appId,appKey)</li><li>服务端校验用户凭证，并返回用户或客户端一个Token</li><li>客户端存储token,并在请求头中携带Token</li><li>服务端校验token并返回数据</li></ul><pre class="line-numbers language-none"><code class="language-none">注意:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>随后客户端的每次请求都需要使用token</li><li>token应该放在header中</li><li>需要将服务器设置为接收所有域的请求: <code>Access-Control-Allow-Origin: *</code></li></ul><p><strong>4.用Token的好处</strong></p><ul><li>无状态和可扩展性</li><li>安全: 防止CSRF攻击;token过期重新认证</li></ul><p><strong>5.JWT和OAuth的区别</strong></p><ul><li>1.OAuth2是一种授权框架 ，JWT是一种认证协议</li><li>2.无论使用哪种方式切记用HTTPS来保证数据的安全性</li><li>3.OAuth2用在<code>使用第三方账号登录的情况</code>(比如使用weibo, qq, github登录某个app)，而<code>JWT是用在前后端分离</code>, 需要简单的对后台API进行保护时使用</li></ul><h3 id="使用Gin框架集成JWT"><a href="#使用Gin框架集成JWT" class="headerlink" title="使用Gin框架集成JWT"></a>使用Gin框架集成JWT</h3><p>在Golang语言中，<a href="https://link.juejin.cn/?target=https://github.com/dgrijalva/jwt-go">jwt-go</a>库提供了一些jwt编码和验证的工具，因此我们很容易使用该库来实现token认证。</p><p>另外，我们也知道<a href="https://link.juejin.cn/?target=https://github.com/gin-gonic/gin">gin</a>框架中支持用户自定义middleware，我们可以很好的将jwt相关的逻辑封装在middleware中，然后对具体的接口进行认证。</p><h4 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h4><p>在gin框架中，自定义中间件比较容易，只要返回一个<code>gin.HandlerFunc</code>即完成一个中间件定义。</p><p>接下来，我们先定义一个用于jwt认证的中间件.</p><pre class="line-numbers language-none"><code class="language-none">// 定义一个JWTAuth的中间件func JWTAuth() gin.HandlerFunc {return func(c *gin.Context) {// 通过http header中的token解析来认证token := c.Request.Header.Get("token")if token == "" {c.JSON(http.StatusOK, gin.H{"status": -1,"msg":    "请求未携带token，无权限访问","data":   nil,})c.Abort()return}log.Print("get token: ", token)// 初始化一个JWT对象实例，并根据结构体方法来解析tokenj := NewJWT()// 解析token中包含的相关信息(有效载荷)claims, err := j.ParserToken(token)if err != nil {// token过期if err == TokenExpired {c.JSON(http.StatusOK, gin.H{"status": -1,"msg":    "token授权已过期，请重新申请授权","data":   nil,})c.Abort()return}// 其他错误c.JSON(http.StatusOK, gin.H{"status": -1,"msg":    err.Error(),"data":   nil,})c.Abort()return}// 将解析后的有效载荷claims重新写入gin.Context引用对象中c.Set("claims", claims)}}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="定义jwt编码和解码逻辑"><a href="#定义jwt编码和解码逻辑" class="headerlink" title="定义jwt编码和解码逻辑"></a>定义jwt编码和解码逻辑</h4><p>根据前面提到的jwt-token的组成部分，以及<code>jwt-go</code>中相关的定义，我们可以使用如下方法进行生成token.</p><pre class="line-numbers language-none"><code class="language-none">// 定义一个jwt对象type JWT struct {// 声明签名信息SigningKey []byte}// 初始化jwt对象func NewJWT() *JWT {return &amp;JWT{[]byte("bgbiao.top"),}}// 自定义有效载荷(这里采用自定义的Name和Email作为有效载荷的一部分)type CustomClaims struct {Name  string `json:"name"`Email string `json:"email"`// StandardClaims结构体实现了Claims接口(Valid()函数)jwt.StandardClaims}// 调用jwt-go库生成token// 指定编码的算法为jwt.SigningMethodHS256func (j *JWT) CreateToken(claims CustomClaims) (string, error) {// https://gowalker.org/github.com/dgrijalva/jwt-go#Token// 返回一个token的结构体指针token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)return token.SignedString(j.SigningKey)}// token解码func (j *JWT) ParserToken(tokenString string) (*CustomClaims, error) {// https://gowalker.org/github.com/dgrijalva/jwt-go#ParseWithClaims// 输入用户自定义的Claims结构体对象,token,以及自定义函数来解析token字符串为jwt的Token结构体指针// Keyfunc是匿名函数类型: type Keyfunc func(*Token) (interface{}, error)// func ParseWithClaims(tokenString string, claims Claims, keyFunc Keyfunc) (*Token, error) {}token, err := jwt.ParseWithClaims(tokenString, &amp;CustomClaims{}, func(token *jwt.Token) (interface{}, error) {return j.SigningKey, nil})if err != nil {// https://gowalker.org/github.com/dgrijalva/jwt-go#ValidationError// jwt.ValidationError 是一个无效token的错误结构if ve, ok := err.(*jwt.ValidationError); ok {// ValidationErrorMalformed是一个uint常量，表示token不可用if ve.Errors&amp;jwt.ValidationErrorMalformed != 0 {return nil, fmt.Errorf("token不可用")// ValidationErrorExpired表示Token过期} else if ve.Errors&amp;jwt.ValidationErrorExpired != 0 {return nil, fmt.Errorf("token过期")// ValidationErrorNotValidYet表示无效token} else if ve.Errors&amp;jwt.ValidationErrorNotValidYet != 0 {return nil, fmt.Errorf("无效的token")} else {return nil, fmt.Errorf("token不可用")}}}// 将token中的claims信息解析出来并断言成用户自定义的有效载荷结构if claims, ok := token.Claims.(*CustomClaims); ok &amp;&amp; token.Valid {return claims, nil}return nil, fmt.Errorf("token无效")}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="定义登陆验证逻辑"><a href="#定义登陆验证逻辑" class="headerlink" title="定义登陆验证逻辑"></a>定义登陆验证逻辑</h4><p>接下来的部分就是普通api的具体逻辑了，比如可以在登陆时进行用户校验，成功后未该次认证请求生成token。</p><pre class="line-numbers language-none"><code class="language-none">// 定义登陆逻辑// model.LoginReq中定义了登陆的请求体(name,passwd)func Login(c *gin.Context) {var loginReq model.LoginReqif c.BindJSON(&amp;loginReq) == nil {// 登陆逻辑校验(查库，验证用户是否存在以及登陆信息是否正确)isPass, user, err := model.LoginCheck(loginReq)// 验证通过后为该次请求生成tokenif isPass {generateToken(c, user)} else {c.JSON(http.StatusOK, gin.H{"status": -1,"msg":    "验证失败" + err.Error(),"data":   nil,})}} else {c.JSON(http.StatusOK, gin.H{"status": -1,"msg":    "用户数据解析失败","data":   nil,})}}// token生成器// md 为上面定义好的middleware中间件func generateToken(c *gin.Context, user model.User) {// 构造SignKey: 签名和解签名需要使用一个值j := md.NewJWT()// 构造用户claims信息(负荷)claims := md.CustomClaims{user.Name,user.Email,jwtgo.StandardClaims{NotBefore: int64(time.Now().Unix() - 1000), // 签名生效时间ExpiresAt: int64(time.Now().Unix() + 3600), // 签名过期时间Issuer:    "bgbiao.top",                    // 签名颁发者},}// 根据claims生成token对象token, err := j.CreateToken(claims)if err != nil {c.JSON(http.StatusOK, gin.H{"status": -1,"msg":    err.Error(),"data":   nil,})}log.Println(token)// 封装一个响应数据,返回用户名和tokendata := LoginResult{Name:  user.Name,Token: token,}c.JSON(http.StatusOK, gin.H{"status": 0,"msg":    "登陆成功","data":   data,})return}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="定义普通待验证接口"><a href="#定义普通待验证接口" class="headerlink" title="定义普通待验证接口"></a>定义普通待验证接口</h4><pre class="line-numbers language-none"><code class="language-none">// 定义一个普通controller函数，作为一个验证接口逻辑func GetDataByTime(c *gin.Context) {// 上面我们在JWTAuth()中间中将'claims'写入到gin.Context的指针对象中，因此在这里可以将之解析出来claims := c.MustGet("claims").(*md.CustomClaims)if claims != nil {c.JSON(http.StatusOK, gin.H{"status": 0,"msg":    "token有效","data":   claims,})}}// 在主函数中定义路由规则router := gin.Default()v1 := router.Group("/apis/v1/"){v1.POST("/register", controller.RegisterUser)v1.POST("/login", controller.Login)}// secure v1sv1 := router.Group("/apis/v1/auth/")// 加载自定义的JWTAuth()中间件,在整个sv1的路由组中都生效sv1.Use(md.JWTAuth()){sv1.GET("/time", controller.GetDataByTime)}router.Run(":8081")复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="验证使用JWT后的接口"><a href="#验证使用JWT后的接口" class="headerlink" title="验证使用JWT后的接口"></a>验证使用JWT后的接口</h4><pre class="line-numbers language-none"><code class="language-none"># 运行项目$ go run main.go127.0.0.113306root:bgbiao.top@tcp(127.0.0.1:13306)/test_api?charset=utf8mb4&amp;parseTime=True&amp;loc=Local[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production. - using env:export GIN_MODE=release - using code:gin.SetMode(gin.ReleaseMode)[GIN-debug] POST   /apis/v1/register         --&gt; warnning-trigger/controller.RegisterUser (3 handlers)[GIN-debug] POST   /apis/v1/login            --&gt; warnning-trigger/controller.Login (3 handlers)[GIN-debug] GET    /apis/v1/auth/time        --&gt; warnning-trigger/controller.GetDataByTime (4 handlers)[GIN-debug] Listening and serving HTTP on :8081# 注册用户$ curl -i -X POST \   -H "Content-Type:application/json" \   -d \'{  "name": "hahaha1",  "password": "hahaha1",  "email": "hahaha1@bgbiao.top",  "phone": 10000000000}' \ 'http://localhost:8081/apis/v1/register'HTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Date: Sun, 15 Mar 2020 07:09:28 GMTContent-Length: 41{"data":null,"msg":"success ","status":0}%# 登陆用户以获取token$ curl -i -X POST \   -H "Content-Type:application/json" \   -d \'{  "name":"hahaha1",  "password":"hahaha1"}' \ 'http://localhost:8081/apis/v1/login'HTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Date: Sun, 15 Mar 2020 07:10:41 GMTContent-Length: 290{"data":{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyTmFtZSI6ImhhaGFoYTEiLCJlbWFpbCI6ImhhaGFoYTFAYmdiaWFvLnRvcCIsImV4cCI6MTU4NDI1OTg0MSwiaXNzIjoiYmdiaWFvLnRvcCIsIm5iZiI6MTU4NDI1NTI0MX0.HNXSKISZTqzjKd705BOSARmgI8FGGe4Sv-Ma3_iK1Xw","name":"hahaha1"},"msg":"登陆成功","status":0}# 访问需要认证的接口# 因为我们对/apis/v1/auth/的分组路由中加载了jwt的middleware，因此该分组下的api都需要使用jwt-token认证$ curl http://localhost:8081/apis/v1/auth/time{"data":null,"msg":"请求未携带token，无权限访问","status":-1}%# 使用token认证$ curl http://localhost:8081/apis/v1/auth/time -H 'token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyTmFtZSI6ImhhaGFoYTEiLCJlbWFpbCI6ImhhaGFoYTFAYmdiaWFvLnRvcCIsImV4cCI6MTU4NDI1OTg0MSwiaXNzIjoiYmdiaWFvLnRvcCIsIm5iZiI6MTU4NDI1NTI0MX0.HNXSKISZTqzjKd705BOSARmgI8FGGe4Sv-Ma3_iK1Xw'{"data":{"userName":"hahaha1","email":"hahaha1@bgbiao.top","exp":1584259841,"iss":"bgbiao.top","nbf":1584255241},"msg":"token有效","status":0}%复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://link.juejin.cn/?target=https://github.com/BGBiao/gin-jwt-token">gin-jwt-go源码</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> JWT </tag>
            
            <tag> Golang </tag>
            
            <tag> Gin框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热情假设</title>
      <link href="/zhb233go.github.io/2021/12/07/21-re-qing-jia-she/"/>
      <url>/zhb233go.github.io/2021/12/07/21-re-qing-jia-she/</url>
      
        <content type="html"><![CDATA[<h1 id="热情假设"><a href="#热情假设" class="headerlink" title="热情假设"></a>热情假设</h1><p>2005年，斯坦福大学邀请乔布斯在毕业典礼演讲。这个演讲后来成为经典，《乔布斯传》说”或许有些演讲对后世影响更大，但是你找不到（比这篇）更好的演讲。”</p><p>演讲中，乔布斯说了一段有名的话。</p><blockquote><p>“你们的时间有限，所以不要把它浪费在过其他人的生活。最重要的是，你要有勇气跟随你的内心和直觉。某种程度上，它们已经知道你真正想要成为什么样子。其他所有事情都是次要的。”</p></blockquote><p>这段话后来被称为”热情假设”，很多人都引用它鼓励年轻人：寻找职业方向的时候，要跟随内心的热情（passion），去做那些你有强烈意愿从事的工作。</p><p>但是，美国最近出版了一本新书《优秀到无法忽略》（<a href="https://commoncog.com/blog/so-good-they-cant-ignore-you/">《So Good They Can’t Ignore You》</a>），声称乔布斯的这个建议是完全错误的，误导年轻人。别的不说，乔布斯本人也不遵守”热情假设”。年轻时，他对禅宗思想最感兴趣，去印度学习佛教。如果他真的追随自己的内心，他就应该去当一个禅宗老师，而不是跑回美国创办苹果公司。</p><p>这本书认为，以下几个原因导致”热情假设”不是一个好的建议。</p><ul><li><p>第一，热情真的很罕见。大部分人都对自己的工作没兴趣，而是对某种爱好（比如打球、钓鱼）有兴趣。如果大部分人都找不到自己的职业热情，你怎么能叫他们去追随热情呢？</p></li><li><p>第二，热情需要时间来建立。许多人刚开始工作的时候，对自己的职业并没有兴趣，随着时间积累，他们的经验越来越多，能够掌控的东西越来越多，这才慢慢开始热爱自己的工作。找工作阶段，你可能根本不会意识到这个职业就是你的热情所在。</p></li><li><p>第三，过度强调热情，容易对现状产生不满。2010年的一项调查发现，只有45％的美国人对自己的工作满意。由于很多人相信，无法产生热情的工作不是好工作，导致对职业生涯抱有不切实际的期望，对现有的工作不满意，不断跳槽。</p></li></ul><p>这本书提出，热情不是凭空产生的，它跟自主权有关。如果你在某个职位上的自主权越大，能够掌控的东西越多，就越容易对当前的职业产生热情。<strong>与其强调跟随内心的热情，不如强调如何在某种职业里面获得自主权。你必须使自己变得优秀，让别人无法忽视你，同意让你掌控更多的资源</strong> ，这就是书名的含义。</p><p>——引自阮一峰的网络日志27期</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《黑天鹅》读后感</title>
      <link href="/zhb233go.github.io/2021/12/06/20-hei-tian-e-du-hou-gan/"/>
      <url>/zhb233go.github.io/2021/12/06/20-hei-tian-e-du-hou-gan/</url>
      
        <content type="html"><![CDATA[<h1 id="《黑天鹅》读后感"><a href="#《黑天鹅》读后感" class="headerlink" title="《黑天鹅》读后感"></a><strong>《黑天鹅》读后感</strong></h1><p>上周终于将《黑天鹅》看完了，利用在地铁上的闲暇时间看的，我知道读书需要一个安静的环境，所以我不知道我有没有看漏一些地方，以下是我读完后的一点浅显的理解：</p><ol><li>黑天鹅事件是不可预测的，对于人们财富的影响是巨大的；</li><li>黑天鹅事件对于财富越大的人越具有影响力，对于贫困的人影响不大；</li><li>黑天鹅事件的影响具有两面性</li><li>黑天鹅事件是可减弱的但不可消除。</li></ol><h3 id="广义解释："><a href="#广义解释：" class="headerlink" title="广义解释："></a>广义解释：</h3><p>黑天鹅事件（英文：”Black swan” incidents)指非常难以预测，且不寻常的事件，通常会引起市场连锁负面反应甚至颠覆。</p><p>一般来说，“黑天鹅”事件是指满足以下三个特点的事件：它具有意外性；它产生重大影响；虽然它具有意外性，但人的本性促使我们在事后为它的发生编造理由，并且或多或少认为它是可解释和可预测的。</p><p>黑天鹅存在于各个领域，无论金融市场、商业、经济还是个人生活，都逃不过它的控制。“<a href="https://baike.baidu.com/item/%E7%81%B0%E7%8A%80%E7%89%9B/22030944">灰犀牛</a></p><p>”是与“黑天鹅”相互补足的概念，“<a href="https://baike.baidu.com/item/%E7%81%B0%E7%8A%80%E7%89%9B%E4%BA%8B%E4%BB%B6/22044335">灰犀牛事件</a>”是太过于常见以至于人们习以为常的风险，“黑天鹅事件”则是极其罕见的、出乎人们意料的风险。</p><h3 id="“黑天鹅”的逻辑是："><a href="#“黑天鹅”的逻辑是：" class="headerlink" title="“黑天鹅”的逻辑是："></a>“黑天鹅”的逻辑是：</h3><p><a href="https://baike.baidu.com/item/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B">你不知道的事</a>比你知道的事更有意义。在人类社会发展的进程中，对我们的历史和社会产生重大影响的，通常都不是我们已知或可以预见的东西。</p><h3 id="对我自己现阶段的解读："><a href="#对我自己现阶段的解读：" class="headerlink" title="对我自己现阶段的解读："></a>对我自己现阶段的解读：</h3><p>就像是这去年刚出的疫情一样，对于我这样的普通人，给我的影响就是出门不方便，人们交流减少，娱乐方式减少。对于个人的财富没有多少影响。但对于一些工厂来说影响确实巨大的，实体产业遭受打击。另一方面线上产业确越发蓬勃。给我的启发就是：看待一个事物时，更应该关注它背后的运行机制，因为在表面上出现的仅仅的它的结果，要从过程去分析结果；它也提醒我需要加强自身的风险意识，去预防不可预测的风险。</p><p>一本好书是值得反复阅读的，之后一定会再阅读一遍，相信会有更多的理解。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
            <tag> 好书推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/zhb233go.github.io/2021/12/06/0-hello-world/"/>
      <url>/zhb233go.github.io/2021/12/06/0-hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go使用S3搭建Lambda无状态服务</title>
      <link href="/zhb233go.github.io/2021/12/04/go-shi-yong-s3-da-jian-lambda-wu-zhuang-tai-fu-wu/"/>
      <url>/zhb233go.github.io/2021/12/04/go-shi-yong-s3-da-jian-lambda-wu-zhuang-tai-fu-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="golang使用S3搭建Lambda无状态服务"><a href="#golang使用S3搭建Lambda无状态服务" class="headerlink" title="golang使用S3搭建Lambda无状态服务"></a>golang使用S3搭建Lambda无状态服务</h1><p>由于项目需求我需要使用aws的Lambda服务来自动处理存入图片的缩略图的生成和存入功能。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul><li>根据尺寸需求生成对应的缩略图</li><li>自动保存入S3对应位置</li><li>将位置信息告诉后端存入数据库</li><li>日志记录报错和运行信息</li></ul><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><h4 id="1-一个aws账号"><a href="#1-一个aws账号" class="headerlink" title="1.一个aws账号"></a>1.一个aws账号</h4><h4 id="2-编辑好需求的程序-需要在本地测试好，确定没问题再转化成Lambda格式，虽然在aws控制台可以测试，但需要打包，很麻烦，先做测试，减少上线步骤。"><a href="#2-编辑好需求的程序-需要在本地测试好，确定没问题再转化成Lambda格式，虽然在aws控制台可以测试，但需要打包，很麻烦，先做测试，减少上线步骤。" class="headerlink" title="2.编辑好需求的程序,需要在本地测试好，确定没问题再转化成Lambda格式，虽然在aws控制台可以测试，但需要打包，很麻烦，先做测试，减少上线步骤。"></a>2.编辑好需求的程序,需要在本地测试好，确定没问题再转化成Lambda格式，虽然在aws控制台可以测试，但需要打包，很麻烦，先做测试，减少上线步骤。</h4><p>官方的例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>        <span class="token string">"fmt"</span>        <span class="token string">"context"</span>        <span class="token string">"github.com/aws/aws-lambda-go/lambda"</span><span class="token punctuation">)</span><span class="token keyword">type</span> MyEvent <span class="token keyword">struct</span> <span class="token punctuation">{</span>        Name <span class="token builtin">string</span> <span class="token string">`json:"name"`</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">HandleRequest</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> name MyEvent<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"Hello %s!"</span><span class="token punctuation">,</span> name<span class="token punctuation">.</span>Name <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lambda<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span>HandleRequest<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面列出了有效的处理程序签名。TIn 和 TOut 表示类型与 encoding/json 标准库兼容。有关更多信息，请参阅 func Unmarshal，以了解如何反序列化这些类型。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span><span class="token keyword">func</span> <span class="token punctuation">(</span>TIn<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>TOut<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token builtin">error</span><span class="token keyword">func</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> TIn<span class="token punctuation">)</span> <span class="token builtin">error</span><span class="token keyword">func</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">(</span>TOut<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> TIn<span class="token punctuation">)</span> <span class="token punctuation">(</span>TOut<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-部署-zip文件存档"><a href="#3-部署-zip文件存档" class="headerlink" title="3.部署.zip文件存档"></a>3.部署.zip文件存档</h4><h5 id="在-macOS-和-Linux-上创建-zip-文件"><a href="#在-macOS-和-Linux-上创建-zip-文件" class="headerlink" title="在 macOS 和 Linux 上创建 .zip 文件"></a>在 macOS 和 Linux 上创建 .zip 文件</h5><p>编译您的可执行文件。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">GOOS<span class="token operator">=</span>linux <span class="token keyword">go</span> build main<span class="token punctuation">.</span><span class="token keyword">go</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 GOOS 设置为 linux 可确保编译的可执行文件与 Go 运行时兼容（即使您在非 Linux 环境中编译它也是如此）。</p><p>（可选）如果您的 main 程序包包含多个文件，请使用以下 go build 命令来编译此程序包：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">GOOS<span class="token operator">=</span>linux <span class="token keyword">go</span> build main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（可选）您可能需要使用 Linux 上的 CGO_ENABLED=0 编译程序包：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">GOOS<span class="token operator">=</span>linux CGO_ENABLED<span class="token operator">=</span><span class="token number">0</span> <span class="token keyword">go</span> build main<span class="token punctuation">.</span><span class="token keyword">go</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此命令为标准 C 库 (libc) 版本创建稳定的二进制程序包，这在 Lambda 和其他设备上可能有所不同。</p><p>Lambda 使用 POSIX 文件权限，因此在创建 .zip 文件存档之前，您可能需要为部署程序包文件夹设置权限。</p><p>通过将可执行文件打包为 .zip 文件来创建部署程序包。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">zip function<span class="token punctuation">.</span>zip main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里有个坑需要踩一下：<br>main包下，最好是将全部程序放在main.go里面，防止在编译时报错，这样打好zip包后到控制台测试运行，一定要做测试，这样才能确保你的程序能够成功运行，最好是查看图片与需求结果是否相同。</p><p>…补充…</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> AWS </tag>
            
            <tag> S3 </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON Web Token 入门教程</title>
      <link href="/zhb233go.github.io/2021/12/03/19-json-web-token-ru-men-jiao-cheng/"/>
      <url>/zhb233go.github.io/2021/12/03/19-json-web-token-ru-men-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p>JSON Web Token 入门教程<br>作者： 阮一峰</p><p>日期： 2018年7月23日</p><p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案，本文介绍它的原理和用法。</p><p>一、跨域认证的问题<br>互联网服务离不开用户认证。一般流程是下面这样。</p><p>1、用户向服务器发送用户名和密码。</p><p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p><p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p><p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p><p>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><p>二、JWT 的原理<br>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><pre class="line-numbers language-none"><code class="language-none">{  "姓名": "张三",  "角色": "管理员",  "到期时间": "2018年7月1日0点0分"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><p>三、JWT 的数据结构<br>实际的 JWT 大概就像下面这样。</p><p>它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分依次如下。</p><p>Header（头部）<br>Payload（负载）<br>Signature（签名）<br>写成一行，就是下面的样子。</p><pre class="line-numbers language-none"><code class="language-none">Header.Payload.Signature<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面依次介绍这三个部分。</p><p>3.1 Header<br>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p><pre class="line-numbers language-none"><code class="language-none">{  "alg": "HS256",  "typ": "JWT"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。</p><p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p><p>3.2 Payload<br>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p><p>iss (issuer)：签发人<br>exp (expiration time)：过期时间<br>sub (subject)：主题<br>aud (audience)：受众<br>nbf (Not Before)：生效时间<br>iat (Issued At)：签发时间<br>jti (JWT ID)：编号<br>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><pre class="line-numbers language-none"><code class="language-none">{  "sub": "1234567890",  "name": "John Doe",  "admin": true}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><p>3.3 Signature<br>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><pre class="line-numbers language-none"><code class="language-none">HMACSHA256(  base64UrlEncode(header) + "." +  base64UrlEncode(payload),  secret)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p><p>3.4 Base64URL<br>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。</p><p>四、JWT 的使用方式<br>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。</p><p><code>Authorization: Bearer &lt;token&gt;</code></p><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><p>五、JWT 的几个特点<br>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p><p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p><p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p><p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p><p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p><p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p><p>六、参考链接<br><a href="https://jwt.io/introduction/">Introduction to JSON Web Tokens</a>，by Auth0<br><a href="https://medium.com/@bryanmanuele/sessionless-authentication-withe-jwts-with-node-express-passport-js-69b059e4b22c">Sessionless Authentication using JWTs (with Node + Express + Passport JS)</a>, by Bryan Manuele<br><a href="https://github.com/dwyl/learn-json-web-tokens/blob/master/README.md">Learn how to use JSON Web Tokens</a>, by dwyl</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是微服务架构？</title>
      <link href="/zhb233go.github.io/2021/12/03/18-shi-me-shi-wei-fu-wu-jia-gou/"/>
      <url>/zhb233go.github.io/2021/12/03/18-shi-me-shi-wei-fu-wu-jia-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>什么是软件架构？<br>软件架构的重要性<br>什么是微服务架构？<br>微服务架构的优缺点<br>其他突出的软件架构模式<br>构建微服务架构的最佳实践<br>计划构建微服务架构？</p><h2 id="什么是软件架构？"><a href="#什么是软件架构？" class="headerlink" title="什么是软件架构？"></a>什么是软件架构？</h2><p><img src="https://www.devteam.space/wp-content/uploads/2019/01/What-is-software-architecture.jpg"><br>软件架构模式的模式</p><p>软件架构本质上是任何给定软件系统的结构。它用于提供整个系统的图形表示，有助于开发人员。</p><p>通常有多个组件，每个组件都解决一个或多个功能。</p><p>上面的软件架构图示例显示了这些组件如何相互交互。在“软件架构”中阅读更多相关信息。请记住，上图只是一个基本示例。</p><p>我们称之为软件架构的示意图只是一种视觉表示。每个系统图都显示了软件架构师决定的一系列设计原则，以确保最佳的整体系统功能。做出架构决策是为了确保最佳的安全性、性能、可管理性等。</p><p>这些设计原则、架构决策和示意图都是软件架构的组成部分。它们共同使系统能够满足其业务、运营和技术目标。在此 Techopedia 软件架构定义中阅读更多内容。</p><h2 id="软件架构的重要性"><a href="#软件架构的重要性" class="headerlink" title="软件架构的重要性"></a>软件架构的重要性</h2><p>软件架构对于产品的成功极其重要。有几个原因。</p><h3 id="第一组决定"><a href="#第一组决定" class="headerlink" title="第一组决定"></a>第一组决定</h3><p>在“软件开发生命周期”（SDLC）期间，开发团队在软件架构的创建过程中做出与系统相关的关键决策。在此过程之前，将仅概述业务需求。</p><p>如您所知，确保第一组决策正确无误，将使您的项目处于最佳状态以顺利运行。另一方面，如果这些决定不正确，您的项目几乎肯定会遇到严重的问题。在“良好软件架构的重要性”中阅读更多相关信息。</p><h3 id="视觉呈现的交流工具"><a href="#视觉呈现的交流工具" class="headerlink" title="视觉呈现的交流工具"></a>视觉呈现的交流工具</h3><p>软件架构是一种工具，通过提供示意性表示来帮助沟通，这些表示显示与改进核心功能相关的底层决策。做对了，您的所有项目利益相关者以及您的开发团队将准确了解您的产品将如何运作。</p><h3 id="可重用性"><a href="#可重用性" class="headerlink" title="可重用性"></a>可重用性</h3><p>软件架构有助于持续开发，特别是对于未来的项目。由于您已经制定和实施了一次架构决策，并拥有示意图，因此可以在未来的项目中重复使用或扩展这些决策。</p><p>这意味着您可以为新产品重用大部分核心结构，因为只有开发工具、编程语言等会有所不同。没有良好的软件架构，项目或产品可能会失败。在此 Quora 问答主题中阅读更多相关信息。</p><h2 id="什么是微服务架构？"><a href="#什么是微服务架构？" class="headerlink" title="什么是微服务架构？"></a>什么是微服务架构？</h2><p><img src="https://www.devteam.space/wp-content/uploads/2019/01/What-is-the-microservices-architecture.jpg"><br>单体架构和微服务架构差异的示意图</p><p>微服务架构模式帮助开发人员创建多个较小的程序，而不是一个大程序。一个大程序通常很难维护，此外，添加新功能也很困难。使用微服务架构，程序员为每个功能创建一个小程序。添加新功能只需要创建另一个小程序。</p><p>视频点播平台 Netflix 是这种架构模式的一个很好的例子。正如您所料，Netflix“用户界面”(UI) 中的每个部分都是不同的服务。实际上，UI 就像是不同网站的集合，尽管它看起来只是一个。阅读“微服务架构（示例和图表） ”了解更多详情。</p><h2 id="微服务架构的优缺点"><a href="#微服务架构的优缺点" class="headerlink" title="微服务架构的优缺点"></a>微服务架构的优缺点</h2><h4 id="这种模式有很多优点："><a href="#这种模式有很多优点：" class="headerlink" title="这种模式有很多优点："></a>这种模式有很多优点：</h4><p>当企业提供彼此明显分离的功能时，这种架构模式可以使他们的应用程序具有高度可扩展性。<br>个别服务可能有不同的需求概况，因此，企业将为这些个别服务实施扩展策略。这有助于优化和确定资源的优先级。<br>如果您使用这种架构模式，您会发现阅读和理解您的代码库会容易得多。<br>维护应用程序更容易。<br>单个微服务可以单独部署。您只部署已更改的微服务，而不是整个应用程序。这减少了在部署过程中花费的时间和精力。<br>您发现调试应用程序更容易，因为您无需查看大型应用程序的多个层。<br>微服务架构模式可以更轻松地隔离故障。<br>如果您使用微服务架构模式，您可以构建更具弹性的服务，这会提高您的应用程序的容错能力。<br>如果您使用微服务架构，则可以提高可重用性。在此模式中，您可以围绕业务功能构建和组织微服务。当与其他业务功能存在共性时，您可以以最少的更改重用您之前开发的微服务。这种重用有助于降低您的开发成本。<br>在“什么是微服务？”。</p><h4 id="也有缺点："><a href="#也有缺点：" class="headerlink" title="也有缺点："></a>也有缺点：</h4><p>如果我们不能清楚地将服务彼此分开，这种模式会增加复杂性。<br>如果多个服务使用相同的任务，则此模式会对性能产生不利影响。<br>如果由于网站不同部分的页面速度不同，微服务过多，用户可能会发现 UI 混乱。如果您使用太多不同的编程语言来开发不同的微服务，那么您的应用程序将更加难以维护。<br>如果您使用微服务架构，集成测试可能会很困难。如果您的组件位于其他系统/环境中，那么您会发现很难设置端到端的集成测试环境。<br>您需要仔细定义微服务与其他服务交互的接口。如果您有太多由不同团队开发的微服务，那么定义此类接口可能会很困难。不同的微服务将相互依赖输入。不同的开发团队需要清楚地了解其他微服务可能使用的接口，因此，沟通是关键。<br>微服务架构实现的一个突出例子<br>想看看微服务架构在起作用吗？好吧，Netflix 就是您的最佳选择！这家流行的流媒体服务提供商充分利用了这种架构模式。</p><p>Netflix 仍在经历高速增长，然而，该公司最初难以跟上它的步伐。它有一个单体架构，它的数据中心与此保持一致。Netflix 无法以足够快的速度建立足够数量的数据中心来跟上其令人印象深刻的增长。</p><p>同年，一个模块代码中缺少一个分号导致 Netflix 网站瘫痪。该网站关闭了几个小时，需要一个大型工程团队的共同努力才能恢复。当 Netflix 不得不进行故障排除时，它总是不得不聘请一个由多个领域组成的大型工程团队。嗯，这就是使用单体架构的巨大应用程序的缺点！</p><p>Netflix 于 2009 年开始转向 AWS 云微服务架构，当时微服务架构模式并不流行，甚至连“微服务”这个词都没有使用。</p><p>该公司于 2009 年首次迁移了一款非面向客户的应用程序，并且进展顺利。随后，Netflix 将其网站的几个面向客户的功能转移到了 AWS 云微服务架构中。到 2011 年 12 月，Netflix 完成了搬迁。</p><p>就本月的情况而言，Netflix 微服务架构中的 API 网关每天处理 20 亿次 API 调用！您可以阅读“为什么不提及 Netflix 就不能谈论微服务”以了解有关此转变的更多信息。</p><p>其他突出的软件架构模式<br>当我们回顾其他软件架构模式的特征时，微服务架构的重要性变得更加清晰。</p><p>微服务架构还有其他四种关键模式：</p><h4 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h4><p>这是最常见的软件架构模式。大多数业务应用程序将信息存储在数据库表中。这种模式在层中有代码。最顶层接受数据。然后数据导航到最底部的层，即数据库。</p><p>大多数关键框架（如 Java EE）都使用这种模式。分层架构提供了一些优势，例如，应用程序易于维护，测试更容易。在“大型企业 Java 项目架构”中阅读更多相关信息。</p><p>缺点是代码量大且无组织，其中大部分只在层之间传递数据，不执行任何业务逻辑。这会影响产品的性能。</p><h4 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h4><p>许多用例涉及仅在有数据要处理时才执行的程序。在事件驱动架构的情况下，中央单元接收所有数据输入。特定的数据输入是事件。然后中央单元委托适当的组件处理特定类型的数据。</p><p>并非所有模块都处理所有数据。这使得应用程序具有可扩展性，此外，开发人员可以轻松扩展系统以应对新事件。在“前 5 种软件架构模式：如何做出正确选择”中阅读更多相关信息。</p><p>有一些缺点。当模块相互影响时，测试变得更加困难。如果多个模块处理同一个事件，它会使错误处理复杂化。由于消息传递开销，系统可能会变慢。</p><h4 id="微内核架构"><a href="#微内核架构" class="headerlink" title="微内核架构"></a>微内核架构</h4><p>常用工具有一组用户重复执行的任务。著名的“集成开发环境”(IDE) Eclipse 就是一个这样的例子，它具有可重复的任务，如打开文件、编辑文件等。</p><p>微内核架构使用微内核来包含这些基本功能。我们可以将其上的所有其他内容视为“插件”。这种模式非常适合流行的工具，因为它可以提高性能。但是，很难定义常见的任务。在“软件架构：您需要了解的 5 种模式”中阅读更多相关信息。</p><h4 id="天基建筑"><a href="#天基建筑" class="headerlink" title="天基建筑"></a>天基建筑</h4><p>基于空间的架构的目标 是在高负载时为 Web 应用程序提供健壮性和稳定性。大多数网站都是围绕数据库构建的，因此，它们依赖于数据库来处理负载。</p><p>使用基于空间的架构，软件架构师将处理和存储拆分到多个服务器中。数据和服务调用分布在节点之间。这有助于避免数据库在高负载情况下崩溃。请注意，测试整个系统可能很困难，因为模拟负载条件可能很棘手。</p><h3 id="构建微服务架构的最佳实践"><a href="#构建微服务架构的最佳实践" class="headerlink" title="构建微服务架构的最佳实践"></a>构建微服务架构的最佳实践</h3><p>微服务架构实现的最佳实践<br>寻找最佳微服务架构<br>概述您的微服务<br>领域驱动设计<br>让每个人都加入<br>使用 RESTful API<br>为特定的微服务建立团队<br>设置服务器和数据存储环境<br>文档 API<br>使用最好的 DevOps 工具包<br>监控是关键</p><h4 id="最佳实践-1：确定微服务架构是否符合您的要求"><a href="#最佳实践-1：确定微服务架构是否符合您的要求" class="headerlink" title="最佳实践 #1：确定微服务架构是否符合您的要求"></a>最佳实践 #1：确定微服务架构是否符合您的要求</h4><p>Amazon、Twitter、eBay 和 PayPal 是成功实施微服务架构设计的组织的例子。这是一种流行的模式，然而，这并不意味着它对你有用。</p><p>如果您不能将您的 Web 应用程序分解为提供价值的功能，那么微服务架构对您来说就没有意义了。阅读“模式：按业务能力分解”以获得更多见解。</p><h4 id="最佳实践-2：定义您的微服务"><a href="#最佳实践-2：定义您的微服务" class="headerlink" title="最佳实践#2：定义您的微服务"></a>最佳实践#2：定义您的微服务</h4><p>您需要明确区分业务功能、服务和微服务。如果没有这个，您可能会构建过大的微服务。这是一种不完整的形式，您将看不到使用微服务方法的任何好处。</p><p>另一方面是创建过多微服务的可能性。这将导致您的架构过度碎片化。请记住，要管理微服务架构，您需要一个成熟的运营团队。在“微服务权衡”中了解它。</p><p>如果微服务太多，运营管理成本会很高。您将看到运营成本的激增掩盖了您从微服务中获得的收益。</p><h4 id="最佳实践-3：使用“领域驱动设计”（DDD）来设计微服务"><a href="#最佳实践-3：使用“领域驱动设计”（DDD）来设计微服务" class="headerlink" title="最佳实践#3：使用“领域驱动设计”（DDD）来设计微服务"></a>最佳实践#3：使用“领域驱动设计”（DDD）来设计微服务</h4><p>虽然这一步与定义微服务的练习密切相关，但它更进了一步。在这里，您可以围绕您的业务领域设计微服务。让我们再次回顾 Netflix 示例。他们从不同的服务器运行他们的内容交付和不同的跟踪服务。</p><p>“领域驱动设计”(DDD) 是一种设计原则，它使用实用的规则和思想来表达面向对象的模型。它帮助软件架构师了解不同的业务领域，因此，他们可以专注于构建业务可以很好理解的微服务架构。在“ DDD 101 — 5 分钟之旅”中阅读更多相关信息。</p><h4 id="最佳实践-4：尽早获得组织领导和团队的支持"><a href="#最佳实践-4：尽早获得组织领导和团队的支持" class="headerlink" title="最佳实践#4：尽早获得组织领导和团队的支持"></a>最佳实践#4：尽早获得组织领导和团队的支持</h4><p>实现微服务架构设计不仅仅是一个技术决策。这种转型代价高昂，而且影响不仅限于内部开发团队。从单体架构过渡是一个漫长的项目。组织中的高级管理人员必须为此投入资金。</p><p>对您的开发团队的影响将是巨大的。到目前为止，您的团队一直在使用端到端测试过程来测试整个系统，以防出现增强。您现在需要围绕微服务对系统进行模块化。这需要文化转型。</p><p>转型将有助于您的业务敏捷性，因为它将促进持续交付。但是，团队必须完全接受转型。阅读我们的指南“敏捷帮助变革管理的 5 种方式”，了解如何有效地帮助这种转变。</p><h4 id="最佳实践-5：最佳地使用-RESTful-API"><a href="#最佳实践-5：最佳地使用-RESTful-API" class="headerlink" title="最佳实践 #5：最佳地使用 RESTful API"></a>最佳实践 #5：最佳地使用 RESTful API</h4><p>如果您优化使用 RESTful API，微服务架构模式可以提供重要的价值。RESTful API 提供了许多优点，例如，您不需要在客户端安装任何东西。您不需要 SDK 或框架，因为使用 API 服务的 HTTP 请求就足够了。在此 Quora 问答主题中阅读有关 RESTful API 优势的更多信息。</p><p>RESTful API 领域的专家 Leonard Richardson 提出了 REST API 使用的成熟度模型。为了从您的微服务架构中实现最佳价值，您应该尝试达到此成熟度模型的最高水平。阅读“微服务架构的 10 个最佳实践”以获得更多见解。</p><h4 id="最佳实践-6：围绕微服务组织团队"><a href="#最佳实践-6：围绕微服务组织团队" class="headerlink" title="最佳实践 #6：围绕微服务组织团队"></a>最佳实践 #6：围绕微服务组织团队</h4><p>您需要建立不同的团队来处理不同的微服务。这些团队应该被赋予足够的权力来处理他们的微服务。但是，所有团队都应该跨职能并了解整个项目计划。</p><p>每个团队都应该具备构建云原生应用程序的必要技能。每个团队都需要业务分析师、开发人员、测试人员和 DevOps 工程师。每个团队都应该有自己的项目经理 (PM)。我们的指南“如何建立Scrum开发团队？”可以帮助您组织这些团队。</p><h4 id="最佳实践-7：为每个微服务提供单独的数据存储"><a href="#最佳实践-7：为每个微服务提供单独的数据存储" class="headerlink" title="最佳实践 #7：为每个微服务提供单独的数据存储"></a>最佳实践 #7：为每个微服务提供单独的数据存储</h4><p>每个微服务都应该为其数据存储做好准备。每个微服务都应该完全拥有自己的数据。当然，数据可以在微服务之间共享，但是，这应该通过 API 进行。</p><p>如果多个微服务共享同一个数据存储，这会导致服务之间的耦合。这将大大违背微服务架构的目的。在“ Top 5+ 微服务架构和设计最佳实践”中阅读更多相关信息。</p><h4 id="最佳实践-8：基于领域设计-API-并很好地记录它们"><a href="#最佳实践-8：基于领域设计-API-并很好地记录它们" class="headerlink" title="最佳实践 #8：基于领域设计 API 并很好地记录它们"></a>最佳实践 #8：基于领域设计 API 并很好地记录它们</h4><p>充分注意基于业务领域设计 API。很好地记录 API。考虑使用Swagger 之类的工具。我们有一个指南“如何为您的移动应用程序构建 RESTful API？”您可以咨询。</p><h4 id="最佳实践-9：使用好的-DevOps-工具集"><a href="#最佳实践-9：使用好的-DevOps-工具集" class="headerlink" title="最佳实践 #9：使用好的 DevOps 工具集"></a>最佳实践 #9：使用好的 DevOps 工具集</h4><p>到目前为止，您应该已经将微服务设计得足够好，可以独立部署它们。为了从这些微服务中实现最佳价值，您需要自动化构建和部署管理。因此，您将需要一套良好的 DevOps 工具。</p><p>用于部署自动化的 Jenkins 和用于容器化的 Docker 是一个很好的组合。但是，如果您需要更多示例，请阅读“ 2019 年的 10 个最佳 DevOps 工具”。</p><h4 id="最佳实践-10：投资于监控"><a href="#最佳实践-10：投资于监控" class="headerlink" title="最佳实践 #10：投资于监控"></a>最佳实践 #10：投资于监控</h4><p>如果您使用的是单体架构并正在过渡到微服务架构，则必须解决日益增加的复杂性。对性能和动态环境的需求增加需要更高级的监控。</p><p>一个好的监控解决方案应该解决资源分配的持续变化。这样的解决方案应该将从监控中收集的数据存储在中央数据库中。它产生的洞察力应该揭示应用程序的动态特性。</p><p>每个微服务都应该使用监控代理。监控系统应支持根本原因分析。阅读更多关于它在“成功微服务设计的 5 个基础”中的重要性。</p><h3 id="部署微服务架构时的关键考虑因素"><a href="#部署微服务架构时的关键考虑因素" class="headerlink" title="部署微服务架构时的关键考虑因素"></a>部署微服务架构时的关键考虑因素</h3><p>可以看到，部署微服务架构是一个涉及到的项目。在进行此类项目时，请牢记以下注意事项：</p><ol><li><p>管理依赖<br>您需要在微服务架构中以不同于单体应用程序中的方式管理依赖项。微服务架构涉及每个独立运行的服务。但是，一个微服务可能需要访问系统的其他部分。这就是复杂性出现的地方。仔细考虑依赖关系。</p></li><li><p>寻找具有所需知识的建筑师<br>架构师将在实施微服务架构中发挥关键作用。你需要一个称职的建筑师。架构师可能需要使用事件驱动的聚合来实现此架构，这需要适当的后端相关专业知识。</p></li></ol><p>请记住，微服务架构中的微服务是分布式系统。因此，架构师需要具备这方面的良好知识。</p><p>此外，架构师需要实现从多个数据存储中检索数据的查询。在微服务架构中，这将比单体应用更复杂。该项目可能会使用“事件溯源”模式，这会增加复杂性。架构师可能需要在此处使用“通用查询职责分离”(CQRS) 模式。</p><p>在某些情况下，架构师可能需要使用“断路器”模式。这可以帮助多个服务在为请求提供服务时进行协作。一个服务可能会同步调用另一个服务。此其他服务可能会停机，或者，它可能会遇到高延迟。“断路器”模式可防止此类问题影响其他服务。</p><p>负载平衡恰好是架构师需要足够经验的另一个领域。它有助于微服务在管理系统负载的同时保持安全性和可用性。</p><p>开发人员可能会在创建微服务时对要实现的端点数量感到困惑。知识渊博的软件架构师可以在这里发挥很大的作用，因为他/她知道端点的数量取决于服务的类型。</p><ol start="3"><li>使用正确的工具和框架，如“Spring Boot”<br>使用正确的开源工具可以极大地帮助实现微服务架构。幸运的是，您可以利用丰富的开源工具生态系统。</li></ol><p>例如，您可以使用流行的开源框架“Spring Boot”轻松创建微服务。以下是此类工具的更多示例：</p><p>API开发的邮递员；<br>用于消息传递的 Amazon Simple Queue Service (SQS)；<br>用于监控的 Logstash；<br>用于部署的 Kubernetes。<br>GitHub 在这里值得一提，尽管它不是完全开源的。这有助于您进行版本控制和源代码管理。</p><ol start="4"><li>为可扩展性设计微服务<br>在设计微服务时，可扩展性是一个关键因素。无论是创建新服务还是增强现有服务，都需要注意这一点。为此，您需要考虑各种方法和技术。</li></ol><p>一个很好的例子是缓存。请记住遵循正确的教程在微服务架构中实现它。异步消息传递使您能够在构建微服务时提供更好的可扩展性。</p><ol start="5"><li>处理认证和授权<br>处理用户身份验证和授权在微服务和单体应用程序之间差异很大。您需要非常了解这些差异的架构师和开发人员。</li></ol><p>例如，他们需要准确地定义有界上下文。这将帮助他们定义具有大量粒度的用户授权。</p><p>再举一个例子。您的团队将需要使用令牌进行用户身份验证。存在各种类型的令牌，例如“JSON Web 令牌”(JWT)。近年来，这种开放标准的代币越来越受欢迎。您需要了解此类现代标准的架构师和开发人员。</p><ol start="6"><li>恰当地使用服务网格<br>有时您需要实现外部配置，如凭据以及微服务架构模式。您可能需要监控指标以了解应用程序的执行情况。考虑使用服务网格来管理服务之间的通信。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>习惯的养成</title>
      <link href="/zhb233go.github.io/2021/12/02/17-xi-guan-de-yang-cheng/"/>
      <url>/zhb233go.github.io/2021/12/02/17-xi-guan-de-yang-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="习惯的养成"><a href="#习惯的养成" class="headerlink" title="习惯的养成"></a>习惯的养成</h1><p>每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。</p><p>看一本书 → 看一页书<br>写一篇文章 → 写一句话<br>跑10公里 → 穿上跑鞋<br>做100次俯卧撑 → 做1次俯卧撑<br>多吃蔬菜水果 → 吃一个水果<br>编写一个程序 → 编写一个函数 → 编写一行代码<br>这样做的目的是使上手变得超级容易，让你先上手再说。一旦开始做了（这可能是最艰难的一步），你就会开始有动力，可能会继续做下去。</p><p>阅读一页 → 阅读10页 → 读完第一章<br>写一个句子 → 写文章的开头 → 写出正文<br>穿上跑鞋 → 步行5分钟 → 跑步5分钟<br>一旦开始，继续做下去就会容易得多。有时，你甚至会发现，自己在不知不觉间已经完成了任务。</p><p><img src="https://www.wangbase.com/blogimg/asset/202007/bg2020072418.jpg" alt="image"></p><p>一个人应该能够换尿布，策划战争，杀猪，开船，设计房子，写十四行诗，结算账户，砌墙，接脱臼的骨头，安慰濒死的人，服从命令，发布命令，携手合作，独立行动，解数学方程，分析新问题，铲粪，电脑编程，做出可口的饭，善打架，勇敢地死去。只有昆虫才专业化。<br>—— 罗伯特・安森・海因莱因</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二八定律</title>
      <link href="/zhb233go.github.io/2021/11/30/16-er-ba-ding-lu/"/>
      <url>/zhb233go.github.io/2021/11/30/16-er-ba-ding-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="二八定律"><a href="#二八定律" class="headerlink" title="二八定律"></a>二八定律</h1><ul><li>二八定律又叫帕累托定律,是19世纪末20世纪初意大利经济学家<br>帕累托发现的一种奇怪的社会现象。他认为,在任何一组东西中最重要的</li><li>只占其中一小部分,约20%,其余80%尽管是多数却是次要的,因此又称 二八定律,<br>最著名的是”社会上20%的人掌握了80%的财富!”外汇市场二八定律实际就是二<br>八定律在外汇市场上的一些具体表现,是一些看似不可能但又具有真实影响的<br>现象。</li><li>二八定律在社会中的现象极其普遍,它的现实意义:二八法则不仅在<br>经济学管理学领域应用广泛,它对我们自身发展也有重要的现实意义:<br>学会避免将时间和精力花费在琐事上,要学会抓主要矛盾。<br>一个人的精力和时间都是非常有限的要想真正”做好每件事情”几乎是<br>不可能的,要学会合理分配时间和精力。要想面面俱到还不如重点突破。<br>把80%的资源花在能出关键效益的炸的方面,这20%的方面又能带动其余<br>80%的发展。</li><li>二八定律运用在我自身,我认为我每天三分之一的时间用于在工作上,三分<br>之用手休息,还有三分之一也不能白白浪费,在工作中,80%时间用于解决实际<br>20%的难题就行了。其余20%用于学习新知识,扩展知识广度。而在私下<br>生活80%时间用于提升自身身心从煅练身体,阅读写作,训练口语方面着<br>手,而余下20%就拿来继续思考和处理琐事。</li><li>二八定律也可以用于人生的成长和财富积累，人生真正能好好生活的可能<br>就20%人生.所以在人生的黄金时期更要好好计划,让这20%去养活<br>余下80%人生。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的青春结束了</title>
      <link href="/zhb233go.github.io/2021/11/29/15-wo-de-qing-chun-jie-shu-liao/"/>
      <url>/zhb233go.github.io/2021/11/29/15-wo-de-qing-chun-jie-shu-liao/</url>
      
        <content type="html"><![CDATA[<h1 id="我的青春结束了"><a href="#我的青春结束了" class="headerlink" title="我的青春结束了"></a>我的青春结束了</h1><p>在周六的那天晚天,因为第二天需要早起,我比平常更早的睡觉了,差不多<br>八点多就开始睡觉了,当我睡到九点半多时,我被微信视频信息吵醒了<br>,我咪咪糊糊打开手机开始接听。原来是我的好兄弟<br>打过来的,他略带惊讶和急切的口吻对我说道:”兄弟你听说了吗?<br>你还有你前女友的微信吗?你不知道发生什么了吗!”我缓缓说道:她<br>被求婚了是吧,我听鋭了”,他略带同情的对我说:”兄弟,你还跟她联<br>系吗?”我回忙了一下说”好像一年多没联系了,我屏敝她了。”</p><p>是啊,曾经那个学生时代难忘的回忆,在时间这个巨轮面前,就如<br>同一颗小石子被无情碾过。我一直坚信那句话,人是会变的，两个人能否<br>最终走到一起,需要的是正确的时间和正确的地点。青春的时候<br>我们天真无邪,认为世界就是你我不需要考虑现实。现实是随着<br>时间流淌我们变得越来越现实,而你我的模样早已不是当初的<br>记忆。但是,人终一日会找到她的归属,我怀着真诚的心,诚挚的<br>祝福每个在我成长路上遇到的人,希望她能幸福!</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人生游戏</title>
      <link href="/zhb233go.github.io/2021/11/25/14-ren-sheng-you-xi/"/>
      <url>/zhb233go.github.io/2021/11/25/14-ren-sheng-you-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="人生是场游戏"><a href="#人生是场游戏" class="headerlink" title="人生是场游戏"></a>人生是场游戏</h1><p>生存是种即时策略游戏、所有的人都是这场游戏的玩家。财务自由了,<br>就是游戏的赢家。<br>具体来说又分成两种游戏财富游戏和地位游戏。财富游戏<br>的统家追求更多的财富,地位游戏的玩家追求最高的地位。<br>古时候,地位越高,财富越多,当大官就发大财.所以大家都说地位<br>游戏。现代社会财富游戏和地位游戏慢慢脱离了关系,不当大<br>官也可以发大财,财富游戏的玩家多了起来。<br>这两种游戏有本质的区别。地位游戏一定是零和的,有赢家<br>就肯定有输家。比如,我当了部门主管你就不能当了。所以地位<br>游戏很凶险,必须时刻提防其他玩家的冷枪。财富游戏不是零和的,<br>我赚了钱,不影响其人的收益很可能双赢。<br>创业是财富游戏,政治是地位游戏。因为上面的原因,我<br>认为,创业值得参与,政治不值得参与。有些创业项目也是零和的,<br>比如,抢票技术、秒杀技术、游戏外挂等,也不值得参与。</p><p>引用—网络</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记</title>
      <link href="/zhb233go.github.io/2021/11/24/13-du-shu-bi-ji/"/>
      <url>/zhb233go.github.io/2021/11/24/13-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><p>人不定命运的囚徒而是自己思想的囚徒——富兰克林•罗斯福</p><p>在我们进行天分比较时经常忽略沉默的证据,尤其在那些<br>受赢家通吃效应影响的行业。我们也许很喜欢那些成功故事,但太<br>把它们当回事是不应该的,因为我们并没有看到全部事实。</p><p>列夫·托尔斯泰说过,所有幸运的家庭都是一样的,而不幸的家庭<br>各有各的不幸。人们被发现犯了”喜欢苹果胜于喜欢橘子,喜欢橘子胜于<br>梨,喜欢梨胜于苹果”的错误,这视具体问题而定。<br>我们应该避免柏拉图化的思想。柏拉图化是自上而下的,程式化的,<br>封闭思维的,自我服务的商品化的,非柏拉图化是自下而上的开放<br>思维的,怀疑的经验的。<br>—-节选《黑天鹅》</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础——并发</title>
      <link href="/zhb233go.github.io/2021/11/24/go-yu-yan-ji-chu-bing-fa/"/>
      <url>/zhb233go.github.io/2021/11/24/go-yu-yan-ji-chu-bing-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础——并发"><a href="#Go语言基础——并发" class="headerlink" title="Go语言基础——并发"></a>Go语言基础——并发</h1><p>并发是编程里面一个非常重要的概念，Go语言在语言层面天生支持并发，这也是Go语言流行的一个很重要的原因。</p><h1 id="Go语言中的并发编程"><a href="#Go语言中的并发编程" class="headerlink" title="Go语言中的并发编程"></a>Go语言中的并发编程</h1><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。</p><p>并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。</p><p>Go语言的并发通过<code>goroutine</code>实现。<code>goroutine</code>类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个<code>goroutine</code>并发工作。<code>goroutine</code>是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。</p><p>Go语言还提供<code>channel</code>在多个<code>goroutine</code>间进行通信。<code>goroutine</code>和<code>channel</code>是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。</p><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？</p><p>Go语言中的<code>goroutine</code>就是这样一种机制，<code>goroutine</code>的概念类似于线程，但 <code>goroutine</code>是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p><p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–<code>goroutine</code>，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个<code>goroutine</code>去执行这个函数就可以了，就是这么简单粗暴。</p><h3 id="使用goroutine"><a href="#使用goroutine" class="headerlink" title="使用goroutine"></a>使用goroutine</h3><p>Go语言中使用<code>goroutine</code>非常简单，只需要在调用函数的时候在前面加上<code>go</code>关键字，就可以为一个函数创建一个<code>goroutine</code>。</p><p>一个<code>goroutine</code>必定对应一个函数，可以创建多个<code>goroutine</code>去执行相同的函数。</p><h3 id="启动单个goroutine"><a href="#启动单个goroutine" class="headerlink" title="启动单个goroutine"></a>启动单个goroutine</h3><p>启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个<code>go</code>关键字。</p><p>举个例子如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello Goroutine!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main goroutine done!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个示例中hello函数和下面的语句是串行的，执行的结果是打印完<code>Hello Goroutine!</code>后打印<code>main goroutine done!</code>。</p><p>接下来我们在调用hello函数前面加上关键字<code>go</code>，也就是启动一个goroutine去执行hello这个函数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 启动另外一个goroutine去执行hello函数</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main goroutine done!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这一次的执行结果只打印了<code>main goroutine done!</code>，并没有打印<code>Hello Goroutine!</code>。为什么呢？</p><p>在程序启动时，Go程序就会为<code>main()</code>函数创建一个默认的<code>goroutine</code>。</p><p>当main()函数返回的时候该<code>goroutine</code>就结束了，所有在<code>main()</code>函数中启动的<code>goroutine</code>会一同结束，<code>main</code>函数所在的<code>goroutine</code>就像是权利的游戏中的夜王，其他的<code>goroutine</code>都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p><p>所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是<code>time.Sleep</code>了。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 启动另外一个goroutine去执行hello函数</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main goroutine done!"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行上面的代码你会发现，这一次先打印<code>main goroutine done!</code>，然后紧接着打印<code>Hello Goroutine!</code>。</p><p>首先为什么会先打印<code>main goroutine done!</code>是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的<code>goroutine</code>是继续执行的。</p><h3 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h3><p>在Go语言中实现并发就是这样简单，我们还可以启动多个<code>goroutine</code>。让我们再来一个例子： （这里使用了<code>sync.WaitGroup</code>来实现goroutine的同步）</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// goroutine结束就登记-1</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello Goroutine!"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 启动一个goroutine就登记+1</span><span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 等待所有登记的goroutine都结束</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个<code>goroutine</code>是并发执行的，而<code>goroutine</code>的调度是随机的。</p><h2 id="goroutine与线程"><a href="#goroutine与线程" class="headerlink" title="goroutine与线程"></a>goroutine与线程</h2><h3 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a>可增长的栈</h3><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个<code>goroutine</code>的栈在其生命周期开始时只有很小的栈（典型情况下2KB），<code>goroutine</code>的栈不是固定的，他可以按需增大和缩小，<code>goroutine</code>的栈大小限制可以达到1GB，虽然极少会用到这么大。所以在Go语言中一次创建十万左右的<code>goroutine</code>也是可以的。</p><h3 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a>goroutine调度</h3><p><code>GPM</code>是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p><ul><li><code>G</code>很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li><li><code>P</code>管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li><li><code>M（machine）</code>是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</li></ul><p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p><p>P的个数是通过<code>runtime.GOMAXPROCS</code>设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p><p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，<code>goroutine</code>则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p><p><a href="https://www.cnblogs.com/sunsky303/p/9705727.html">点我了解更多</a></p><h3 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h3><p>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p><p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数。</p><p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p><p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"A:"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"B:"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>runtime<span class="token punctuation">.</span><span class="token function">GOMAXPROCS</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行，代码如下。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"A:"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"B:"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>runtime<span class="token punctuation">.</span><span class="token function">GOMAXPROCS</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go语言中的操作系统线程和goroutine的关系：</p><ol><li>一个操作系统线程对应用户态多个goroutine。</li><li>go程序可以同时使用多个操作系统线程。</li><li>goroutine和OS线程是多对多的关系，即m:n。</li></ol><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的<code>goroutine</code>中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><p>Go语言的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong>。</p><p>如果说<code>goroutine</code>是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个<code>goroutine</code>发送特定值到另一个<code>goroutine</code>的通信机制。</p><p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p><h3 id="channel类型"><a href="#channel类型" class="headerlink" title="channel类型"></a>channel类型</h3><p><code>channel</code>是一种类型，一种引用类型。声明通道类型的格式如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> 变量 <span class="token keyword">chan</span> 元素类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举几个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> ch1 <span class="token keyword">chan</span> <span class="token builtin">int</span>   <span class="token comment">// 声明一个传递整型的通道</span><span class="token keyword">var</span> ch2 <span class="token keyword">chan</span> <span class="token builtin">bool</span>  <span class="token comment">// 声明一个传递布尔型的通道</span><span class="token keyword">var</span> ch3 <span class="token keyword">chan</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token comment">// 声明一个传递int切片的通道</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h3><p>通道是引用类型，通道类型的空值是<code>nil</code>。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> ch <span class="token keyword">chan</span> <span class="token builtin">int</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token comment">// &lt;nil&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>声明的通道后需要使用<code>make</code>函数初始化之后才能使用。</p><p>创建channel的格式如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> 元素类型<span class="token punctuation">,</span> <span class="token punctuation">[</span>缓冲大小<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>channel的缓冲大小是可选的。</p><p>举几个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ch4 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>ch5 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>ch6 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h3><p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p><p>发送和接收都使用<code>&lt;-</code>符号。</p><p>现在我们先使用以下语句定义一个通道：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><p>将一个值发送到通道中。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ch <span class="token operator">&lt;-</span> <span class="token number">10</span> <span class="token comment">// 把10发送到ch中</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4><p>从一个通道中接收值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">x <span class="token operator">:=</span> <span class="token operator">&lt;-</span> ch <span class="token comment">// 从ch中接收值并赋值给变量x</span><span class="token operator">&lt;-</span>ch       <span class="token comment">// 从ch中接收值，忽略结果</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>我们通过调用内置的<code>close</code>函数来关闭通道。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p><p>关闭后的通道有以下特点：</p><ol><li>对一个关闭的通道再发送值就会导致panic。</li><li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致panic。</li></ol><h3 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a>无缓冲的通道</h3><p>无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>ch <span class="token operator">&lt;-</span> <span class="token number">10</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"发送成功"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">fatal error: all goroutines are asleep - deadlock<span class="token operator">!</span>goroutine <span class="token number">1</span> <span class="token punctuation">[</span>chan send<span class="token punctuation">]</span>:main.main<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">..</span>./src/github.com/Q1mi/studygo/day06/channel02/main.go:8 +0x54<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么会出现<code>deadlock</code>错误呢？</p><p>因为我们使用<code>ch := make(chan int)</code>创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。</p><p>上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁，那如何解决这个问题呢？</p><p>一种方法是启用一个<code>goroutine</code>去接收值，例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">recv</span><span class="token punctuation">(</span>c <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ret <span class="token operator">:=</span> <span class="token operator">&lt;-</span>cfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"接收成功"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">recv</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token comment">// 启用goroutine从通道接收值</span>ch <span class="token operator">&lt;-</span> <span class="token number">10</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"发送成功"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无缓冲通道上的发送操作会阻塞，直到另一个<code>goroutine</code>在该通道上执行接收操作，这时值才能发送成功，两个<code>goroutine</code>将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个<code>goroutine</code>在该通道上发送一个值。</p><p>使用无缓冲通道进行通信将导致发送和接收的<code>goroutine</code>同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p><h3 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a>有缓冲的通道</h3><p>解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 创建一个容量为1的有缓冲区通道</span>ch <span class="token operator">&lt;-</span> <span class="token number">10</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"发送成功"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p><p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量，虽然我们很少会这么做。</p><h3 id="for-range从通道循环取值"><a href="#for-range从通道循环取值" class="headerlink" title="for range从通道循环取值"></a>for range从通道循环取值</h3><p>当向通道中发送完数据时，我们可以通过<code>close</code>函数来关闭通道。</p><p>当通道被关闭时，再往该通道发送值会引发<code>panic</code>，从该通道取值的操作会先取完通道中的值，再然后取到的值一直都是对应类型的零值。那如何判断一个通道是否被关闭了呢？</p><p>我们来看下面这个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// channel 练习</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>ch2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token comment">// 开启goroutine将0~100的数发送到ch1中</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>ch1 <span class="token operator">&lt;-</span> i<span class="token punctuation">}</span><span class="token function">close</span><span class="token punctuation">(</span>ch1<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">{</span>i<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch1 <span class="token comment">// 通道关闭后再取值ok=false</span><span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">}</span>ch2 <span class="token operator">&lt;-</span> i <span class="token operator">*</span> i<span class="token punctuation">}</span><span class="token function">close</span><span class="token punctuation">(</span>ch2<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 在主goroutine中从ch2中接收值打印</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> ch2 <span class="token punctuation">{</span> <span class="token comment">// 通道关闭后会退出for range循环</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过我们通常使用的是<code>for range</code>的方式。使用<code>for range</code>遍历通道，当通道被关闭的时候就会退出<code>for range</code>。</p><h3 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h3><p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</p><p>Go语言中提供了<strong>单向通道</strong>来处理这种情况。例如，我们把上面的例子改造如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">counter</span><span class="token punctuation">(</span>out <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>out <span class="token operator">&lt;-</span> i<span class="token punctuation">}</span><span class="token function">close</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">squarer</span><span class="token punctuation">(</span>out <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">,</span> in <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> in <span class="token punctuation">{</span>out <span class="token operator">&lt;-</span> i <span class="token operator">*</span> i<span class="token punctuation">}</span><span class="token function">close</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">printer</span><span class="token punctuation">(</span>in <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> in <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>ch2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">counter</span><span class="token punctuation">(</span>ch1<span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">squarer</span><span class="token punctuation">(</span>ch2<span class="token punctuation">,</span> ch1<span class="token punctuation">)</span><span class="token function">printer</span><span class="token punctuation">(</span>ch2<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，</p><ul><li><code>chan&lt;- int</code>是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作；</li><li><code>&lt;-chan int</code>是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。</li></ul><p>在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。</p><h3 id="通道总结"><a href="#通道总结" class="headerlink" title="通道总结"></a>通道总结</h3><p><code>channel</code>常见的异常总结，如下图：<img src="https://www.liwenzhou.com/images/Go/concurrence/channel01.png" alt="channel异常总结"></p><p>关闭已经关闭的<code>channel</code>也会引发<code>panic</code>。</p><h2 id="worker-pool（goroutine池）"><a href="#worker-pool（goroutine池）" class="headerlink" title="worker pool（goroutine池）"></a>worker pool（goroutine池）</h2><p>在工作中我们通常会使用可以指定启动的goroutine数量–<code>worker pool</code>模式，控制<code>goroutine</code>的数量，防止<code>goroutine</code>泄漏和暴涨。</p><p>一个简易的<code>work pool</code>示例代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">worker</span><span class="token punctuation">(</span>id <span class="token builtin">int</span><span class="token punctuation">,</span> jobs <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> results <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token keyword">range</span> jobs <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"worker:%d start job:%d\n"</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> j<span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"worker:%d end job:%d\n"</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> j<span class="token punctuation">)</span>results <span class="token operator">&lt;-</span> j <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>jobs <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>results <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token comment">// 开启3个goroutine</span><span class="token keyword">for</span> w <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> w <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">;</span> w<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token keyword">go</span> <span class="token function">worker</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> jobs<span class="token punctuation">,</span> results<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 5个任务</span><span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>jobs <span class="token operator">&lt;-</span> j<span class="token punctuation">}</span><span class="token function">close</span><span class="token punctuation">(</span>jobs<span class="token punctuation">)</span><span class="token comment">// 输出结果</span><span class="token keyword">for</span> a <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> a <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> a<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token operator">&lt;-</span>results<span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h2><p>在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span><span class="token punctuation">{</span>    <span class="token comment">// 尝试从ch1接收值</span>    data<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch1    <span class="token comment">// 尝试从ch2接收值</span>    data<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch2    …<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了<code>select</code>关键字，可以同时响应多个通道的操作。</p><p><code>select</code>的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。<code>select</code>会一直等待，直到某个<code>case</code>的通信操作完成时，就会执行<code>case</code>分支对应的语句。具体格式如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">select</span><span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ch1<span class="token punctuation">:</span>        <span class="token operator">...</span>    <span class="token keyword">case</span> data <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch2<span class="token punctuation">:</span>        <span class="token operator">...</span>    <span class="token keyword">case</span> ch3<span class="token operator">&lt;-</span>data<span class="token punctuation">:</span>        <span class="token operator">...</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>        默认操作<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举个小例子来演示下<code>select</code>的使用：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token keyword">select</span> <span class="token punctuation">{</span><span class="token keyword">case</span> x <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token keyword">case</span> ch <span class="token operator">&lt;-</span> i<span class="token punctuation">:</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>select</code>语句能提高代码的可读性。</p><ul><li>可处理一个或多个channel的发送/接收操作。</li><li>如果多个<code>case</code>同时满足，<code>select</code>会随机选择一个。</li><li>对于没有<code>case</code>的<code>select{}</code>会一直等待，可用于阻塞main函数。</li></ul><h2 id="并发安全和锁"><a href="#并发安全和锁" class="headerlink" title="并发安全和锁"></a>并发安全和锁</h2><p>有时候在Go代码中可能会存在多个<code>goroutine</code>同时操作一个资源（临界区），这种情况会发生<code>竞态问题</code>（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。</p><p>举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> x <span class="token builtin">int64</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中我们开启了两个<code>goroutine</code>去累加变量x的值，这两个<code>goroutine</code>在访问和修改<code>x</code>变量的时候就会存在数据竞争，导致最后的结果与期待的不符。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个<code>goroutine</code>可以访问共享资源。Go语言中使用<code>sync</code>包的<code>Mutex</code>类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> x <span class="token builtin">int64</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">var</span> lock sync<span class="token punctuation">.</span>Mutex<span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 加锁</span>x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 解锁</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用互斥锁能够保证同一时间有且只有一个<code>goroutine</code>进入临界区，其他的<code>goroutine</code>则在等待锁；当互斥锁释放后，等待的<code>goroutine</code>才可以获取锁进入临界区，多个<code>goroutine</code>同时等待一个锁时，唤醒的策略是随机的。</p><h3 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h3><p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p><p>读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的<code>goroutine</code>如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个<code>goroutine</code>获取写锁之后，其他的<code>goroutine</code>无论是获取读锁还是写锁都会等待。</p><p>读写锁示例：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> <span class="token punctuation">(</span>x      <span class="token builtin">int64</span>wg     sync<span class="token punctuation">.</span>WaitGrouplock   sync<span class="token punctuation">.</span>Mutexrwlock sync<span class="token punctuation">.</span>RWMutex<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// lock.Lock()   // 加互斥锁</span>rwlock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 加写锁</span>x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span> <span class="token comment">// 假设读操作耗时10毫秒</span>rwlock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                   <span class="token comment">// 解写锁</span><span class="token comment">// lock.Unlock()                     // 解互斥锁</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// lock.Lock()                  // 加互斥锁</span>rwlock<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>               <span class="token comment">// 加读锁</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span> <span class="token comment">// 假设读操作耗时1毫秒</span>rwlock<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token comment">// 解读锁</span><span class="token comment">// lock.Unlock()                // 解互斥锁</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>start <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>end <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>end<span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。</p><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><p>在代码中生硬的使用<code>time.Sleep</code>肯定是不合适的，Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。 <code>sync.WaitGroup</code>有以下几个方法：</p><table><thead><tr><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">(wg * WaitGroup) Add(delta int)</td><td align="center">计数器+delta</td></tr><tr><td align="center">(wg *WaitGroup) Done()</td><td align="center">计数器-1</td></tr><tr><td align="center">(wg *WaitGroup) Wait()</td><td align="center">阻塞直到计数器变为0</td></tr></tbody></table><p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p><p>我们利用<code>sync.WaitGroup</code>将上面的代码优化一下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello Goroutine!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 启动另外一个goroutine去执行hello函数</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main goroutine done!"</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意<code>sync.WaitGroup</code>是一个结构体，传递的时候要传递指针。</p><h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>说在前面的话：这是一个进阶知识点。</p><p>在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。</p><p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案–<code>sync.Once</code>。</p><p><code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>o <span class="token operator">*</span>Once<span class="token punctuation">)</span> <span class="token function">Do</span><span class="token punctuation">(</span>f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>备注：如果要执行的函数<code>f</code>需要传递参数就需要搭配闭包来使用。</em></p><h4 id="加载配置文件示例"><a href="#加载配置文件示例" class="headerlink" title="加载配置文件示例"></a>加载配置文件示例</h4><p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> icons <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image<span class="token keyword">func</span> <span class="token function">loadIcons</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>icons <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image<span class="token punctuation">{</span><span class="token string">"left"</span><span class="token punctuation">:</span>  <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"left.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"up"</span><span class="token punctuation">:</span>    <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"up.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"right"</span><span class="token punctuation">:</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"right.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"down"</span><span class="token punctuation">:</span>  <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"down.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// Icon 被多个goroutine调用时不是并发安全的</span><span class="token keyword">func</span> <span class="token function">Icon</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> image<span class="token punctuation">.</span>Image <span class="token punctuation">{</span><span class="token keyword">if</span> icons <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token function">loadIcons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span> icons<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多个<code>goroutine</code>并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个<code>goroutine</code>都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">loadIcons</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>icons <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image<span class="token punctuation">)</span>icons<span class="token punctuation">[</span><span class="token string">"left"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"left.png"</span><span class="token punctuation">)</span>icons<span class="token punctuation">[</span><span class="token string">"up"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"up.png"</span><span class="token punctuation">)</span>icons<span class="token punctuation">[</span><span class="token string">"right"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"right.png"</span><span class="token punctuation">)</span>icons<span class="token punctuation">[</span><span class="token string">"down"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"down.png"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下就会出现即使判断了<code>icons</code>不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化<code>icons</code>的时候不会被其他的<code>goroutine</code>操作，但是这样做又会引发性能问题。</p><p>使用<code>sync.Once</code>改造的示例代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> icons <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image<span class="token keyword">var</span> loadIconsOnce sync<span class="token punctuation">.</span>Once<span class="token keyword">func</span> <span class="token function">loadIcons</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>icons <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image<span class="token punctuation">{</span><span class="token string">"left"</span><span class="token punctuation">:</span>  <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"left.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"up"</span><span class="token punctuation">:</span>    <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"up.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"right"</span><span class="token punctuation">:</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"right.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"down"</span><span class="token punctuation">:</span>  <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"down.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// Icon 是并发安全的</span><span class="token keyword">func</span> <span class="token function">Icon</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> image<span class="token punctuation">.</span>Image <span class="token punctuation">{</span>loadIconsOnce<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>loadIcons<span class="token punctuation">)</span><span class="token keyword">return</span> icons<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="并发安全的单例模式"><a href="#并发安全的单例模式" class="headerlink" title="并发安全的单例模式"></a>并发安全的单例模式</h4><p>下面是借助<code>sync.Once</code>实现的并发安全的单例模式：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> singleton<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">type</span> singleton <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">var</span> instance <span class="token operator">*</span>singleton<span class="token keyword">var</span> once sync<span class="token punctuation">.</span>Once<span class="token keyword">func</span> <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>singleton <span class="token punctuation">{</span>    once<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        instance <span class="token operator">=</span> <span class="token operator">&amp;</span>singleton<span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> instance<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sync.Once</code>其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p><h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><p>Go语言中内置的map不是并发安全的。请看下面的示例：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> m <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token keyword">return</span> m<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">set</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">,</span> value <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>m<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>wg <span class="token operator">:=</span> sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>key <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> n<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"k=:%v,v:=%v\n"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码开启少量几个<code>goroutine</code>的时候可能没什么问题，当并发多了之后执行上面的代码就会报<code>fatal error: concurrent map writes</code>错误。</p><p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code>。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> m <span class="token operator">=</span> sync<span class="token punctuation">.</span>Map<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>wg <span class="token operator">:=</span> sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>key <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>m<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> n<span class="token punctuation">)</span>value<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"k=:%v,v:=%v\n"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>在上面的代码中的我们通过锁操作来实现同步。而锁机制的底层是基于原子操作的，其一般直接通过CPU指令实现。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p><h3 id="atomic包"><a href="#atomic包" class="headerlink" title="atomic包"></a>atomic包</h3><table><thead><tr><th align="center">方法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">func LoadInt32(addr *int32) (val int32) func LoadInt64(addr *int64) (val int64) func LoadUint32(addr *uint32) (val uint32) func LoadUint64(addr *uint64) (val uint64) func LoadUintptr(addr *uintptr) (val uintptr) func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</td><td align="center">读取操作</td></tr><tr><td align="center">func StoreInt32(addr *int32, val int32) func StoreInt64(addr *int64, val int64) func StoreUint32(addr *uint32, val uint32) func StoreUint64(addr *uint64, val uint64) func StoreUintptr(addr *uintptr, val uintptr) func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</td><td align="center">写入操作</td></tr><tr><td align="center">func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</td><td align="center">修改操作</td></tr><tr><td align="center">func SwapInt32(addr *int32, new int32) (old int32) func SwapInt64(addr *int64, new int64) (old int64) func SwapUint32(addr *uint32, new uint32) (old uint32) func SwapUint64(addr *uint64, new uint64) (old uint64) func SwapUintptr(addr *uintptr, new uintptr) (old uintptr) func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</td><td align="center">交换操作</td></tr><tr><td align="center">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool) func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</td><td align="center">比较并交换操作</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"sync"</span><span class="token string">"sync/atomic"</span><span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">type</span> Counter <span class="token keyword">interface</span> <span class="token punctuation">{</span><span class="token function">Inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int64</span><span class="token punctuation">}</span><span class="token comment">// 普通版</span><span class="token keyword">type</span> CommonCounter <span class="token keyword">struct</span> <span class="token punctuation">{</span>counter <span class="token builtin">int64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c CommonCounter<span class="token punctuation">)</span> <span class="token function">Inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>c<span class="token punctuation">.</span>counter<span class="token operator">++</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c CommonCounter<span class="token punctuation">)</span> <span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int64</span> <span class="token punctuation">{</span><span class="token keyword">return</span> c<span class="token punctuation">.</span>counter<span class="token punctuation">}</span><span class="token comment">// 互斥锁版</span><span class="token keyword">type</span> MutexCounter <span class="token keyword">struct</span> <span class="token punctuation">{</span>counter <span class="token builtin">int64</span>lock    sync<span class="token punctuation">.</span>Mutex<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>MutexCounter<span class="token punctuation">)</span> <span class="token function">Inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>m<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">defer</span> m<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>m<span class="token punctuation">.</span>counter<span class="token operator">++</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>MutexCounter<span class="token punctuation">)</span> <span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int64</span> <span class="token punctuation">{</span>m<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">defer</span> m<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">return</span> m<span class="token punctuation">.</span>counter<span class="token punctuation">}</span><span class="token comment">// 原子操作版</span><span class="token keyword">type</span> AtomicCounter <span class="token keyword">struct</span> <span class="token punctuation">{</span>counter <span class="token builtin">int64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>a <span class="token operator">*</span>AtomicCounter<span class="token punctuation">)</span> <span class="token function">Inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>atomic<span class="token punctuation">.</span><span class="token function">AddInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">.</span>counter<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>a <span class="token operator">*</span>AtomicCounter<span class="token punctuation">)</span> <span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int64</span> <span class="token punctuation">{</span><span class="token keyword">return</span> atomic<span class="token punctuation">.</span><span class="token function">LoadInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">.</span>counter<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span>c Counter<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroupstart <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>c<span class="token punctuation">.</span><span class="token function">Inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>end <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>c1 <span class="token operator">:=</span> CommonCounter<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 非并发安全</span><span class="token function">test</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span>c2 <span class="token operator">:=</span> MutexCounter<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 使用互斥锁实现并发安全</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c2<span class="token punctuation">)</span>c3 <span class="token operator">:=</span> AtomicCounter<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 并发安全且比互斥锁效率更高</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c3<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Golang </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础——网络编程</title>
      <link href="/zhb233go.github.io/2021/11/24/go-yu-yan-ji-chu-wang-luo-bian-cheng/"/>
      <url>/zhb233go.github.io/2021/11/24/go-yu-yan-ji-chu-wang-luo-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础——网络编程"><a href="#Go语言基础——网络编程" class="headerlink" title="Go语言基础——网络编程"></a>Go语言基础——网络编程</h1><h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><p>Socket是BSD UNIX的进程通信机制，通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。Socket可以理解为TCP/IP网络的API，它定义了许多函数或例程，程序员可以用它们来开发TCP/IP网络上的应用程序。电脑上运行的应用程序通常通过”套接字”向网络发出请求或者应答网络请求。</p><h2 id="socket图解"><a href="#socket图解" class="headerlink" title="socket图解"></a>socket图解</h2><p><code>Socket</code>是应用层与TCP/IP协议族通信的中间软件抽象层。在设计模式中，<code>Socket</code>其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在<code>Socket</code>后面，对用户来说只需要调用Socket规定的相关函数，让<code>Socket</code>去组织符合指定的协议数据然后进行通信。</p><p><img src="https://www.liwenzhou.com/images/Go/socket/socket.png" alt="socket图解"></p><h2 id="Go语言实现TCP通信"><a href="#Go语言实现TCP通信" class="headerlink" title="Go语言实现TCP通信"></a>Go语言实现TCP通信</h2><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP/IP(Transmission Control Protocol/Internet Protocol) 即传输控制协议/网间协议，是一种面向连接（连接导向）的、可靠的、基于字节流的传输层（Transport layer）通信协议，因为是面向连接的协议，数据像水流一样传输，会存在黏包问题。</p><h3 id="TCP服务端"><a href="#TCP服务端" class="headerlink" title="TCP服务端"></a>TCP服务端</h3><p>一个TCP服务端可以同时连接很多个客户端，例如世界各地的用户使用自己电脑上的浏览器访问淘宝网。因为Go语言中创建多个goroutine实现并发非常方便和高效，所以我们可以每建立一次链接就创建一个goroutine去处理。</p><p>TCP服务端程序的处理流程：</p><ol><li>监听端口</li><li>接收客户端请求建立链接</li><li>创建goroutine处理链接。</li></ol><p>我们使用Go语言的net包实现的TCP服务端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// tcp/server/main.go</span><span class="token comment">// TCP server端</span><span class="token comment">// 处理函数</span><span class="token keyword">func</span> <span class="token function">process</span><span class="token punctuation">(</span>conn net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 关闭连接</span><span class="token keyword">for</span> <span class="token punctuation">{</span>reader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token keyword">var</span> buf <span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token builtin">byte</span>n<span class="token punctuation">,</span> err <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 读取数据</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read from client failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">}</span>recvStr <span class="token operator">:=</span> <span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"收到client端发来的数据："</span><span class="token punctuation">,</span> recvStr<span class="token punctuation">)</span>conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>recvStr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 发送数据</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>listen<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:20000"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"listen failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">{</span>conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> listen<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 建立连接</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"accept failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">}</span><span class="token keyword">go</span> <span class="token function">process</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span> <span class="token comment">// 启动一个goroutine处理连接</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将上面的代码保存之后编译成<code>server</code>或<code>server.exe</code>可执行文件。</p><h3 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h3><p>一个TCP客户端进行TCP通信的流程如下：</p><ol><li>建立与服务端的链接</li><li>进行数据收发</li><li>关闭链接</li></ol><p>使用Go语言的net包实现的TCP客户端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// tcp/client/main.go</span><span class="token comment">// 客户端</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:20000"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"err :"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 关闭连接</span>inputReader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdin<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span>input<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> inputReader<span class="token punctuation">.</span><span class="token function">ReadString</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token comment">// 读取用户输入</span>inputInfo <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Trim</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> <span class="token string">"\r\n"</span><span class="token punctuation">)</span><span class="token keyword">if</span> strings<span class="token punctuation">.</span><span class="token function">ToUpper</span><span class="token punctuation">(</span>inputInfo<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"Q"</span> <span class="token punctuation">{</span> <span class="token comment">// 如果输入q就退出</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>inputInfo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 发送数据</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span>buf <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span><span class="token punctuation">}</span>n<span class="token punctuation">,</span> err <span class="token operator">:=</span> conn<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"recv failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将上面的代码编译成<code>client</code>或<code>client.exe</code>可执行文件，先启动server端再启动client端，在client端输入任意内容回车之后就能够在server端看到client端发送的数据，从而实现TCP通信。</p><h2 id="TCP黏包"><a href="#TCP黏包" class="headerlink" title="TCP黏包"></a>TCP黏包</h2><h3 id="黏包示例"><a href="#黏包示例" class="headerlink" title="黏包示例"></a>黏包示例</h3><p>服务端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// socket_stick/server/main.go</span><span class="token keyword">func</span> <span class="token function">process</span><span class="token punctuation">(</span>conn net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>reader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token keyword">var</span> buf <span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token keyword">for</span> <span class="token punctuation">{</span>n<span class="token punctuation">,</span> err <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">}</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read from client failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">}</span>recvStr <span class="token operator">:=</span> <span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"收到client发来的数据："</span><span class="token punctuation">,</span> recvStr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>listen<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:30000"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"listen failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> listen<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span>conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> listen<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"accept failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">}</span><span class="token keyword">go</span> <span class="token function">process</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// socket_stick/client/main.go</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:30000"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"dial failed, err"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>msg <span class="token operator">:=</span> <span class="token string">`Hello, Hello. How are you?`</span>conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将上面的代码保存后，分别编译。先启动服务端再启动客户端，可以看到服务端输出结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端分10次发送的数据，在服务端并没有成功的输出10次，而是多条数据“粘”到了一起。</p><h3 id="为什么会出现粘包"><a href="#为什么会出现粘包" class="headerlink" title="为什么会出现粘包"></a>为什么会出现粘包</h3><p>主要原因就是tcp数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发。</p><p>“粘包”可发生在发送端也可发生在接收端：</p><ol><li>由Nagle算法造成的发送端的粘包：Nagle算法是一种改善网络传输效率的算法。简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。</li><li>接收端接收不及时造成的接收端粘包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。</li></ol><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>出现”粘包”的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。</p><p>封包：封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了(过滤非法包时封包会加入”包尾”内容)。包头部分的长度是固定的，并且它存储了包体的长度，根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。</p><p>我们可以自己定义一个协议，比如数据包的前4个字节为包头，里面存储的是发送的数据的长度。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// socket_stick/proto/proto.go</span><span class="token keyword">package</span> proto<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"bufio"</span><span class="token string">"bytes"</span><span class="token string">"encoding/binary"</span><span class="token punctuation">)</span><span class="token comment">// Encode 将消息编码</span><span class="token keyword">func</span> <span class="token function">Encode</span><span class="token punctuation">(</span>message <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 读取消息的长度，转换成int32类型（占4个字节）</span><span class="token keyword">var</span> length <span class="token operator">=</span> <span class="token function">int32</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">var</span> pkg <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span><span class="token comment">// 写入消息头</span>err <span class="token operator">:=</span> binary<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>pkg<span class="token punctuation">,</span> binary<span class="token punctuation">.</span>LittleEndian<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">}</span><span class="token comment">// 写入消息实体</span>err <span class="token operator">=</span> binary<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>pkg<span class="token punctuation">,</span> binary<span class="token punctuation">.</span>LittleEndian<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">}</span><span class="token keyword">return</span> pkg<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token comment">// Decode 解码消息</span><span class="token keyword">func</span> <span class="token function">Decode</span><span class="token punctuation">(</span>reader <span class="token operator">*</span>bufio<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 读取消息的长度</span>lengthByte<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">Peek</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">// 读取前4个字节的数据</span>lengthBuff <span class="token operator">:=</span> bytes<span class="token punctuation">.</span><span class="token function">NewBuffer</span><span class="token punctuation">(</span>lengthByte<span class="token punctuation">)</span><span class="token keyword">var</span> length <span class="token builtin">int32</span>err <span class="token operator">:=</span> binary<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>lengthBuff<span class="token punctuation">,</span> binary<span class="token punctuation">.</span>LittleEndian<span class="token punctuation">,</span> <span class="token operator">&amp;</span>length<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> err<span class="token punctuation">}</span><span class="token comment">// Buffered返回缓冲中现有的可读取的字节数。</span><span class="token keyword">if</span> <span class="token function">int32</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">Buffered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> length<span class="token operator">+</span><span class="token number">4</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> err<span class="token punctuation">}</span><span class="token comment">// 读取真正的消息数据</span>pack <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token function">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">+</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>pack<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> err<span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>pack<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来在服务端和客户端分别使用上面定义的<code>proto</code>包的<code>Decode</code>和<code>Encode</code>函数处理数据。</p><p>服务端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// socket_stick/server2/main.go</span><span class="token keyword">func</span> <span class="token function">process</span><span class="token punctuation">(</span>conn net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>reader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span>msg<span class="token punctuation">,</span> err <span class="token operator">:=</span> proto<span class="token punctuation">.</span><span class="token function">Decode</span><span class="token punctuation">(</span>reader<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"decode msg failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"收到client发来的数据："</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>listen<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:30000"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"listen failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> listen<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span>conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> listen<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"accept failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">}</span><span class="token keyword">go</span> <span class="token function">process</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// socket_stick/client2/main.go</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:30000"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"dial failed, err"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>msg <span class="token operator">:=</span> <span class="token string">`Hello, Hello. How are you?`</span>data<span class="token punctuation">,</span> err <span class="token operator">:=</span> proto<span class="token punctuation">.</span><span class="token function">Encode</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"encode msg failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Go语言实现UDP通信"><a href="#Go语言实现UDP通信" class="headerlink" title="Go语言实现UDP通信"></a>Go语言实现UDP通信</h2><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>UDP协议（User Datagram Protocol）中文名称是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联）参考模型中一种<strong>无连接</strong>的传输层协议，不需要建立连接就能直接进行数据发送和接收，属于不可靠的、没有时序的通信，但是UDP协议的实时性比较好，通常用于视频直播相关领域。</p><h3 id="UDP服务端"><a href="#UDP服务端" class="headerlink" title="UDP服务端"></a>UDP服务端</h3><p>使用Go语言的<code>net</code>包实现的UDP服务端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// UDP/server/main.go</span><span class="token comment">// UDP server端</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>listen<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">ListenUDP</span><span class="token punctuation">(</span><span class="token string">"udp"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>net<span class="token punctuation">.</span>UDPAddr<span class="token punctuation">{</span>IP<span class="token punctuation">:</span>   net<span class="token punctuation">.</span><span class="token function">IPv4</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Port<span class="token punctuation">:</span> <span class="token number">30000</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"listen failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> listen<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span><span class="token keyword">var</span> data <span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token builtin">byte</span>n<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> err <span class="token operator">:=</span> listen<span class="token punctuation">.</span><span class="token function">ReadFromUDP</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 接收数据</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read udp failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"data:%v addr:%v count:%v\n"</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> listen<span class="token punctuation">.</span><span class="token function">WriteToUDP</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span> <span class="token comment">// 发送数据</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"write to udp failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="UDP客户端"><a href="#UDP客户端" class="headerlink" title="UDP客户端"></a>UDP客户端</h3><p>使用Go语言的<code>net</code>包实现的UDP客户端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// UDP 客户端</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>socket<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">DialUDP</span><span class="token punctuation">(</span><span class="token string">"udp"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>net<span class="token punctuation">.</span>UDPAddr<span class="token punctuation">{</span>IP<span class="token punctuation">:</span>   net<span class="token punctuation">.</span><span class="token function">IPv4</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Port<span class="token punctuation">:</span> <span class="token number">30000</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"连接服务端失败，err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> socket<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>sendData <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"Hello server"</span><span class="token punctuation">)</span><span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>sendData<span class="token punctuation">)</span> <span class="token comment">// 发送数据</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"发送数据失败，err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>data <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">)</span>n<span class="token punctuation">,</span> remoteAddr<span class="token punctuation">,</span> err <span class="token operator">:=</span> socket<span class="token punctuation">.</span><span class="token function">ReadFromUDP</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment">// 接收数据</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"接收数据失败，err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"recv:%v addr:%v count:%v\n"</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> remoteAddr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Golang </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础——数组与切片</title>
      <link href="/zhb233go.github.io/2021/11/24/go-yu-yan-ji-chu-shu-zu-yu-qie-pian/"/>
      <url>/zhb233go.github.io/2021/11/24/go-yu-yan-ji-chu-shu-zu-yu-qie-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础——数组与切片"><a href="#Go语言基础——数组与切片" class="headerlink" title="Go语言基础——数组与切片"></a>Go语言基础——数组与切片</h1><h1 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h1><p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 定义一个长度为3元素类型为int的数组a</span><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="数组定义："><a href="#数组定义：" class="headerlink" title="数组定义："></a>数组定义：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">var 数组变量名 <span class="token punctuation">[</span>元素数量<span class="token punctuation">]</span>T<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如：<code>var a [5]int</code>， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 <code>[5]int</code>和<code>[10]int</code>是不同的类型。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">var</span> b <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">int</span>a <span class="token operator">=</span> b <span class="token comment">//不可以这样做，因为此时a和b是不同的类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>数组可以通过下标进行访问，下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>数组的初始化也有很多方式。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>初始化数组时可以使用初始化列表来设置数组元素的值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> testArray <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span>                        <span class="token comment">//数组会初始化为int类型的零值</span><span class="token keyword">var</span> numArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span>                 <span class="token comment">//使用指定的初始值完成初始化</span><span class="token keyword">var</span> cityArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"北京"</span><span class="token punctuation">,</span> <span class="token string">"上海"</span><span class="token punctuation">,</span> <span class="token string">"深圳"</span><span class="token punctuation">}</span> <span class="token comment">//使用指定的初始值完成初始化</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>testArray<span class="token punctuation">)</span>                      <span class="token comment">//[0 0 0]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>numArray<span class="token punctuation">)</span>                       <span class="token comment">//[1 2 0]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>cityArray<span class="token punctuation">)</span>                      <span class="token comment">//[北京 上海 深圳]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> testArray <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">var</span> numArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token keyword">var</span> cityArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"北京"</span><span class="token punctuation">,</span> <span class="token string">"上海"</span><span class="token punctuation">,</span> <span class="token string">"深圳"</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>testArray<span class="token punctuation">)</span>                          <span class="token comment">//[0 0 0]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>numArray<span class="token punctuation">)</span>                           <span class="token comment">//[1 2]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"type of numArray:%T\n"</span><span class="token punctuation">,</span> numArray<span class="token punctuation">)</span>   <span class="token comment">//type of numArray:[2]int</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>cityArray<span class="token punctuation">)</span>                          <span class="token comment">//[北京 上海 深圳]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"type of cityArray:%T\n"</span><span class="token punctuation">,</span> cityArray<span class="token punctuation">)</span> <span class="token comment">//type of cityArray:[3]string</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>我们还可以使用指定索引值的方式来初始化数组，例如:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>                  <span class="token comment">// [0 1 0 5]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"type of a:%T\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token comment">//type of a:[4]int</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>遍历数组a有以下两种方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"北京"</span><span class="token punctuation">,</span> <span class="token string">"上海"</span><span class="token punctuation">,</span> <span class="token string">"深圳"</span><span class="token punctuation">}</span><span class="token comment">// 方法1：for循环遍历</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 方法2：for range遍历</span><span class="token keyword">for</span> index<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> a <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">arraySum</span><span class="token punctuation">(</span>x <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">{</span>    sum <span class="token operator">:=</span> <span class="token number">0</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> x<span class="token punctuation">{</span>        sum <span class="token operator">=</span> sum <span class="token operator">+</span> v    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个求和函数只能接受<code>[3]int</code>类型，其他的都不支持。 再比如，</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。</p><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p><p>切片是一个引用类型，它的内部结构包含<code>地址</code>、<code>长度</code>和<code>容量</code>。切片一般用于快速地操作一块数据集合。</p><h2 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h2><p>声明切片类型的基本语法如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> name <span class="token punctuation">[</span><span class="token punctuation">]</span>T<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，</p><ul><li>name:表示变量名</li><li>T:表示切片中的元素类型</li></ul><p>举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 声明切片类型</span><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>              <span class="token comment">//声明一个字符串切片</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>             <span class="token comment">//声明一个整型切片并初始化</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">}</span> <span class="token comment">//声明一个布尔切片并初始化</span><span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">}</span> <span class="token comment">//声明一个布尔切片并初始化</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>              <span class="token comment">//[]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>              <span class="token comment">//[]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>              <span class="token comment">//[false true]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>       <span class="token comment">//true</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>       <span class="token comment">//false</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>       <span class="token comment">//false</span><span class="token comment">// fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h3><p>切片拥有自己的长度和容量，我们可以通过使用内置的<code>len()</code>函数求长度，使用内置的<code>cap()</code>函数求切片的容量。</p><h3 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h3><p>切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。</p><h4 id="简单切片表达式"><a href="#简单切片表达式" class="headerlink" title="简单切片表达式"></a>简单切片表达式</h4><p>切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的<code>low</code>和<code>high</code>表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出<code>1&lt;=索引值&lt;4</code>的元素组成切片s，得到的切片<code>长度=high-low</code>，容量等于得到的切片的底层数组的容量。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>s <span class="token operator">:=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>  <span class="token comment">// s := a[low:high]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"s:%v len(s):%v cap(s):%v\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">s:<span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">]</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:2 cap<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了方便起见，可以省略切片表达式中的任何索引。省略了<code>low</code>则默认为0；省略了<code>high</code>则默认为切片操作数的长度:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span>  <span class="token comment">// 等同于 a[2:len(a)]</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>  <span class="token comment">// 等同于 a[0:3]</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>   <span class="token comment">// 等同于 a[0:len(a)]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong></p><p>对于数组或字符串，如果<code>0 &lt;= low &lt;= high &lt;= len(a)</code>，则索引合法，否则就会索引越界（out of range）。</p><p>对切片再执行切片表达式时（切片再切片），<code>high</code>的上限边界是切片的容量<code>cap(a)</code>，而不是长度。<strong>常量索引</strong>必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果<code>low</code>和<code>high</code>两个指标都是常数，它们必须满足<code>low &lt;= high</code>。如果索引在运行时超出范围，就会发生运行时<code>panic</code>。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>s <span class="token operator">:=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>  <span class="token comment">// s := a[low:high]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"s:%v len(s):%v cap(s):%v\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>s2 <span class="token operator">:=</span> s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>  <span class="token comment">// 索引的上限是cap(s)而不是len(s)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"s2:%v len(s2):%v cap(s2):%v\n"</span><span class="token punctuation">,</span> s2<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">s:<span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">]</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:2 cap<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:4s2:<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> len<span class="token punctuation">(</span>s2<span class="token punctuation">)</span>:1 cap<span class="token punctuation">(</span>s2<span class="token punctuation">)</span>:1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="完整切片表达式"><a href="#完整切片表达式" class="headerlink" title="完整切片表达式"></a>完整切片表达式</h4><p>对于数组，指向数组的指针，或切片a(<strong>注意不能是字符串</strong>)支持完整切片表达式：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a<span class="token punctuation">[</span>low <span class="token punctuation">:</span> high <span class="token punctuation">:</span> max<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的代码会构造与简单切片表达式<code>a[low: high]</code>相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为<code>max-low</code>。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>t <span class="token operator">:=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"t:%v len(t):%v cap(t):%v\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">t:<span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">]</span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span>:2 cap<span class="token punctuation">(</span>t<span class="token punctuation">)</span>:4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>完整切片表达式需要满足的条件是<code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>，其他条件和简单切片表达式相同。</p><h3 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h3><p>我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的<code>make()</code>函数，格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>T, size, cap<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中：</p><ul><li>T:切片的元素类型</li><li>size:切片中元素的数量</li><li>cap:切片的容量</li></ul><p>举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>      <span class="token comment">//[0 0]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//2</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">cap</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//10</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中<code>a</code>的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以<code>len(a)</code>返回2，<code>cap(a)</code>则返回该切片的容量。</p><h3 id="切片的本质"><a href="#切片的本质" class="headerlink" title="切片的本质"></a>切片的本质</h3><p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p><p>举个例子，现在有一个数组<code>a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}</code>，切片<code>s1 := a[:5]</code>，相应示意图如下。<img src="https://www.liwenzhou.com/images/Go/slice/slice_01.png" alt="slice_01">切片<code>s2 := a[3:6]</code>，相应示意图如下：<img src="https://www.liwenzhou.com/images/Go/slice/slice_02.png" alt="slice_02"></p><h3 id="判断切片是否为空"><a href="#判断切片是否为空" class="headerlink" title="判断切片是否为空"></a>判断切片是否为空</h3><p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p><h2 id="切片不能直接比较"><a href="#切片不能直接比较" class="headerlink" title="切片不能直接比较"></a>切片不能直接比较</h2><p>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如下面的示例：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> s1 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>         <span class="token comment">//len(s1)=0;cap(s1)=0;s1==nil</span>s2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token comment">//len(s2)=0;cap(s2)=0;s2!=nil</span>s3 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//len(s3)=0;cap(s3)=0;s3!=nil</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p><h2 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h2><p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>s1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">//[0 0 0]</span>s2 <span class="token operator">:=</span> s1             <span class="token comment">//将s1直接赋值给s2，s1和s2共用一个底层数组</span>s2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span> <span class="token comment">//[100 0 0]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span> <span class="token comment">//[100 0 0]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="切片遍历"><a href="#切片遍历" class="headerlink" title="切片遍历"></a>切片遍历</h2><p>切片的遍历方式和数组是一致的，支持索引遍历和<code>for range</code>遍历。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">for</span> index<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> s <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="append-方法为切片添加元素"><a href="#append-方法为切片添加元素" class="headerlink" title="append()方法为切片添加元素"></a>append()方法为切片添加元素</h2><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment">// [1]</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>  <span class="token comment">// [1 2 3 4]</span>s2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span>  s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s2<span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token comment">// [1 2 3 4 5 6 7]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong>通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>没有必要像下面的代码一样初始化一个切片再传入<code>append()</code>函数使用，</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">// 没有必要初始化</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>  <span class="token comment">// 没有必要初始化</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p><p>举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//append()添加元素和切片扩容</span><span class="token keyword">var</span> numSlice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>numSlice <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>numSlice<span class="token punctuation">,</span> i<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v  len:%d  cap:%d  ptr:%p\n"</span><span class="token punctuation">,</span> numSlice<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>numSlice<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>numSlice<span class="token punctuation">)</span><span class="token punctuation">,</span> numSlice<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  len:1  cap:1  ptr:0xc0000a8000<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span><span class="token punctuation">]</span>  len:2  cap:2  ptr:0xc0000a8040<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">]</span>  len:3  cap:4  ptr:0xc0000b2020<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">]</span>  len:4  cap:4  ptr:0xc0000b2020<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">]</span>  len:5  cap:8  ptr:0xc0000b6000<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">]</span>  len:6  cap:8  ptr:0xc0000b6000<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">]</span>  len:7  cap:8  ptr:0xc0000b6000<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span><span class="token punctuation">]</span>  len:8  cap:8  ptr:0xc0000b6000<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span><span class="token punctuation">]</span>  len:9  cap:16  ptr:0xc0000b8000<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">]</span>  len:10  cap:16  ptr:0xc0000b8000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的结果可以看出：</p><ol><li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li><li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li></ol><p>append()函数还支持一次性追加多个元素。 例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> citySlice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token comment">// 追加一个元素</span>citySlice <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>citySlice<span class="token punctuation">,</span> <span class="token string">"北京"</span><span class="token punctuation">)</span><span class="token comment">// 追加多个元素</span>citySlice <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>citySlice<span class="token punctuation">,</span> <span class="token string">"上海"</span><span class="token punctuation">,</span> <span class="token string">"广州"</span><span class="token punctuation">,</span> <span class="token string">"深圳"</span><span class="token punctuation">)</span><span class="token comment">// 追加切片</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"成都"</span><span class="token punctuation">,</span> <span class="token string">"重庆"</span><span class="token punctuation">}</span>citySlice <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>citySlice<span class="token punctuation">,</span> a<span class="token operator">...</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>citySlice<span class="token punctuation">)</span> <span class="token comment">//[北京 上海 广州 深圳 成都 重庆]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="切片的扩容策略"><a href="#切片的扩容策略" class="headerlink" title="切片的扩容策略"></a>切片的扩容策略</h2><p>可以通过查看<code>$GOROOT/src/runtime/slice.go</code>源码，其中扩容相关代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">newcap <span class="token operator">:=</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span>doublecap <span class="token operator">:=</span> newcap <span class="token operator">+</span> newcap<span class="token keyword">if</span> <span class="token builtin">cap</span> <span class="token operator">&gt;</span> doublecap <span class="token punctuation">{</span>newcap <span class="token operator">=</span> <span class="token builtin">cap</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token keyword">if</span> old<span class="token punctuation">.</span><span class="token builtin">len</span> <span class="token operator">&lt;</span> <span class="token number">1024</span> <span class="token punctuation">{</span>newcap <span class="token operator">=</span> doublecap<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">// Check 0 &lt; newcap to detect overflow</span><span class="token comment">// and prevent an infinite loop.</span><span class="token keyword">for</span> <span class="token number">0</span> <span class="token operator">&lt;</span> newcap <span class="token operator">&amp;&amp;</span> newcap <span class="token operator">&lt;</span> <span class="token builtin">cap</span> <span class="token punctuation">{</span>newcap <span class="token operator">+=</span> newcap <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token comment">// Set newcap to the requested cap when</span><span class="token comment">// the newcap calculation overflowed.</span><span class="token keyword">if</span> newcap <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>newcap <span class="token operator">=</span> <span class="token builtin">cap</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的代码可以看出以下内容：</p><ul><li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li><li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），</li><li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li><li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li></ul><p><strong>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如<code>int</code>和<code>string</code>类型的处理方式就不一样。</strong></p><h2 id="使用copy-函数复制切片"><a href="#使用copy-函数复制切片" class="headerlink" title="使用copy()函数复制切片"></a>使用copy()函数复制切片</h2><p>首先我们来看一个问题：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>b <span class="token operator">:=</span> afmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[1 2 3 4 5]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">//[1 2 3 4 5]</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1000</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[1000 2 3 4 5]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">//[1000 2 3 4 5]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</strong></p><p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">copy<span class="token punctuation">(</span>destSlice, srcSlice <span class="token punctuation">[</span><span class="token punctuation">]</span>T<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中：</p><ul><li>srcSlice: 数据来源切片</li><li>destSlice: 目标切片</li></ul><p>举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// copy()复制切片</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token function">copy</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> a<span class="token punctuation">)</span>     <span class="token comment">//使用copy()函数将切片a中的元素复制到切片c</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[1 2 3 4 5]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token comment">//[1 2 3 4 5]</span>c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1000</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[1 2 3 4 5]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token comment">//[1000 2 3 4 5]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h2><p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 从切片中删除元素</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">37</span><span class="token punctuation">}</span><span class="token comment">// 要删除索引为2的元素</span>a <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[30 31 33 34 35 36 37]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Golang </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础——文件操作</title>
      <link href="/zhb233go.github.io/2021/11/24/go-yu-yan-ji-chu-wen-jian-cao-zuo/"/>
      <url>/zhb233go.github.io/2021/11/24/go-yu-yan-ji-chu-wen-jian-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础——文件操作"><a href="#Go语言基础——文件操作" class="headerlink" title="Go语言基础——文件操作"></a>Go语言基础——文件操作</h1><h1 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h1><p><code>os.Open()</code>函数能够打开一个文件，返回一个<code>*File</code>和一个<code>err</code>。对得到的文件实例调用<code>close()</code>方法能够关闭文件。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"os"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 只读方式打开当前目录下的main.go文件</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./main.go"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"open file failed!, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token comment">// 关闭文件</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了防止文件忘记关闭，我们通常使用defer注册文件关闭语句。</p><h1 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h1><h2 id="file-Read"><a href="#file-Read" class="headerlink" title="file.Read()"></a>file.Read()</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Read方法定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>File<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span>b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回<code>0</code>和<code>io.EOF</code>。 举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 只读方式打开当前目录下的main.go文件</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./main.go"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"open file failed!, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 使用Read方法读取数据</span><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span>n<span class="token punctuation">,</span> err <span class="token operator">:=</span> file<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"文件读完了"</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"读取了%d字节数据\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="循环读取"><a href="#循环读取" class="headerlink" title="循环读取"></a>循环读取</h3><p>使用for循环读取文件中的所有数据。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 只读方式打开当前目录下的main.go文件</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./main.go"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"open file failed!, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 循环读取文件</span><span class="token keyword">var</span> content <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span>n<span class="token punctuation">,</span> err <span class="token operator">:=</span> file<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"文件读完了"</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">}</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>content <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> tmp<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="bufio读取文件"><a href="#bufio读取文件" class="headerlink" title="bufio读取文件"></a>bufio读取文件</h2><p>bufio是在file的基础上封装了一层API，支持更多的功能。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"bufio"</span><span class="token string">"fmt"</span><span class="token string">"io"</span><span class="token string">"os"</span><span class="token punctuation">)</span><span class="token comment">// bufio按行读取示例</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./xx.txt"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"open file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>reader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span>line<span class="token punctuation">,</span> err <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">ReadString</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token comment">//注意是字符</span><span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"文件读完了"</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">}</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ioutil读取整个文件"><a href="#ioutil读取整个文件" class="headerlink" title="ioutil读取整个文件"></a>ioutil读取整个文件</h2><p><code>io/ioutil</code>包的<code>ReadFile</code>方法能够读取完整的文件，只需要将文件名作为参数传入。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"io/ioutil"</span><span class="token punctuation">)</span><span class="token comment">// ioutil.ReadFile读取整个文件</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>content<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span><span class="token string">"./main.go"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="文件写入操作"><a href="#文件写入操作" class="headerlink" title="文件写入操作"></a>文件写入操作</h1><p><code>os.OpenFile()</code>函数能够以指定模式打开文件，从而实现文件写入相关功能。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">OpenFile</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> flag <span class="token builtin">int</span><span class="token punctuation">,</span> perm FileMode<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>File<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中：</p><p><code>name</code>：要打开的文件名 <code>flag</code>：打开文件的模式。 模式有以下几种：</p><table><thead><tr><th align="center">模式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>os.O_WRONLY</code></td><td align="center">只写</td></tr><tr><td align="center"><code>os.O_CREATE</code></td><td align="center">创建文件</td></tr><tr><td align="center"><code>os.O_RDONLY</code></td><td align="center">只读</td></tr><tr><td align="center"><code>os.O_RDWR</code></td><td align="center">读写</td></tr><tr><td align="center"><code>os.O_TRUNC</code></td><td align="center">清空</td></tr><tr><td align="center"><code>os.O_APPEND</code></td><td align="center">追加</td></tr></tbody></table><p><code>perm</code>：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。</p><h2 id="Write和WriteString"><a href="#Write和WriteString" class="headerlink" title="Write和WriteString"></a>Write和WriteString</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span><span class="token string">"xx.txt"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_CREATE<span class="token operator">|</span>os<span class="token punctuation">.</span>O_TRUNC<span class="token operator">|</span>os<span class="token punctuation">.</span>O_WRONLY<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"open file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>str <span class="token operator">:=</span> <span class="token string">"hello 沙河"</span>file<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token comment">//写入字节切片数据</span>file<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span><span class="token string">"hello 小王子"</span><span class="token punctuation">)</span> <span class="token comment">//直接写入字符串数据</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="bufio-NewWriter"><a href="#bufio-NewWriter" class="headerlink" title="bufio.NewWriter"></a>bufio.NewWriter</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span><span class="token string">"xx.txt"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_CREATE<span class="token operator">|</span>os<span class="token punctuation">.</span>O_TRUNC<span class="token operator">|</span>os<span class="token punctuation">.</span>O_WRONLY<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"open file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>writer <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewWriter</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>writer<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span><span class="token string">"hello沙河\n"</span><span class="token punctuation">)</span> <span class="token comment">//将数据先写入缓存</span><span class="token punctuation">}</span>writer<span class="token punctuation">.</span><span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//将缓存中的内容写入文件</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ioutil-WriteFile"><a href="#ioutil-WriteFile" class="headerlink" title="ioutil.WriteFile"></a>ioutil.WriteFile</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>str <span class="token operator">:=</span> <span class="token string">"hello 沙河"</span>err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">WriteFile</span><span class="token punctuation">(</span><span class="token string">"./xx.txt"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"write file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="copyFile"><a href="#copyFile" class="headerlink" title="copyFile"></a>copyFile</h2><p>借助<code>io.Copy()</code>实现一个拷贝文件函数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// CopyFile 拷贝文件函数</span><span class="token keyword">func</span> <span class="token function">CopyFile</span><span class="token punctuation">(</span>dstName<span class="token punctuation">,</span> srcName <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>written <span class="token builtin">int64</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 以读方式打开源文件</span>src<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>srcName<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"open %s failed, err:%v.\n"</span><span class="token punctuation">,</span> srcName<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> src<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 以写|创建的方式打开目标文件</span>dst<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span>dstName<span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_WRONLY<span class="token operator">|</span>os<span class="token punctuation">.</span>O_CREATE<span class="token punctuation">,</span> <span class="token number">0644</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"open %s failed, err:%v.\n"</span><span class="token punctuation">,</span> dstName<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> dst<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">return</span> io<span class="token punctuation">.</span><span class="token function">Copy</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> src<span class="token punctuation">)</span> <span class="token comment">//调用io.Copy()拷贝内容</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">CopyFile</span><span class="token punctuation">(</span><span class="token string">"dst.txt"</span><span class="token punctuation">,</span> <span class="token string">"src.txt"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"copy file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"copy done!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实现一个cat命令"><a href="#实现一个cat命令" class="headerlink" title="实现一个cat命令"></a>实现一个cat命令</h2><p>使用文件操作相关知识，模拟实现linux平台<code>cat</code>命令的功能。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"bufio"</span><span class="token string">"flag"</span><span class="token string">"fmt"</span><span class="token string">"io"</span><span class="token string">"os"</span><span class="token punctuation">)</span><span class="token comment">// cat命令实现</span><span class="token keyword">func</span> <span class="token function">cat</span><span class="token punctuation">(</span>r <span class="token operator">*</span>bufio<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">{</span>buf<span class="token punctuation">,</span> err <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">ReadBytes</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token comment">//注意是字符</span><span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span><span class="token comment">// 退出之前将已读到的内容输出</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>flag<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 解析命令行参数</span><span class="token keyword">if</span> flag<span class="token punctuation">.</span><span class="token function">NArg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token comment">// 如果没有参数默认从标准输入读取内容</span><span class="token function">cat</span><span class="token punctuation">(</span>bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdin<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 依次读取每个指定文件的内容并打印到终端</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> flag<span class="token punctuation">.</span><span class="token function">NArg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>flag<span class="token punctuation">.</span><span class="token function">Arg</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> <span class="token string">"reading from %s failed, err:%v\n"</span><span class="token punctuation">,</span> flag<span class="token punctuation">.</span><span class="token function">Arg</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">}</span><span class="token function">cat</span><span class="token punctuation">(</span>bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Golang </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天必逛且可以提升技术能力的网址</title>
      <link href="/zhb233go.github.io/2021/11/23/12-mei-tian-bi-guang-qie-ke-yi-ti-sheng-ji-zhu-neng-li-de-wang-zhi/"/>
      <url>/zhb233go.github.io/2021/11/23/12-mei-tian-bi-guang-qie-ke-yi-ti-sheng-ji-zhu-neng-li-de-wang-zhi/</url>
      
        <content type="html"><![CDATA[<p>1.<a href="https://www.ruanyifeng.com/blog/">阮一峰的网络日志</a> 一个技术大佬创建的博客，里面有他每周周刊，可最新的技术和推荐文章</p><p>2.<a href="https://www.liwenzhou.com/">李文周的博客</a> 刚入go语言就会搜的博主，里面有他整理的有关go语言的系列教程，跟着学不迷路</p><p>3.<a href="https://github.com/avelino/awesome-go">awsome-go</a> github上星标最多的项目，上面有最全的go项目列表，站在巨人们的肩膀上，学习项目经验</p><p>4.<a href="https://roadmap.sh/roadmaps">开发者路线图</a> 可以了解一想要发展的学习路线，为你的开发前程指明道路<br>以下是golang的学习路线图:<br><img src="https://roadmap.sh/roadmaps/golang.png" alt="golang的学习路线图" title="golang"><br>5.<a href="https://news.ycombinator.com/news">Hacker News</a> 一个国外IT技术文章发布平台，可了解一些技术知识</p><p>6.<a href="https://gobyexample.com/">GoByExample</a> 一个通过go示例学习的网站</p><p>7.<a href="https://zh-style-guide.readthedocs.io/zh_CN/latest/index.html">中文技术文档写作风格指南</a> 一个指导如何书写中文文档的技术网站，为标准化的写作风格培养习惯</p><p>8.<a href="https://www.runoob.com/">菜鸟教程</a> 一个强烈推荐的软件开发初学者教学网站，网站全免费并且教学专业，通俗易懂，技术栈全覆盖</p><p>9.<a href="https://leetcode-cn.com/">Leetcode</a> 一个学软件编程必须要来的网站，上面可以看到许多大厂的面试题并且可以一边学习一边刷题，可以学习数据结构和算法，从基础开始打牢，经常逛逛去大厂机会大大增加</p><p>10.<a href="https://www.digitalocean.com/community">digitalocean</a> 一个技术开发论坛，上面有许多语言教程，非常专业</p><p>11.<a href="https://www.jianshu.com/techareas/backend">简书</a> 一个小型的技术博客发布平台</p><p>12.<a href="https://juejin.cn/">稀土掘金</a> 一个和简书相似的发布平台，比简书稍大</p><p>13.<a href="https://segmentfault.com/">segmentfault</a> 一个开发者社区</p><p>14.<a href="https://www.cnblogs.com/">博客园</a> 属于中国早期的技术博客平台，技术博客主的资历也最老，上面有许多经验资深的博客发布的文章</p><p>15.<a href="https://www.yuque.com/">语雀</a> 同样是博客发布平台</p><p>16.<a href="https://free-for.dev/#/?id=free-fordev">free-for.dev</a> 一个开发者免费的项目支持，前期可在上面寻找项目支持</p><p>17.<a href="https://www.sina.com.cn/">新浪网</a> 了解新闻、资讯、科技等动向</p><p>18.<a href="https://www.yii3.cn/">易三文档</a> 一个有几个使用的开发使用便捷手册</p><p>19.<a href="http://www.cyc2018.xyz/">CS-Notes</a> 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>值得收藏的网站</title>
      <link href="/zhb233go.github.io/2021/11/23/11-zhi-de-shou-cang-de-wang-zhan/"/>
      <url>/zhb233go.github.io/2021/11/23/11-zhi-de-shou-cang-de-wang-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="值得收藏的网站（持续更新）"><a href="#值得收藏的网站（持续更新）" class="headerlink" title="值得收藏的网站（持续更新）"></a>值得收藏的网站（持续更新）</h1><p>###个人推荐指数</p><ol><li><p>**** <a href="https://mixkit.co/">Mixkit 是一个免费图库，包含很棒的视频剪辑、音乐曲目、音效和视频模板。</a></p></li><li><p>*** <a href="https://pic.netbian.com/">彼岸图网是一个4K图纸下载网站，每天能下载一张免费4K壁纸</a></p></li><li><p>*** <a href="https://www.lofi.cafe/">lofi.cafe是一个很棒国外电台网站，能在工作学习之余听听音乐，轻音乐为主</a></p></li><li><p>***<a href="https://sample-videos.com/index.php#sample-mp4-video">simple.video一个免费示例视频网站，各种格式都有</a></p></li><li><p>** <a href="http://oskarstalberg.com/game/house/index.html">一个沙盒解压小游戏</a></p></li><li><p>** <a href="https://fuun.fun/">fun.site一个趣味网站大集合的网址</a></p></li><li><p>** <a href="https://www.flickr.com/photos/biodivlibrary/">一个可以观看动物插图的网站</a></p></li><li><p>** <a href="https://bruno-simon.com/">一个有趣的3D模型的网站</a></p></li><li><p>*** <a href="https://www.nocsdegree.com/">一个收集其他职业的人自学成为软件工程师采访的网站，学习其他人的经验</a></p></li></ol><p>10.* <a href="https://gifcities.org/">GifCities 是互联网档案馆的一个特殊项目，旨在庆祝网络保存 20 周年。Internet Archive 是一个非营利性数字图书馆，其中包含数百万本免费书籍、电影、软件、音乐、网站等。</a></p><p>11.***  <a href="https://ptable.com/#%E6%80%A7%E8%B4%A8">一个化学周期表的互动网站，有助理解化学元素</a></p><p>12.*** <a href="https://typlog.com/podlist/">收集高质量的中文播客的网站</a></p><p>13.*** <a href="https://www.indiehackers.com/">一个很棒的IT交流网站，上面有各种技术人员在上面发表文章</a></p><p>14.* <a href="https://blog.usepastel.com/post/33-beautiful-free-icon-sets">33 个具有漂亮免费图标集的网站</a></p><p>15.** <a href="https://www.veer.com/?utm_source=biantuwang&amp;chid=600">veer.com是一个提供免费插图的网站</a></p><p>16.* <a href="https://colorfu.art/editor">一个可以便捷制作大头报图的网站</a></p><p>17.** <a href="https://vididoo.vercel.app/">一个在线快捷处理音视频的网站</a></p><p>18.*** <a href="https://landgreen.github.io/physics/index.html">一个在线高中物理要点讲解，配有插图和动画。</a></p><p>19.*** <a href="http://www.progressfocused.com/">一个大学心理学教授的博客，可以学习有用的心理学小知识</a></p><p>20.***** <a href="https://www.pinterest.com/">pinterest一个国外免费的高质量图片网站，许多图片都可以直接当壁纸，但需要翻墙</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成功所需的 5 种文案写作技巧</title>
      <link href="/zhb233go.github.io/2021/11/23/10-cheng-gong-suo-xu-de-5-chong-wen-an-xie-zuo-ji-qiao/"/>
      <url>/zhb233go.github.io/2021/11/23/10-cheng-gong-suo-xu-de-5-chong-wen-an-xie-zuo-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h1 id="成功所需的-5-种文案写作技巧"><a href="#成功所需的-5-种文案写作技巧" class="headerlink" title="成功所需的 5 种文案写作技巧"></a>成功所需的 5 种文案写作技巧</h1><h2 id="文案撰稿人需要什么技能？"><a href="#文案撰稿人需要什么技能？" class="headerlink" title="文案撰稿人需要什么技能？"></a>文案撰稿人需要什么技能？</h2><p><a href="https://matgillard.com/?source=post_page-----a7be60065eb4-----------------------------------"><img src="https://miro.medium.com/fit/c/96/96/1*VP5ZfM9aHJL7d7x3_ITVTQ.jpeg" alt="马特吉拉德"></a></p><p><a href="https://matgillard.com/?source=post_page-----a7be60065eb4-----------------------------------">马特吉拉德</a><a href="https://medium.com/m/signin?actionUrl=https://medium.com/_/subscribe/user/9ef1cfb5557/a7be60065eb4&amp;operation=register&amp;redirect=https://goodcopywriting.com/5-copywriting-skills-you-need-to-succeed-a7be60065eb4&amp;user=Mat+Gillard&amp;userId=9ef1cfb5557&amp;source=post_page-9ef1cfb5557----a7be60065eb4---------------------follow_byline--------------">跟随</a></p><p><a href="https://goodcopywriting.com/5-copywriting-skills-you-need-to-succeed-a7be60065eb4?source=post_page-----a7be60065eb4-----------------------------------">11 月 23 日</a> · 2分钟阅读</p><p><img src="https://miro.medium.com/max/1400/1*iAg35spPJaEcUtsCcLA9kg.jpeg" alt="img"></p><p>您是否需要任何特殊的资格或技能才能成为一名撰稿人？</p><p>绝对不！</p><p>成为一名成功的撰稿人不需要正式的资格。要成为一名出色的文案撰稿人，您需要具有创造力、独立性以及良好的沟通技巧和知识，或者对销售和营销有个人兴趣。</p><p>尽管如此，以下五项技能将使您更轻松地生成成功和有效的副本。</p><h1 id="英语语言技能"><a href="#英语语言技能" class="headerlink" title="英语语言技能"></a>英语语言技能</h1><p>高水平的英语语言技能是必须的。读者经常寻找使用正确句子结构、单词选择、语法和拼写的副本。</p><p>作为文案，您还应该密切注意标点符号。</p><p>有大量免费网站可以帮助您在需要时提高英语技能。广泛阅读对建立词汇量也很有帮助。</p><h1 id="注重细节"><a href="#注重细节" class="headerlink" title="注重细节"></a>注重细节</h1><p>而且，除了英语语言技能外，您还需要能够发现工作中的错误。</p><p>在发送给客户或上传给读者之前，您的副本应尽可能无错误。</p><p>很多时候，作为一名自由撰稿人，您将成为自己的校对员和文案编辑，因此需要对细节有敏锐的洞察力。</p><h1 id="研究能力"><a href="#研究能力" class="headerlink" title="研究能力"></a>研究能力</h1><p>知道如何对您想写的主题进行彻底的研究、调查和批判性分析。</p><p>当然，互联网和现代技术通过使其更快、更容易来简化流程。</p><p>当您想了解您的客户和目标受众时，出色的研究技能也适用。</p><p>如果您知道如何以及在哪里找到它，那么您可以在互联网和书籍上找到的内容是无限的。</p><h1 id="大词汇"><a href="#大词汇" class="headerlink" title="大词汇"></a>大词汇</h1><p>广泛的词汇是有帮助的。重要的是在你的文案中使用各种各样的词，而不是相同的陈词滥调。</p><p>但在某些情况下，您可能必须坚持使用常见的和经过测试的词，尤其是在想要获得强有力的标题时。</p><p>不要重复相同的词，尤其是在同一段落中。</p><p>作为初学者，同义词库是开始寻找替代词的好地方。</p><h1 id="能够看到不同的观点"><a href="#能够看到不同的观点" class="headerlink" title="能够看到不同的观点"></a>能够看到不同的观点</h1><p>作为一名文案撰稿人，沉浸在别人的故事或经历中，发挥两全其美的作用。</p><p>你的意见和他们的意见。</p><p>您必须能够仔细聆听并了解他人的观点。</p><p>当您将自己置于读者和客户的角度时，它会让您更有同理心，并尊重地分享不同的观点。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些开发问题快速解决方案</title>
      <link href="/zhb233go.github.io/2021/11/23/9-yi-xie-kai-fa-wen-ti-kuai-su-jie-jue-fang-an-lian-jie-chi-xu-geng-xin-zhong/"/>
      <url>/zhb233go.github.io/2021/11/23/9-yi-xie-kai-fa-wen-ti-kuai-su-jie-jue-fang-an-lian-jie-chi-xu-geng-xin-zhong/</url>
      
        <content type="html"><![CDATA[<h4 id="1-怎样写Markdown文件？"><a href="#1-怎样写Markdown文件？" class="headerlink" title="1.怎样写Markdown文件？"></a>1.怎样写Markdown文件？</h4><p><a href="https://www.runoob.com/markdown/md-tutorial.html">Markdown语法图文全面教程(10分钟学会)</a></p><h4 id="2-常用的git命令"><a href="#2-常用的git命令" class="headerlink" title="2.常用的git命令"></a>2.常用的git命令</h4><p><a href="https://blog.csdn.net/halaoda/article/details/78661334?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163764899316780357255501%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163764899316780357255501&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-78661334.pc_search_all_es&amp;utm_term=%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4&amp;spm=1018.2226.3001.4187">Git 常用命令大全</a></p><h4 id="3-Linux常用命令"><a href="#3-Linux常用命令" class="headerlink" title="3.Linux常用命令"></a>3.Linux常用命令</h4><p><a href="https://blog.csdn.net/m0_47890251/article/details/106747543?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163764919116780271972292%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163764919116780271972292&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-5-106747543.pc_search_all_es&amp;utm_term=linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4&amp;spm=1018.2226.3001.4187">Linux常用命令大全（非常详细！）</a></p><h4 id="4-SSH简介及两种远程登录的方法"><a href="#4-SSH简介及两种远程登录的方法" class="headerlink" title="4.SSH简介及两种远程登录的方法"></a>4.SSH简介及两种远程登录的方法</h4><p><a href="https://blog.csdn.net/li528405176/article/details/82810342?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163764956316780269858066%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163764956316780269858066&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82810342.pc_search_all_es&amp;utm_term=ssh&amp;spm=1018.2226.3001.4187">SSH简介及两种远程登录的方法</a></p><h4 id="5-gpg使用方法"><a href="#5-gpg使用方法" class="headerlink" title="5.gpg使用方法"></a>5.gpg使用方法</h4><p><a href="https://blog.csdn.net/arv002/article/details/114322941?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163764968516780271533854%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163764968516780271533854&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-114322941.pc_search_all_es&amp;utm_term=gpg&amp;spm=1018.2226.3001.4187">gpg使用方法</a></p><h4 id="6-docker常用命令总结"><a href="#6-docker常用命令总结" class="headerlink" title="6.docker常用命令总结"></a>6.docker常用命令总结</h4><p><a href="https://blog.csdn.net/u013378306/article/details/86668313?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-86668313.nonecase&amp;spm=1018.2226.3001.4187">docker常用命令总结</a></p><h4 id="7-官方docker简介和构建docker镜像"><a href="#7-官方docker简介和构建docker镜像" class="headerlink" title="7.官方docker简介和构建docker镜像"></a>7.官方docker简介和构建docker镜像</h4><p><a href="docker%E7%AE%80%E4%BB%8B%E5%92%8C%E6%9E%84%E5%BB%BAdocker%E9%95%9C%E5%83%8F">docker简介和构建docker镜像</a></p><h4 id="8-5-个可用于改进开发过程的-Git-工作流程和分支策略"><a href="#8-5-个可用于改进开发过程的-Git-工作流程和分支策略" class="headerlink" title="8. 5 个可用于改进开发过程的 Git 工作流程和分支策略"></a>8. 5 个可用于改进开发过程的 Git 工作流程和分支策略</h4><p><a href="https://zepel.io/blog/5-git-workflows-to-improve-development/">5 个可用于改进开发过程的 Git 工作流程和分支策略</a></p><h4 id="9-理解Docker的多阶段镜像构建"><a href="#9-理解Docker的多阶段镜像构建" class="headerlink" title="9.理解Docker的多阶段镜像构建"></a>9.理解Docker的多阶段镜像构建</h4><p><a href="https://juejin.cn/post/6844903510874521608">理解Docker的多阶段镜像构建</a></p><h4 id="10-理解-gitignore文件和Dockerfile书写参考"><a href="#10-理解-gitignore文件和Dockerfile书写参考" class="headerlink" title="10.理解.gitignore文件和Dockerfile书写参考"></a>10.理解.gitignore文件和Dockerfile书写参考</h4><p><a href="https://git-scm.com/docs/gitignore">.gitignore理解</a></p><p><a href="https://docs.docker.com/engine/reference/builder/">Dockerfile参考</a></p><h4 id="11-Docker-时区调整方案"><a href="#11-Docker-时区调整方案" class="headerlink" title="11.Docker 时区调整方案"></a>11.Docker 时区调整方案</h4><p><a href="https://cloud.tencent.com/developer/article/1626811">Docker 时区调整方案</a></p><h4 id="12-什么是HASH？"><a href="#12-什么是HASH？" class="headerlink" title="12.什么是HASH？"></a>12.什么是HASH？</h4><p><a href="https://blog.csdn.net/asdzheng/article/details/70226007">Hash算法总结</a></p><h4 id="13-curl的用法指南"><a href="#13-curl的用法指南" class="headerlink" title="13.curl的用法指南"></a>13.curl的用法指南</h4><p><a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">curl的用法指南</a></p><p>持续更新…</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu开发环境快速安装教程</title>
      <link href="/zhb233go.github.io/2021/11/23/8-ubuntu-kai-fa-huan-jing-kuai-su-an-zhuang-jiao-cheng/"/>
      <url>/zhb233go.github.io/2021/11/23/8-ubuntu-kai-fa-huan-jing-kuai-su-an-zhuang-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu开发环境快速安装教程："><a href="#Ubuntu开发环境快速安装教程：" class="headerlink" title="Ubuntu开发环境快速安装教程："></a>Ubuntu开发环境快速安装教程：</h1><h3 id="ubuntu安装go："><a href="#ubuntu安装go：" class="headerlink" title="ubuntu安装go："></a>ubuntu安装go：</h3><p>1、下载二进制包：go1.4.linux-amd64.tar.gz。</p><p>2、将下载的二进制包解压至 /usr/local目录。</p><pre class="line-numbers language-none"><code class="language-none">tar -C /usr/local -xzf go1.4.linux-amd64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、将 /usr/local/go/bin 目录添加至PATH环境变量：</p><pre class="line-numbers language-none"><code class="language-none">export PATH=$PATH:/usr/local/go/bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="ubuntu安装docker："><a href="#ubuntu安装docker：" class="headerlink" title="ubuntu安装docker："></a>ubuntu安装docker：</h3><p>在终端中输入以下命令：</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>没有错误则成功了。</p><p>二、安装需要的包</p><p>在终端输入命令</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install apt-transport-https ca-certificates software-properties-common curl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>没有错误则成功。<br>三、添加 GPG 密钥，并添加 Docker-ce 软件源</p><p>官方的软件源（不推荐，很慢）：</p><pre class="line-numbers language-none"><code class="language-none">curl -fsSL https://download.docker.com/linux/ubuntu/gpg|sudo apt-key add -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>中国科技大学的 Docker-ce 源（其他源类似）：</p><pre class="line-numbers language-none"><code class="language-none">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">sudo add-apt-repository "deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \$(lsb_release -cs) stable"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="注意：添加错了可以用以下命令删除"><a href="#注意：添加错了可以用以下命令删除" class="headerlink" title="注意：添加错了可以用以下命令删除"></a>注意：添加错了可以用以下命令删除</h5><h5 id="查询keyid-下图"><a href="#查询keyid-下图" class="headerlink" title="查询keyid,下图"></a>查询keyid,下图</h5><pre class="line-numbers language-none"><code class="language-none">sudo apt-key list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="keyid-就是90那一串"><a href="#keyid-就是90那一串" class="headerlink" title="keyid 就是90那一串"></a>keyid 就是90那一串</h5><pre class="line-numbers language-none"><code class="language-none">sudo apt-key del &lt;keyid&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="加参数-r可以移除"><a href="#加参数-r可以移除" class="headerlink" title="加参数-r可以移除"></a>加参数-r可以移除</h5><pre class="line-numbers language-none"><code class="language-none">sudo add-apt-repository -r "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更新软件包缓存</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>四、安装 Docker-ce</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install docker-ce<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>五、测试运行</p><pre class="line-numbers language-none"><code class="language-none">sudo docker run hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>六、添加当前用户到 docker 用户组，可以不用 sudo 运行 docker</p><p>将当前用户添加到 docker 组</p><pre class="line-numbers language-none"><code class="language-none">sudo gpasswd -a ${USER} docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重新登录或者用以下命令切换到docker组</p><pre class="line-numbers language-none"><code class="language-none">newgrp - docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启docker服务</p><pre class="line-numbers language-none"><code class="language-none">sudo service docker restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不加sudo直接执行docker命令检查效果</p><pre class="line-numbers language-none"><code class="language-none">docker ps<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="ubuntu安装git："><a href="#ubuntu安装git：" class="headerlink" title="ubuntu安装git："></a>ubuntu安装git：</h3><h5 id="Linux-平台上安装"><a href="#Linux-平台上安装" class="headerlink" title="Linux 平台上安装"></a>Linux 平台上安装</h5><p>Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。</p><p>在有 yum 的系统上（比如 Fedora）或者有 apt-get 的系统上（比如 Debian 体系），可以用下面的命令安装：</p><p>各 Linux 系统可以使用其安装包管理工具（apt-get、yum 等）进行安装：</p><h5 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian/Ubuntu"></a>Debian/Ubuntu</h5><p>Debian/Ubuntu Git 安装命令为：</p><pre class="line-numbers language-none"><code class="language-none">$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \  libz-dev libssl-dev$ apt-get install git$ git --versiongit version 1.8.1.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ubuntu安装goland："><a href="#ubuntu安装goland：" class="headerlink" title="ubuntu安装goland："></a>ubuntu安装goland：</h3><h5 id="goland安装"><a href="#goland安装" class="headerlink" title="goland安装"></a>goland安装</h5><ol><li>下载goland<br><a href="https://www.jetbrains.com/go/download/#section=linux">Goland下载链接</a></li><li>cd到安装包目录，移动并解压</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">tar</span> -zxvf goland-2020.3.4.tar.gz -C /usr/local/ <span class="token comment">#包的名字自行修改</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>启动Goland</li></ol><p><img src="https://img-blog.csdnimg.cn/20210320104439418.png" alt="在这里插入图片描述"></p><h3 id="ubuntu安装google-chorme："><a href="#ubuntu安装google-chorme：" class="headerlink" title="ubuntu安装google chorme："></a>ubuntu安装google chorme：</h3><p>下载Chrome</p><pre class="line-numbers language-none"><code class="language-none">$ wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装</p><pre class="line-numbers language-none"><code class="language-none">$ sudo dpkg -i google-chrome-stable_current_amd64.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>报错</p><pre class="line-numbers language-none"><code class="language-none">$ sudo dpkg -i google-chrome-stable_current_amd64.deb(Reading database ... 155736 files and directories currently installed.)Preparing to unpack google-chrome-stable_current_amd64.deb ...Unpacking google-chrome-stable (88.0.4324.96-1) ...dpkg: dependency problems prevent configuration of google-chrome-stable: google-chrome-stable depends on fonts-liberation; however:  Package fonts-liberation is not installed. google-chrome-stable depends on libatk-bridge2.0-0 (&gt;= 2.5.3); however:  Package libatk-bridge2.0-0 is not installed. google-chrome-stable depends on libatk1.0-0 (&gt;= 2.2.0); however:  Package libatk1.0-0 is not installed. google-chrome-stable depends on libatspi2.0-0 (&gt;= 2.9.90); however:  Package libatspi2.0-0 is not installed. google-chrome-stable depends on libcairo2 (&gt;= 1.6.0); however:  Package libcairo2 is not installed. google-chrome-stable depends on libcups2 (&gt;= 1.4.0); however:  Package libcups2 is not installed. google-chrome-stable depends on libgbm1 (&gt;= 8.1~0); however:  Package libgbm1 is not installed. google-chrome-stable depends on libgdk-pixbuf2.0-0 (&gt;= 2.22.0); however:  Package libgdk-pixbuf2.0-0 is not installed. google-chrome-stable depends on libgtk-3-0 (&gt;= 3.9.10); however:  Package libgtk-3-0 is not installed. google-chrome-stable depends on libnspr4 (&gt;= 2:4.9-2~); however:  Package libnspr4 is not installed. google-chrome-stable depends on libnss3 (&gt;= 2:3.22); however:  Package libnss3 is not installed. google-chrome-stable depends on libpango-1.0-0 (&gt;= 1.14.0); however:  Package libpango-1.0-0 is not installed. google-chrome-stable depends on libxkbcommon0 (&gt;= 0.4.1); however:  Package libxkbcommon0 is not installed. google-chrome-stable depends on xdg-utils (&gt;= 1.0.2); however:  Package xdg-utils is not installed.dpkg: error processing package google-chrome-stable (--install): dependency problems - leaving unconfiguredProcessing triggers for mime-support (3.64ubuntu1) ...Processing triggers for man-db (2.9.1-1) ...Errors were encountered while processing: google-chrome-stable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>报错原因：缺少依赖软件包</p><pre class="line-numbers language-none"><code class="language-none">dpkg: error processing package google-chrome-stable (--install): dependency problems - leaving unconfigured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>解决办法：修复依赖关系</p><pre class="line-numbers language-none"><code class="language-none">$ sudo apt-get install -f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果系统中有某个软件包不满足依赖条件,这个命令就会自动修复,将要安装那个软件包依赖的软件包。</p><p>查看Chrome版本信息</p><pre class="line-numbers language-none"><code class="language-none">$ google-chrome --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="ubuntu安装teams："><a href="#ubuntu安装teams：" class="headerlink" title="ubuntu安装teams："></a>ubuntu安装teams：</h3><p>1、去官网下载二进制包teams.tar.gz。</p><p>2、将下载的二进制包解压至 /usr/local目录。</p><pre class="line-numbers language-none"><code class="language-none">tar -C /usr/local -xzf teams.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Ubuntu安装typora"><a href="#Ubuntu安装typora" class="headerlink" title="Ubuntu安装typora:"></a>Ubuntu安装typora:</h3><p>在终端中输入以下命令：</p><pre class="line-numbers language-none"><code class="language-none"># sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAEwget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -# add Typora's repositorysudo add-apt-repository 'deb https://typora.io/linux ./'sudo apt-get update# install typorasudo apt-get install typora<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ubuntu安装cloudmusic："><a href="#ubuntu安装cloudmusic：" class="headerlink" title="ubuntu安装cloudmusic："></a>ubuntu安装cloudmusic：</h3><p>先到网站下载安装包，网址：<a href="https://music.163.com/#/download">https://music.163.com/#/download</a> , 然后下载客户端，点击下载全部客户端，选择Linux版，选择Ubuntu18.04，其实我的20.04 版的没找到，不过这个用起来还不错。至于是32还是64，自己看吧。<br>然后将安装包下载到：~/下载 目录下，然后在这个目录下面打开终端。<br>在终端里面输入：sudo dpkg -i netease-cloud-music_1.2.1_amd64_ubuntu_20190428.deb 就行了</p><h3 id="ubuntu安装vim："><a href="#ubuntu安装vim：" class="headerlink" title="ubuntu安装vim："></a>ubuntu安装vim：</h3><p>自带的vi不好用，所以自己重新下了一下</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install vim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后进入/etc/vim目录下配置文件，使用会舒服一点</p><pre class="line-numbers language-none"><code class="language-none">sudo vim vimrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在末尾添加代码</p><pre><code>set number   set history=1000   set autoindentset smartindent set tabstop=4 set shiftwidth=4 set showmatch</code></pre><h3 id="ubuntu-安装PostMan"><a href="#ubuntu-安装PostMan" class="headerlink" title="ubuntu 安装PostMan:"></a>ubuntu 安装PostMan:</h3><pre class="line-numbers language-test" data-language="test"><code class="language-test">sudo snap install postman<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="ubuntu-安装nodejs和npm"><a href="#ubuntu-安装nodejs和npm" class="headerlink" title="ubuntu 安装nodejs和npm:"></a>ubuntu 安装nodejs和npm:</h4><p>一.下载最新版本的nodejs包（最新版本的nodejs包里默认含有npm）<br>可以去nodejs官网去查看最新版本的nodejs<br>网址如下：<a href="https://nodejs.org/en/download/current/">https://nodejs.org/en/download/current/</a><br>目前最新版本为：v17.1.0</p><pre class="line-numbers language-none"><code class="language-none">wget https://nodejs.org/dist/v17.1.0/node-v17.1.0-linux-x64.tar.xz    tar xf  node-v17.1.0-linux-x64.tar.xz       // 解压cd node-v17.1.0-linux-x64/                  // 进入解压目录 ./bin/node -v                               // 执行node命令 查看版本// bin目录下有执行文件npm和node 做软链接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下载到你当前的目录,假如是：/home/root/</p><p>第二步 创建软连接 可以在任意路径下执行npm node<br>注意：在创建软连接的时候要写 绝对路径,软连接到/usr/local/bin/</p><pre class="line-numbers language-none"><code class="language-none">ln -s  /home/root/node-v17.1.0-linux-x64/bin/node  /usr/local/bin/ln -s /home/root/node-v17.1.0-linux-x64/bin/npm  /usr/local/bin/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>// 注意要写文件的绝对路径</p><p>如果你在创建软连的时候，出现npm已经存在,node 已经存在<br>解决方案：<br>删除 /usr/local/bin/目录下的node，npm</p><p>rt@ubuntu:<del>$ sudo rm -rf /usr/local/bin/node<br>rt@ubuntu:</del>$ sudo rm -rf /usr/local/bin/npm</p><p>之后再创建软连接，完成。</p><pre class="line-numbers language-none"><code class="language-none">rbt@ubuntu:~$ node -vv17.1.0rt@ubuntu:~$ npm -v8.4.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样node和npm就同时安装成功了！</p><h4 id="ubuntu安装python3："><a href="#ubuntu安装python3：" class="headerlink" title="ubuntu安装python3："></a>ubuntu安装python3：</h4><p>ubuntu本身是有Python2.7版本的，但是不同版本的ubuntu中的Python3的版本是不同的，我现在用的是14版本就是python3.4，我想把它升级为3.6版本。当然，如果需要，你可以改为任意版本。</p><ol><li>安装python3.6(非必需)<br>在终端中输入下面的命令（不要怀疑，每行都是一个命令）</li></ol><pre class="line-numbers language-none"><code class="language-none">wget http://www.python.org/ftp/python/3.6.4/Python-3.6.4.tgz  tar -xvzf Python-3.6.4.tgz  cd Python-3.6.4  ./configure --with-ssl  make  sudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些命令会使你的ubuntu下载python3.6.4，并替换你现在的python3版本。</p><ol start="2"><li>安装python运行环境<br>输入sudo passwd 输入root相关密码，输入su，进入超级管理员（如果你没设置过，需要设置root用户密码），也许你在安装时还需要升级你的apt-get，命令行下输入apt-get update</li></ol><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install pythonsudo apt-get install python-dev(编译外部模块文件使用的)sudo apt-get install python-pipsudo apt-get install libxml*sudo apt-get install net-toolssudo apt-get install lsof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python3的话安装pip，命令为sudo apt-get install python3-pip<br>执行之后，输入python3来确定你是否安装成功，如下图所示显示python3.6.4即安装成功：</p><p>3.更新pip版本</p><pre class="line-numbers language-none"><code class="language-none">sudo pip install --upgrade pip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.安装SSH</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install openssh-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5.安装 Nginx</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>6.安装 uwsgi</p><pre class="line-numbers language-none"><code class="language-none">sudo pip install uwsgi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>部署django项目前输入以下命令开启8000端口</p><pre class="line-numbers language-none"><code class="language-none">uwsgi --http :8000  --chdir 项目路径 -w  项目名称.wsgi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解除端口被占用的命令：</p><pre class="line-numbers language-none"><code class="language-none">sudo fuser -k 8000/tcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="至此ubuntu的基本的软件开发环境基本搭建完成，本文只做快速搭建环境的流程，具体问题网上都有解决方案，还有就是为什么没有数据库的安装？废话，都有Docker了，谁还安装数据库呀！！！"><a href="#至此ubuntu的基本的软件开发环境基本搭建完成，本文只做快速搭建环境的流程，具体问题网上都有解决方案，还有就是为什么没有数据库的安装？废话，都有Docker了，谁还安装数据库呀！！！" class="headerlink" title="至此ubuntu的基本的软件开发环境基本搭建完成，本文只做快速搭建环境的流程，具体问题网上都有解决方案，还有就是为什么没有数据库的安装？废话，都有Docker了，谁还安装数据库呀！！！"></a>至此ubuntu的基本的软件开发环境基本搭建完成，本文只做快速搭建环境的流程，具体问题网上都有解决方案，还有就是为什么没有数据库的安装？废话，都有Docker了，谁还安装数据库呀！！！</h5>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旅行的意义</title>
      <link href="/zhb233go.github.io/2021/11/22/7-lu-xing-de-yi-yi/"/>
      <url>/zhb233go.github.io/2021/11/22/7-lu-xing-de-yi-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="旅行的意义"><a href="#旅行的意义" class="headerlink" title="旅行的意义"></a>旅行的意义</h1><ul><li>今天看到一句话:”年轻时,我认为旅行是人生重要的事情,但是</li></ul><p>现在,我意识到旅行不是如此。它没有那么让人兴奋,也算不上成就,</p><p>跟其它的消费行为没有太大区别。旅行中,我们真正感兴趣的东西都是</p><p>那些留在原地,努力建设的人们建造出来的。</p><p>现在想想去年我做了一年的技术支持,也去过了祖国许多的地方,对于我来说,第一份</p><p>工作它虽然谈不上好,但对于我自己的成长和视界上的提升是巨大的,从</p><p>小我就希望到外界的世界去看看.大山的孩子的心思总是单纯的。一年的时间,</p><p>一边工作的同时也欣赏了各地的风景,但是我遗憾是给我去探寻留在原地</p><p>的人们建造出来的美景、美食和美丽的心灵的时间太短。每经过一个</p><p>地方都是匆匆而过,虽然时间短暂,但留在我心中的种子已经种子,我相信这颗种子不会死去,</p><p>随着时间的成熟和我个人的成长,一定会再次绽放那个短暂回忆美丽的</p><p>花朵,因为人是一直成长的,但是那些地方和那些人一定</p><p>会留住原地继续建造，等待每个匆匆过往的旅客。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最重要的事,就是做你认为正确的事</title>
      <link href="/zhb233go.github.io/2021/11/21/6-zui-chong-yao-de-shi-jiu-shi-zuo-ni-ren-wei-zheng-que-de-shi/"/>
      <url>/zhb233go.github.io/2021/11/21/6-zui-chong-yao-de-shi-jiu-shi-zuo-ni-ren-wei-zheng-que-de-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="最重要的事-就是做你认为正确的事"><a href="#最重要的事-就是做你认为正确的事" class="headerlink" title="最重要的事,就是做你认为正确的事"></a>最重要的事,就是做你认为正确的事</h1><ul><li>在小时候母亲都外出务工了,由爷爷奶奶扶养到初中,他们就<br>离世了,之后就是我和姐姐在家,我爸为了能照映到我们都在离<br>家较近的地方打工,妈妈常年在外务工,从小到大父母由于文化<br>程度都不高,在能给予我支持的就是尽力供我的教育,每次他们能与<br>我沟通的就是希望我好好读书,以后能找到一份好的工作,而现在,<br>大学读完了,也有了工作.我不知道是不是就达到了父母的期望。以前的<br>我很迷茫,也幸好我老家是个小地方,没有太多选择,在小学、初中、高中,<br>我尽我的可能都进了能尽量好的班级学习,不出意外的,我考上了大学,<br>而且是个一本,(我以为的)在选考业的时候,依旧迷茫,不知道选什么专业,<br>但是,不知道为什么,我的心中就认为以后的世界一定是互联网的世界,或许<br>是有预感,或许自己爱打游戏,对于我当时的天真和想法其实<br>到现在我也觉得是正确的,因为我想有学习软件开发或许我真的可以搞出个<br>名堂来。在当时,我在选学校时,我记得我的大学的第一志愿都选了”软件工程”,<br>之后是计算机”灬反正就是和软件相关的我都写上了,但是由<br>于贵州有贫困生补助,能写三个提前批的大学名额这个名额是那<br>外省大学为了一些特设学科而给出的名额。但是这些大学的学科都不是<br>我想去的,我就抱着不想去的心态,随便选了三个我自认为得不到的大学,并<br>选择了与软件工程挨了一点边的《电子信息科学与技术》,而我也因为这个阴差<br>阳错的来到了我的母校”天津工业大学”,我很意外,也<br>有一点遗憾,没有能去我心心念念的大学学科。</li><li>读了九年的义务教育、从来没有人告诉我该做什么<br>父母告诉我好好读书,我就好好的考上了大学,<br>但是大学的学科并不是我想学习的学科、也没有人该告诉我应该做什么了,<br>又一次不出意外的,我迷茫了,在大学里充满了诱惑游戏、金钱、娱乐。<br>那时的我就像个孩子,脱离了父母的监管,在大学肆意的放纵。可以<br>想象之后的学习就像还狂奔的野马,踏进泥塘——一踏胡图,在大<br>三的学科有七科学科，我就挂了六科,谈了四年的女友也分了,当时的自己<br>就能用一个字形容:”颓废!加之我跟人借钱,欠了一屁股债。可以这么说:<br>这是我活到现在人生的最低谷。那个时候真的可以体验。 晚上在床上睡<br>不着见到第二天的太阳。经历那段时间,我也没有了其它的顾虑,将学科<br>补考,最后靠着几个难兄难弟的同学抗过了大学结束。而现在我回到了我当时<br>想报考的学科。在互联网做个软件开发,我很开心,因为我在做着我喜欢的<br>事情而我现在的工作都靠我自己学习而得到的,现在,我能理解什么是正确的事情。</li><li>罗翔老师在档节目里曾说:”你最重要是做你觉得正确的事情,<br>最重要的是你听不到内心的抱怨,最重要的是多年以后的你能够看得<br>起现在的你,过好每一天,演好当下的剧本,朝着心中的那个标杆去前进,<br>人要做到!不清高,不娇情,不抱怨,就是在黑夜中看到了微光,<br>你就朝着微光的方向走过去,虽然有的时候你去怀疑你会觉得<br>是不是走错了,但是所有的怀疑都为了确信:那就是如何过看起来好的一生<br>,那你就要去定义了,什么叫做好,这个世界有太多关于好的标准了。<br>good（好）,如果加个s,就变成了 goods (商品),所以一切事情<br>最重要的就是赚钱吗!难道能赚钱的职业就是好职业吗?那这样做<br>一切职业分工就没有意义了。你要去寻找什么叫good,然后你才能去过 good<br>的一生,你才可以避免去随波逐流,你才内心会有一种笃定,你才会拒绝跟别人<br>去攀比,也拒绝被别人攀比。对于不可控的事情,我们保持<br>乐观,对于可控的事情,我们保持谨慎。于是你就仔细去回想,你这一生<br>中所遇到的很多经历,很多重要的时刻,你才恍然大悟,原来你就是个很<br>渺小的人”。</li><li>虽然现在我的人生才走了四分之一的阶段,但是我还要面对我人生的以后的<br>各个重大时刻。所以,我希望以后的我能够坦然的面对,也希望以后的<br>自己,能够看得起现在的自己</li></ul><p>——致自己<br>2021.11.20</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以后的世界将是游戏的世界</title>
      <link href="/zhb233go.github.io/2021/11/20/5-yi-hou-de-shi-jie-jiang-shi-you-xi-de-shi-jie/"/>
      <url>/zhb233go.github.io/2021/11/20/5-yi-hou-de-shi-jie-jiang-shi-you-xi-de-shi-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="以后的世界将是游戏的世界"><a href="#以后的世界将是游戏的世界" class="headerlink" title="以后的世界将是游戏的世界"></a>以后的世界将是游戏的世界</h1><p>上周同时观看了两部电影,分别是《头号流家》与《失控玩家》两部</p><p>电影都是讲述近未来的游戏世界,《头号玩家》以玩家视角为切入点,</p><p>讲述玩家以VR眼镜和体感服装为媒介,进入一个虚拟世界与众多玩家</p><p>一起游玩,这个世界与现实世界就如同一个平行</p><p>宇宙,玩家可以在这个宇宙里面做任何它想做的事情。而</p><p>《失控玩家》则以游戏NPC为视角,向观众介绍了人工智能与</p><p>游戏世界不同的可能性。又时逢前段时间,元宇宙的概率</p><p>大火,就向人们抛出了可在人工智能,大数据,去服务逐渐</p><p>盛行的时代,在不久的未来,就会出现这种产品。但是,一方面</p><p>上层的服务需要有底层硬件的支持。就现阶段而言,VR眼镜</p><p>与体感套件都很初级,服务器也难以支持这种大型的游戏服务。所以在我看来我对</p><p>以后的游戏市场保持乐观心态,可能在未来5年的时间,我们将看到游戏</p><p>市场的澎渤发展。我会不断观察和验证我的观点。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对新人的一些建议</title>
      <link href="/zhb233go.github.io/2021/11/19/4-dui-xin-ren-de-yi-xie-jian-yi/"/>
      <url>/zhb233go.github.io/2021/11/19/4-dui-xin-ren-de-yi-xie-jian-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="软件开发人员促销：获得更高水平的建议"><a href="#软件开发人员促销：获得更高水平的建议" class="headerlink" title="软件开发人员促销：获得更高水平的建议"></a>软件开发人员促销：获得更高水平的建议</h1><p>我最近的促销活动进展顺利。当<a href="https://blog.pragmaticengineer.com/things-ive-learned-transitioning-from-engineer-to-engineering-manager/">我从工程师过渡到管理人员时</a>，我有八个人向我报告。两年后，他们都被提升到了一个新的水平，还有一些其他的开发人员，他们后来加入了我的团队。从那以后，我帮助团队以外的人整理了成功的晋升案例，并成为了几个工程师晋升委员会的成员。最近，我也被提升到了更高一级的工程管理。</p><p>升职迟早会成为工程师的敏感话题。加入一家公司时，很少有开发人员会考虑到这一点——这是理所当然的，因为人们都专注于跟上进度。但随着时间的推移，随着越来越多的人在他们身边得到晋升，晋升成为许多人的首要考虑。作为经理，这自然成为我经常思考的话题。</p><p><strong>本文收集了我向团队中的工程师提供的晋升建议</strong>- 其中许多人后来被提升到更高级别。</p><ul><li><a href="https://blog.pragmaticengineer.com/software-engineering-promotions/#do-your-preparation">做好准备</a></li><li><a href="https://blog.pragmaticengineer.com/software-engineering-promotions/#set-your-sight-on-the-promotion">将目光投向促销</a></li><li><a href="https://blog.pragmaticengineer.com/software-engineering-promotions/#get-help-frequent-feedback">获得帮助和频繁的反馈</a></li><li><a href="https://blog.pragmaticengineer.com/software-engineering-promotions/#put-in-the-work">投入工作</a></li><li><a href="https://blog.pragmaticengineer.com/software-engineering-promotions/#stay-grounded">脚踏实地</a></li><li>帮助别人</li></ul><h2 id="做好准备"><a href="#做好准备" class="headerlink" title="做好准备"></a>做好准备</h2><p>一旦你决定你对升职有兴趣，就从收集基本信息开始，并评估升职对你的现实程度。</p><h4 id="了解贵公司的晋升流程。"><a href="#了解贵公司的晋升流程。" class="headerlink" title="了解贵公司的晋升流程。"></a>了解贵公司的晋升流程。</h4><p>每家公司都有不同的晋升流程。虽然类似的公司可能有类似的流程，但不要想当然。如果有关于该过程的信息，那就是一个很好的开始。最好的起点是询问您的经理。随着公司的成长和成熟，促销流程发生了变化。我观察到的最常见的促销过程类型是以下三种：</p><ul><li><strong>非正式升职：经理决定谁升职</strong>。几位经理进入一个房间，然后拿出一份晋升人员名单，这是小型初创公司和公司的典型流程。在会议上，管理人员介绍他们团队中的人员，然后由团队决定他们是否准备好晋升。</li><li><strong>半正式的晋升过程，有一个以经理为主的晋升委员会</strong>。随着公司的发展，将所有经理聚集在一起变得困难且耗时。此外，先前过程的偏见开始变得更加明显。领导层将致力于制定一个更具可扩展性和更公平的流程。这通常从写下每个工程级别的基本期望开始，并要求经理提交简短的文档，说明他们团队中的工程师为什么准备晋升。</li><li><strong>正式的晋升流程：晋升套餐和委员会</strong>。谷歌、优步和几家大型科技公司都在效仿这种流程。它需要有明确和广泛定义的工作阶梯，在每个级别都有明确的期望。我们的想法是使促销活动尽可能公正。作为更公平和透明的过程的回报，产生了更多的文件。广泛的自我审查、同行审查和经理审查被写入。由高级工程师和管理人员组成的晋升委员会决定晋升是否通过。</li></ul><p>所有方法都有其优点和缺点。了解您的组织正在关注什么，以便您更好地了解您和您的经理必须如何准备。</p><h4 id="评估自己"><a href="#评估自己" class="headerlink" title="评估自己"></a>评估自己</h4><p>大多数科技公司都采用一种方法，将已经在那里工作的人提升到更高的水平。晋升通常是对您的影响力和技能始终超出对您的期望的认可，并且符合下一个级别的规范。</p><p>那么，与下一个级别相比，您的表现如何？当您在一家公司工作时，回答这个问题要容易得多，在文档中明确定义了能力和级别，您可以参考。定义明确的能力的一些很好的例子包括<a href="https://progression.monzo.com/">Monzo</a>、<a href="https://docs.google.com/spreadsheets/d/12h50IYqd7fsO7tJ0l1OuHYbz5vN2d24a8EIDFhu2AZQ/edit#gid=2035430096">Square</a>或<a href="https://dresscode.renttherunway.com/blog/ladder">Rent The Runway 等</a>。如果您的公司拥有明确定义的能力，请通读您所在级别和下一级别的期望。列出您所展示的技能、您所产生的影响以及它如何与这些期望相匹配。</p><p>如果您的公司没有明确的能力和期望，您仍然需要弄清楚您在当前的期望中表现如何。您还想知道达到下一个级别的预期目标。<strong>根据经验，要考虑晋升，您应该在目前的水平上做得很好。</strong>因此，您可以从获取有关您当前表现的反馈开始，与最适合向您提供反馈的人交谈：您的经理。</p><h4 id="让你的经理站在你这边"><a href="#让你的经理站在你这边" class="headerlink" title="让你的经理站在你这边"></a>让你的经理站在你这边</h4><p>无论您的公司遵循什么流程，如果您的经理不支持升职，那么您获得晋升的机会非常渺茫。所以一定要让你的经理站在你这边。你怎么做到这一点？询问他们促销是如何运作的，他们的促销理念是什么。与当前和下一级别相比，询问他们如何评价您当前的表现。根据您的经理的不同，您可能会决定逐步提出这个问题，但您迟早需要就此进行坦诚的对话。</p><p>这种谈话对我来说总是很尴尬，作为一名工程师，我在职业生涯中很长一段时间都避免这种谈话。回想起来，我希望我没有。原因很简单。</p><p>*<strong>当*您准备好*时，*晋升符合您经理的最佳利益。</strong>管理者的评判标准是他们是否有能力让他们的团队提供更好的产出。他们通过让他们的工程师作为一个团队更有效率来做到这一点。为了让团队更有效率，团队中的工程师需要成长为更高效、更可靠和更资深。外部可见的增长指标之一是促销活动。晋升意味着经理帮助这个人成长——要么通过指导、指导，要么只是让他们摆脱困境。一个团队越来越高级的经理表明他们在培养人才方面做得很好。</p><p>所以我们知道晋升会让经理看起来很好。尽管如此，仍有很多开发人员认为<em>“我的经理永远不会提拔我”。</em>问问自己：这是为什么？一位领导停滞不前的经理开始引起来自上级和团队的不必要的关注。如果人们不断收到平均或差劲的绩效评估，而从不准备升职，那对经理来说也不好看。所以在你问过自己为什么你的经理似乎不想提拔你之后，也问问你的经理。告诉您您可以和应该发展哪些领域符合他们的最大利益。</p><h4 id="在高级酒吧以上的促销活动中要切合实际"><a href="#在高级酒吧以上的促销活动中要切合实际" class="headerlink" title="在高级酒吧以上的促销活动中要切合实际"></a>在高级酒吧以上的促销活动中要切合实际</h4><p>通常，晋升到高级职位主要是基于获得技能、展示这些技能并产生影响。但是，在高级工程师级别之上，还有其他因素在起作用。</p><p>首先，可能有多少人可以晋升到更高级别的预算限制。有些地方需要一个商业案例，说明为什么给定的团队或区域需要领导、员工或首席工程师。如果没有商业案例，您可能无法获得晋升。即使您可能有公平的晋升机会，也是如此。</p><p>其次，在高级工程师级别以上，您可能会发现很难找到足够大且影响力足以保证晋升的项目。例如，您的团队可能正忙于交付小的、增量的功能，这些功能没有什么复杂性，但具有可观的商业价值。几乎可以肯定，仅仅在这里工作出色，您不会被提升到高级级别。在这种情况下，您需要掌控自己的职业并决定如何前进。你是否在等待新的机会到来？您是否调动团队来领导复杂而有影响力的绿地项目的工作？您是否提出了一项具有巨大业务影响的新计划，说服利益相关者启动并最终领导它？没有简单的答案：你必须采取主动，争取支持，</p><p><img src="https://blog.pragmaticengineer.com/content/images/2019/10/levels-1.png" alt="img"></p><p><strong>随着您的职业阶梯上升，进入下一个级别变得越来越难。</strong>这是开发人员阶梯上的类似挑战，就像管理一样。从经理到总监通常同样困难，就像从高级工程师到员工或原则一样。</p><h2 id="将目光投向促销"><a href="#将目光投向促销" class="headerlink" title="将目光投向促销"></a>将目光投向促销</h2><p>一旦您了解晋升流程的运作方式、评估自己并让您的经理站在您这边，就该集中注意力了。</p><h4 id="设定目标以缩小您在下一级别缺乏的领域的差距"><a href="#设定目标以缩小您在下一级别缺乏的领域的差距" class="headerlink" title="设定目标以缩小您在下一级别缺乏的领域的差距"></a>设定目标以缩小您在下一级别缺乏的领域的差距</h4><p>毫无疑问，您需要在多个领域变得更好或展示影响力。这可能涉及软件工程、有影响力的执行、设计复杂问题的解决方案、与他人更好地协作等领域。</p><p>设定可帮助您实现目标的 SMART 目标 - 具体、可衡量、可实现、现实、及时。设定只取决于你自己的目标，而不取决于外部因素，比如被给予机会。例如，如果您确定要改进的领域是在架构上变得更好，那么不要设定构建复杂项目的通用目标。但是您可以设定一个目标，每月至少彻底审查一份提案，在该领域指导至少一名初级工程师 3 个月，或阅读相关书籍并在接下来的 2 个月内向您的团队和组织展示学习成果。如果你被确认领导一个项目，你可以设定一个目标，让两个比你高的人审查你的提案，他们在你的团队之外。</p><h4 id="采取行动并承担责任，就像您已经处于下一个级别一样"><a href="#采取行动并承担责任，就像您已经处于下一个级别一样" class="headerlink" title="采取行动并承担责任，就像您已经处于下一个级别一样"></a>采取行动并承担责任，就像您已经处于下一个级别一样</h4><p>有两种促销情况。一个是非常简单的：毫无疑问，工程师已经在下一个级别执行了很长时间。另一个更具挑战性：这个人表现出很多希望，但有一些地方他们没有达到下一个层次。第二种促销案例是抛硬币类型，结果可能以任何一种方式进行。</p><p>当您为升职而努力时，目标是在下一个级别上始终如一地表现：不要仅将其限制在您的重点领域。如果您的目标是高层，而您团队的项目面临风险，请建立并帮助整个项目取得成功。如果你的经理要求志愿者做一件无聊但重要的家务活，而且没有人加紧努力，请考虑举手。在粉碎这项工作的基础上，自动化它的一部分，让团队中的下一个人更容易完成它。</p><h4 id="记录您的成就和影响"><a href="#记录您的成就和影响" class="headerlink" title="记录您的成就和影响"></a>记录您的成就和影响</h4><p>当您的经理或您整理升职案例的时候到了，第一个问题将是关于您取得的成就，这保证了这次升职。到那个时候，你会忘记你所做的很多伟大的工作。因此，提前开始并开始写下您正在完成的所有工作。</p><p>开始一个<a href="https://blog.pragmaticengineer.com/work-log-template-for-software-engineers/">工作日志文件</a>或类似的东西，你会不断更新。<a href="https://blog.pragmaticengineer.com/work-log-template-for-software-engineers/">这是我创建的 Google Doc 模板</a>。与您的经理分享此信息，以便他们也了解您所做的所有工作。没有人比你更了解你所做的工作。你可能会因为你完成了多少额外的事情而让你的经理大吃一惊。当你得到晋升时，你会让你们的生活更轻松。</p><p>考虑针对下一个职业阶梯级别<a href="https://blog.pragmaticengineer.com/performance-review-template-and-example-for-software-engineers/">进行自我评估</a>，列出您认为证明您已经证明在下一个级别工作的例子。向您的经理寻求反馈，并使用此审查来确定您可以努力缩小的下一个级别的差距。</p><h2 id="获得帮助和频繁的反馈"><a href="#获得帮助和频繁的反馈" class="headerlink" title="获得帮助和频繁的反馈"></a>获得帮助和频繁的反馈</h2><p>争取晋升的过程并不短：可能需要几个月的时间。很容易忘记自己的表现，以及您是否仍然在证明自己处于下一个级别的目标上。</p><h4 id="在公司找个导师，帮你"><a href="#在公司找个导师，帮你" class="headerlink" title="在公司找个导师，帮你"></a>在公司找个导师，帮你</h4><p>虽然您的经理可能会在您的升职工作中站在您这边，但他们能给您的反馈也有限。您可以<a href="https://blog.pragmaticengineer.com/developers-mentoring-other-developers/">通过获得一位导师（另一位工程师）</a>来加速您的职业发展。</p><p>尝试找到已经处于下一个级别的开发人员。更好的是，如果他们在公司内得到提拔。向他们寻求指导，特别是在成长到一个新的水平上。与他们分享您的评估和目标，并寻求反馈和帮助以帮助您成长到更高的水平。</p><p>在我的公司内，我注意到主动建立此类指导的开发人员看到了多种好处。一方面，他们根据导师的反馈对自己的成长方式变得更具战略性。这些导师通常在公司工作的时间更长，并帮助工程师了解促销活动中一些不太清楚的部分。其次，即使他们没有得到提升，有导师的开发人员也更容易反弹。他们有自己的导师，他们投资于让他们更上一层楼。这使这些开发人员更容易团结一致，继续在他们的游戏中保持出色，并在下一个周期进行推广。</p><h4 id="要求定期、明确的反馈"><a href="#要求定期、明确的反馈" class="headerlink" title="要求定期、明确的反馈"></a>要求定期、明确的反馈</h4><p>设定目标并为之努力是一回事。但是，尤其是当您正在努力实现升职等重要里程碑时，定期获得有关您的工作方式的反馈同样重要。</p><p>注意定期向经理展示您认为自己取得的进展。向他们询问有关您在下一级别的进展情况的反馈。尽早进行对话，了解他们是否支持您在下一个周期获得晋升。即使答案是“还没有”，让他们帮助定义可操作的事情，如果你完成了，你将为下一个级别做好准备。</p><h4 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h4><p><a href="https://newsletter.pragmaticengineer.com/">订阅我的每周通讯</a>，为工程经理和高级工程师提供建议、观察和灵感。</p><h2 id="投入工作"><a href="#投入工作" class="headerlink" title="投入工作"></a>投入工作</h2><p>如果您已向您的经理和导师明确表示您正在为晋升而努力，请投入工作。在提名前的几个月里，加倍努力在更高的水平上表现，完成工作并帮助他人。</p><h4 id="不要疏远你的同龄人"><a href="#不要疏远你的同龄人" class="headerlink" title="不要疏远你的同龄人"></a>不要疏远你的同龄人</h4><p>我有时会看到工程师犯的一个错误是过于专注于<em>他们的</em>晋升，以至于最终损害了团队。到了升职时间，他们往往最终没有升职，因为很明显，他们与优秀的团队合作者背道而驰。越来越多的公司小心翼翼——理所当然！- 不提拔拉低团队的人。</p><p>为了实现您为晋升而设定的目标，让人们避开是一个糟糕的策略。首先，这是非常短期的思考。在晋升时可能会要求您可能走过的同龄人提供反馈。但即使他们不是，这也是不成熟的标志。您获得的资历越高，就越期望您成为一名出色的团队合作者，<em>同时取得</em>可靠的成绩。要达到平衡并不总是那么容易。但是，如果您发现自己以一种让团队中的人感到不安的方式推进自己的目标，请考虑改变您的方法以提高协作性。</p><h4 id="即使你觉得口袋里有东西，也不要退缩"><a href="#即使你觉得口袋里有东西，也不要退缩" class="headerlink" title="即使你觉得口袋里有东西，也不要退缩"></a>即使你觉得口袋里有东西，也不要退缩</h4><p>有一次，开发人员与他们的经理设定了目标，如果他们成功领导并交付 ComplexProjectX，他们将获得晋升。项目进展顺利，人就升职了。此人一听这好消息，一脚踹开，放下了这个项目，没有委托给其他人。随着项目的推出，越来越多的问题浮出水面，没有人采取行动。最终，不得不恢复推出。</p><p>这发生在晋升委员会讨论这位工程师的案子之前。在讨论中，他们一致认为，虽然这个人在很多方面都表现出很高的技能，但他们通过从方向盘上消失的第11个小时来表现出不成熟。没有沟通，也没有很好的解释为什么会发生这种情况。该人在那个周期没有得到提升。</p><h2 id="脚踏实地"><a href="#脚踏实地" class="headerlink" title="脚踏实地"></a>脚踏实地</h2><h4 id="不要相信任何向您承诺“肯定会升职”的人。"><a href="#不要相信任何向您承诺“肯定会升职”的人。" class="headerlink" title="不要相信任何向您承诺“肯定会升职”的人。"></a>不要相信任何向您承诺“肯定会升职”的人。</h4><p>我告诉我团队中的所有工程师的第一件事是，我和任何经理都不能保证“肯定会升职”。如果有人告诉他们这些，请不要相信。我见过太多的开发人员被这样的承诺烧毁。即使有最好的经理，也有很多原因导致“确定”的晋升不会实现。</p><p>首先，任何经理都可能会意外离开。最常见的苦涩故事是这样的：<em>“X 经理答应我会升职，因为我做得很好。然后他们离开了。我的新经理没有兑现这个承诺，决定不提拔我”。</em>第二个原因是，任何经理都可能误判他们的直属部门的表现或公司晋升的政治局势。相信关于“已经在口袋里”类型的声明的好消息很诱人：不要。如果你以表面价值接受这样的承诺，无论它们可能是多么真诚，你都会让自己失望。</p><h4 id="不要让晋升成为你唯一的目标"><a href="#不要让晋升成为你唯一的目标" class="headerlink" title="不要让晋升成为你唯一的目标"></a>不要让晋升成为你唯一的目标</h4><p>无论您在下一级别的表现如何，无论您的经理多么支持您，您都可能不会得到提升。如果你的唯一目标是升职本身，你会士气低落，可能会考虑辞职并寻找新工作，仅仅因为结果本身。</p><p>我曾经有一位我强烈支持的工程师，我 100% 相信他们会得到晋升。尽管我为这个人而战，但他们仍然没有走上连锁店为他们辩护。此后，我更加致力于帮助这位工程师在下一个周期中获得认可。幸运的是，这位开发人员不仅关注结果，而且同样关心其他领域的发展。下一次，他们粉碎了晋升过程，继续保持高增长轨迹。</p><p><strong>如果你的主要目标是职业发展，即使你没有得到提升，你也会获得宝贵的技能。</strong>这些技能可能是传达工程最佳实践、指导他人、领导项目、分享知识等。专注于这些技能，而不是仅仅提升。根据贵公司遵循的流程，促销会成功还是失败。但没有人能夺走你的成长。</p><h4 id="促销不是获得正面反馈的唯一途径"><a href="#促销不是获得正面反馈的唯一途径" class="headerlink" title="促销不是获得正面反馈的唯一途径"></a>促销不是获得正面反馈的唯一途径</h4><p>许多人将晋升视为对工作出色的证明。然而，虽然成功的促销确实意味着出色的反馈，但您获得的大部分正面认可不会通过促销获得。</p><p>你每天都会从和你一起工作的人那里得到反馈，他们会说“<em>谢谢</em>”、“<em>你真的帮了我</em>”或“<em>没有你我会被困更长时间</em>”。你会从你的经理和导师那里得到反馈。而且，当然，还有正式的绩效评估，您的经理还将在其中总结您所做的出色工作 - 以及需要改进的领域。获得奖金或加薪也是所有积极的反馈——所有这些都将比晋升更频繁。</p><h4 id="保持耐心并保持积极态度。这是一场漫长的比赛。"><a href="#保持耐心并保持积极态度。这是一场漫长的比赛。" class="headerlink" title="保持耐心并保持积极态度。这是一场漫长的比赛。"></a>保持耐心并保持积极态度。这是一场漫长的比赛。</h4><p>我有一位有几年经验的才华横溢的开发人员加入了我的团队，他渴望达到高级水平。他们有一个朋友最近晋升到了这个级别，他们觉得这个朋友在他们之前。这个人很沮丧，在经过他们的自我评估后，我告诉他们，与下一个级别相比，他们有太多的差距，无法在本周期晋升。我说，即使他们投入工作，我也看不到他们在下一个周期之前升职，也就是 9 个月之后。我建议我们制定一个计划来实现这一目标。</p><p>首先，这个人很不高兴，认为我已经为他们准备好了。慢慢地，冷静下来之后，我们制定了一个计划。一步一步地，我们取得了进展，他们开始意识到他们需要做多少工作。最终，9个月后，他们升职了。他们还不到5年的经验，已经是高级水平了。作为参考，我花了更长的时间才能达到相同的水平。尽管如此，与他们不同的是，我从未感到落后。</p><p>额外的 6 个月或 12 个月会对您的职业生涯产生影响吗？你越早接触它，你就越认为它会起作用。然而，一段时间后，您可能会意识到这不是短跑，而是马拉松。<strong>虽然您可能会在第一份工作几年后获得晋升，但随着时间的推移，晋升会放缓：获得晋升将更具挑战性。</strong></p><p>玩长时间的游戏。保持积极的态度并专注于您持续的专业成长。将您的成长视为一次旅程，而不是促销的竞争。这样做你会更加平衡。</p><h2 id="帮助别人"><a href="#帮助别人" class="headerlink" title="帮助别人"></a>帮助别人</h2><p>在公司内晋升从来都不是一件容易的事。当您在这方面取得成功时，请考虑回馈并收留某人，帮助他们成长。让其他人知道您愿意指导他人。如果您在团队中看到某人具有良好的成长潜力并且您觉得可以提供帮助，请主动提出指导他们。</p><p>即使你还没有得到提升，也要帮助他人成长并因他们的成长而获得认可。如果你所在的公司有更重量级的晋升流程，有同行评审，你可能会被其他人要求对他们的晋升进行同行评审。如果您在更高级别加入，其他工程师可能会向您寻求有关发展的建议。</p><p><strong>不要忘记，升职是对你成长的认可。最好的成长方式之一就是</strong><a href="https://blog.pragmaticengineer.com/developers-mentoring-other-developers/"><strong>通过指导</strong></a><strong>来</strong><a href="https://blog.pragmaticengineer.com/developers-mentoring-other-developers/"><strong>教导他人</strong></a><strong>。</strong>保持平易近人和乐于助人的态度，并为此付出代价。你会学到更多，结交许多盟友，这样你的职业生涯将变得更加愉快。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>幸存者偏差</title>
      <link href="/zhb233go.github.io/2021/11/18/3-xing-cun-zhe-pian-chai/"/>
      <url>/zhb233go.github.io/2021/11/18/3-xing-cun-zhe-pian-chai/</url>
      
        <content type="html"><![CDATA[<h1 id="幸存者偏差"><a href="#幸存者偏差" class="headerlink" title="幸存者偏差"></a>幸存者偏差</h1><ul><li><p>二战时,美国邀请沃德教授利用统计学知识加强飞机。机翼是最容易击中的<br>位置机尾则是最少被击中的位置，沃德教授的结论：”是应该加强机尾的保护”,<br>而军方指挥官认为:”应该加强机翼的保护,因为这是最容易被击<br>中的地方”。</p></li><li><p>我们太容易在编造历史理论时忘记已经死去的人,但这个问题不仅存在于<br>历史中,还存在于我们在所有领域打造样本并搜集证据的方式中。我们<br>把这种扭曲称为偏差,也就是你所看到的事物与真正存在的庸物之间的差异。<br>我们的认知系统对于不出现在我们眼前或不引起我们感情注意<br>的事物可能没有反应。</p></li><li><p>我们天生肤浅,只注意我们看到的东西,不注意没给<br>我们留下生动印象的东西。我们向沉默的证据发动了双重战争。潜意识<br>的推理机制的确存在这样的机制忽视沉默的证据,即使我们知道需要考虑它。<br>不进入视线则不进入大脑我们对抽象的东西怀有天性上的甚至行动上的蔑视。</p></li></ul><p>—–节选自《黑天鹅》</p><p>作者:纳西姆·尼古拉斯·塔勒布</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超前消费的利与弊?</title>
      <link href="/zhb233go.github.io/2021/11/17/2-chao-qian-xiao-fei-de-li-yu-bi/"/>
      <url>/zhb233go.github.io/2021/11/17/2-chao-qian-xiao-fei-de-li-yu-bi/</url>
      
        <content type="html"><![CDATA[<h1 id="超前消费的利与弊"><a href="#超前消费的利与弊" class="headerlink" title="超前消费的利与弊?"></a>超前消费的利与弊?</h1><p>就在昨天,我接到一个电话,说是想邀请我去招商银行办一张信用卡,</p><p>我当时没有答应他说是考虑一下，之后我就想这种形式的消费对我来说的利弊如何？</p><p>在我看来,就像花呗、信用卡之类形式的消费方式就与</p><p>货款无异,都是透支你的个人信用、在你没有这个经济实力的</p><p>情况下,银行给你提供这种方式让你消费,而你恰好踏入这个陷井,因</p><p>为银行给你支出的钱就是从其它人流入的钱流转,银行通过流转收取利息。</p><ul><li>超前消费的利:老话说的好!早卖早享受,晚买享折扣!但是对于你想要购</li></ul><p>买的物品没有足够的资金银行就跟你提供这种方式,抵押你的信用、</p><p>促使你去消费这样就使你能够在每月付出较少代价情况,购买你想要的物品,</p><ul><li>超前消费的弊:虽然你能够提前享受购买物品的快感,去透支你的信用、</li></ul><p>但是它是限制的,并且关键在于你有能力还上你的信用,在你资金链</p><p>充足情况下,信用能帮你周转，但你不能靠此无为乐,</p><p>透支信用的后果就是对自身信用的破坏这种消费形式属于风险</p><p>不大,但后果严重,就如同在悬崖攀爬过程中风险不大。因为你在</p><p>保险绳,就相当于你的资金链,一但你的保险绳断开、跌下谷底便是粉身碎骨。</p><ul><li>总结:对于我来说、自身在可支配资金情况下尽减少或者不用</li></ul><p>这种消费,因为只要你习惯这种形式的消费,你就没有了对他的畏惧感。</p><p>俗话说:淹死的都是会水的。小心驶得万年船。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你眼中的世界</title>
      <link href="/zhb233go.github.io/2021/11/16/1-ni-yan-zhong-de-shi-jie/"/>
      <url>/zhb233go.github.io/2021/11/16/1-ni-yan-zhong-de-shi-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="你的眼里是什么样的世界就是什么样的"><a href="#你的眼里是什么样的世界就是什么样的" class="headerlink" title="你的眼里是什么样的世界就是什么样的,"></a>你的眼里是什么样的世界就是什么样的,</h1><ul><li>这个世界很大,而人却很渺小人就如同马路上的沙粒微不足道,</li></ul><p>每个人都有不同的生活环境,从小到大，你眼中的世界是什么样的呢?</p><p>我认为世界是一直在变化的,而人也是一样在成长的，人眼中的世界是很局限的，</p><p>人的一生所经历的事物也是有限的,你能经历的就</p><p>只是你身边所能接触到的事与物,在一方面来说,这个世界是有一套它自身</p><p>运转的规则,你只能只身于世界的一个小环境中用你的眼睛去观察</p><p>成的一小部分,所以这个你所认识的世界仅仅是你看到的一小部分、而</p><p>你就认为这就是世界的全部,心中就难免与他所看的世界产生差距。</p><p>另一方面、世界是不断变化的,你所观察到的东西也是不断的变化,</p><p>而且人的心智上的成长也会影响你观察这个世界而得出不同的结</p><p>论。所以说,虽然这个世界有这么多我们看不清的事物和道理，</p><p>但只要我们一直保持独立的思考，并且能拥有一套我们去解释这个世界</p><p>的方法，我们就可以过好大部分的人生了!</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
